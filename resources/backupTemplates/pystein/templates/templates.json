[
    {
      "id": "BlobTrigger-CSharp",
      "runtime": "2",
      "files": {
        "readme.md": "# BlobTrigger - C<span>#</span>\r\n\r\nThe `BlobTrigger` makes it incredibly easy to react to new Blobs inside of Azure Blob Storage. This sample demonstrates a simple use case of processing data from a given Blob using C#.\r\n\r\n## How it works\r\n\r\nFor a `BlobTrigger` to work, you provide a path which dictates where the blobs are located inside your container, and can also help restrict the types of blobs you wish to return. For instance, you can set the path to `samples/{name}.png` to restrict the trigger to only the samples path and only blobs with \".png\" at the end of their name.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
        "run.csx": "public static void Run(Stream myBlob, string name, ILogger log)\r\n{\r\n    log.LogInformation($\"C# Blob trigger function Processed blob\\n Name:{name} \\n Size: {myBlob.Length} Bytes\");\r\n}\r\n",
        "sample.dat": "samples-workitems/workitem.txt"
      },
      "function": {
        "bindings": [
          {
            "name": "myBlob",
            "type": "blobTrigger",
            "direction": "in",
            "path": "samples-workitems/{name}",
            "connection": ""
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "BlobTrigger",
        "description": "$BlobTrigger_description",
        "name": "Azure Blob Storage trigger",
        "language": "C#",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "blob",
        "enabledInTryMode": true,
        "userPrompt": [
          "connection",
          "path"
        ]
      }
    },
    {
      "id": "BlobTrigger-Custom",
      "runtime": "2",
      "files": {},
      "function": {
        "bindings": [
          {
            "name": "myBlob",
            "type": "blobTrigger",
            "direction": "in",
            "path": "samples-workitems/{name}",
            "connection": ""
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "BlobTrigger",
        "description": "$BlobTrigger_description",
        "name": "Azure Blob Storage trigger",
        "language": "Custom",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "blob",
        "enabledInTryMode": true,
        "userPrompt": [
          "connection",
          "path"
        ]
      }
    },
    {
      "id": "BlobTrigger-JavaScript",
      "runtime": "2",
      "files": {
        "index.js": "module.exports = async function (context, myBlob) {\r\n    context.log(\"JavaScript blob trigger function processed blob \\n Blob:\", context.bindingData.blobTrigger, \"\\n Blob Size:\", myBlob.length, \"Bytes\");\r\n};",
        "readme.md": "# BlobTrigger - JavaScript\r\n\r\nThe `BlobTrigger` makes it incredibly easy to react to new Blobs inside of Azure Blob Storage. This sample demonstrates a simple use case of processing data from a given Blob using JavaScript.\r\n\r\n## How it works\r\n\r\nFor a `BlobTrigger` to work, you provide a path which dictates where the blobs are located inside your container, and can also help restrict the types of blobs you wish to return. For instance, you can set the path to `samples/{name}.png` to restrict the trigger to only the samples path and only blobs with \".png\" at the end of their name.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
        "sample.dat": "samples-workitems/workitem.txt"
      },
      "function": {
        "bindings": [
          {
            "name": "myBlob",
            "type": "blobTrigger",
            "direction": "in",
            "path": "samples-workitems/{name}",
            "connection": ""
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "BlobTrigger",
        "description": "$BlobTrigger_description",
        "name": "Azure Blob Storage trigger",
        "language": "JavaScript",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "blob",
        "enabledInTryMode": true,
        "userPrompt": [
          "connection",
          "path"
        ]
      }
    },
    {
      "id": "BlobTrigger-PowerShell",
      "runtime": "2",
      "files": {
        "readme.md": "# BlobTrigger - PowerShell\r\n\r\nThe `BlobTrigger` makes it incredibly easy to react to new Blobs inside of [Azure Blob Storage](https://azure.microsoft.com/en-us/services/storage/blobs/).\r\nThis sample demonstrates a simple use case of processing data from a given Blob using PowerShell.\r\n\r\n## How it works\r\n\r\nFor a `BlobTrigger` to work, you provide a path which dictates where the blobs are located inside your container, and can also help restrict the types of blobs you wish to return. For instance, you can set the path to `samples/{name}.png` to restrict the trigger to only the samples path and only blobs with \".png\" at the end of their name.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation\r\n",
        "run.ps1": "# Input bindings are passed in via param block.\r\nparam([byte[]] $InputBlob, $TriggerMetadata)\r\n\r\n# Write out the blob name and size to the information log.\r\nWrite-Host \"PowerShell Blob trigger function Processed blob! Name: $($TriggerMetadata.Name) Size: $($InputBlob.Length) bytes\"\r\n",
        "sample.dat": "samples-workitems/workitem.txt"
      },
      "function": {
        "bindings": [
          {
            "name": "InputBlob",
            "type": "blobTrigger",
            "direction": "in",
            "path": "samples-workitems/{name}",
            "connection": ""
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "BlobTrigger",
        "description": "$BlobTrigger_description",
        "name": "Azure Blob Storage trigger",
        "language": "PowerShell",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "blob",
        "enabledInTryMode": true,
        "userPrompt": [
          "connection",
          "path"
        ]
      }
    },
    {
      "id": "BlobTrigger-Python",
      "runtime": "2",
      "files": {
        "readme.md": "# BlobTrigger - Python\r\n\r\nThe `BlobTrigger` makes it incredibly easy to react to new Blobs inside of Azure Blob Storage. This sample demonstrates a simple use case of processing data from a given Blob using Python.\r\n\r\n## How it works\r\n\r\nFor a `BlobTrigger` to work, you provide a path which dictates where the blobs are located inside your container, and can also help restrict the types of blobs you wish to return. For instance, you can set the path to `samples/{name}.png` to restrict the trigger to only the samples path and only blobs with \".png\" at the end of their name.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
        "sample.dat": "samples-workitems/workitem.txt",
        "__init__.py": "import logging\r\n\r\nimport azure.functions as func\r\n\r\n\r\ndef main(myblob: func.InputStream):\r\n    logging.info(f\"Python blob trigger function processed blob \\n\"\r\n                 f\"Name: {myblob.name}\\n\"\r\n                 f\"Blob Size: {myblob.length} bytes\")\r\n"
      },
      "function": {
        "scriptFile": "__init__.py",
        "bindings": [
          {
            "name": "myblob",
            "type": "blobTrigger",
            "direction": "in",
            "path": "samples-workitems/{name}",
            "connection": ""
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "BlobTrigger",
        "description": "$BlobTrigger_description",
        "name": "Azure Blob Storage trigger",
        "language": "Python",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "blob",
        "enabledInTryMode": true,
        "userPrompt": [
          "connection",
          "path"
        ],
        "filters": [
          "Python3"
        ]
      }
    },
    {
      "id": "BlobTrigger-Python-Preview",
      "runtime": "2",
      "files": {
        "blob_trigger_template.md": "# Azure Functions: Blob Trigger in Python\r\n\r\n## Blob Trigger\r\n\r\nThe Blob storage trigger starts a function when a new or updated blob is detected. The blob contents are provided as input to the function. The Azure Blob storage trigger requires a general-purpose storage account. Storage V2 accounts with hierarchical namespaces are also supported.\r\n\r\n## Using the Template\r\n\r\nFollowing is an example code snippet for Blob Trigger using the [Python programming model V2](https://aka.ms/pythonprogrammingmodel) (currently in Preview).\r\n\r\n```python\r\nimport logging\r\n\r\nimport azure.functions as func\r\n\r\napp = func.FunctionApp()\r\n\r\n@app.function_name(name=\"BlobTrigger1\")\r\n@app.blob_trigger(arg_name=\"myblob\", path=\"samples-workitems/{name}\",\r\n                  connection=\"\")\r\ndef test_function(myblob: func.InputStream):\r\n   logging.info(f\"Python blob trigger function processed blob \\n\"\r\n                f\"Name: {myblob.name}\\n\"\r\n                f\"Blob Size: {myblob.length} bytes\")\r\n```\r\n\r\nTo run the code snippet generated through the command palette, note the following:\r\n\r\n- The function application is defined and named `app`.\r\n- Confirm that the parameters within the trigger reflect values that correspond with your storage account.\r\n- The name of the file must be `function_app.py`.\r\n  \r\nNote that Blob input and output bindings are also supported in Azure Functions. To learn more, see [Azure Blob storage bindings overview](https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-blob?tabs=in-process%2Cextensionv5%2Cextensionv3&pivots=programming-language-python)\r\n\r\n## Programming Model V2 (Preview)\r\n\r\nThe new programming model in Azure Functions Python delivers an experience that aligns with Python development principles, and subsequently with commonly used Python frameworks. \r\n\r\nThe improved programming model requires fewer files than the default model, and specifically eliminates the need for a configuration file (`function.json`). Instead, triggers and bindings are represented in the `function_app.py` file as decorators. Moreover, functions can be logically organized with support for multiple functions to be stored in the same file. Functions within the same function application can also be stored in different files, and be referenced as blueprints.\r\n\r\nTo learn more about using the new Python programming model for Azure Functions, see the [Azure Functions Python developer guide](https://aka.ms/pythondeveloperguide). Note that in addition to the documentation, [hints](https://aka.ms/functions-python-hints) are available in code editors that support type checking with PYI files.\r\n\r\nTo learn more about the new programming model for Azure Functions in Python, see [Programming Models in Azure Functions](https://aka.ms/functions-programming-models).",
        "function_app.py": "import logging\n\nimport azure.functions as func\n\napp = func.FunctionApp()\n\n@app.function_name(name=\"BlobTrigger1\")\n@app.blob_trigger(arg_name=\"myblob\", path=\"samples-workitems/{name}\",\n                  connection=\"\")\ndef test_function(myblob: func.InputStream):\n   logging.info(f\"Python blob trigger function processed blob \\n\"\n                f\"Name: {myblob.name}\\n\"\n                f\"Blob Size: {myblob.length} bytes\")"
      },
      "metadata": {
        "defaultFunctionName": "BlobTrigger",
        "description": "$BlobTrigger_description",
        "name": "Azure Blob Storage trigger",
        "language": "Python",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "blob",
        "enabledInTryMode": true,
        "userPrompt": [
          "connection",
          "path"
        ],
        "filters": [
          "Python3"
        ]
      }
    },
    {
      "id": "BlobTrigger-Python-Preview-Append",
      "runtime": "2",
      "files": {
        "blob_trigger_template.md": "# Azure Functions: Blob Trigger in Python\r\n\r\n## Blob Trigger\r\n\r\nThe Blob storage trigger starts a function when a new or updated blob is detected. The blob contents are provided as input to the function. The Azure Blob storage trigger requires a general-purpose storage account. Storage V2 accounts with hierarchical namespaces are also supported.\r\n\r\n## Using the Template\r\n\r\nFollowing is an example code snippet for Blob Trigger using the [Python programming model V2](https://aka.ms/pythonprogrammingmodel) (currently in Preview).\r\n\r\n```python\r\nimport logging\r\n\r\nimport azure.functions as func\r\n\r\napp = func.FunctionApp()\r\n\r\n@app.function_name(name=\"BlobTrigger1\")\r\n@app.blob_trigger(arg_name=\"myblob\", path=\"samples-workitems/{name}\",\r\n                  connection=\"\")\r\ndef test_function(myblob: func.InputStream):\r\n   logging.info(f\"Python blob trigger function processed blob \\n\"\r\n                f\"Name: {myblob.name}\\n\"\r\n                f\"Blob Size: {myblob.length} bytes\")\r\n```\r\n\r\nTo run the code snippet generated through the command palette, note the following:\r\n\r\n- The function application is defined and named `app`.\r\n- Confirm that the parameters within the trigger reflect values that correspond with your storage account.\r\n- The name of the file must be `function_app.py`.\r\n  \r\nNote that Blob input and output bindings are also supported in Azure Functions. To learn more, see [Azure Blob storage bindings overview](https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-blob?tabs=in-process%2Cextensionv5%2Cextensionv3&pivots=programming-language-python)\r\n\r\n## Programming Model V2 (Preview)\r\n\r\nThe new programming model in Azure Functions Python delivers an experience that aligns with Python development principles, and subsequently with commonly used Python frameworks. \r\n\r\nThe improved programming model requires fewer files than the default model, and specifically eliminates the need for a configuration file (`function.json`). Instead, triggers and bindings are represented in the `function_app.py` file as decorators. Moreover, functions can be logically organized with support for multiple functions to be stored in the same file. Functions within the same function application can also be stored in different files, and be referenced as blueprints.\r\n\r\nTo learn more about using the new Python programming model for Azure Functions, see the [Azure Functions Python developer guide](https://aka.ms/pythondeveloperguide). Note that in addition to the documentation, [hints](https://aka.ms/functions-python-hints) are available in code editors that support type checking with PYI files.\r\n\r\nTo learn more about the new programming model for Azure Functions in Python, see [Programming Models in Azure Functions](https://aka.ms/functions-programming-models).",
        "function_app.py": "@app.function_name(name=\"BlobTrigger1\")\n@app.blob_trigger(arg_name=\"myblob\", path=\"samples-workitems/{name}\",\n                  connection=\"\")\ndef test_function(myblob: func.InputStream):\n   logging.info(f\"Python blob trigger function processed blob \\n\"\n                f\"Name: {myblob.name}\\n\"\n                f\"Blob Size: {myblob.length} bytes\")"
      },
      "metadata": {
        "defaultFunctionName": "BlobTrigger",
        "description": "$BlobTrigger_description",
        "name": "Azure Blob Storage trigger",
        "language": "Python",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "blob",
        "enabledInTryMode": true,
        "userPrompt": [
          "connection",
          "path"
        ],
        "filters": [
          "Python3"
        ]
      }
    },
    {
      "id": "BlobTrigger-TypeScript",
      "runtime": "2",
      "files": {
        "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\r\n\r\nconst blobTrigger: AzureFunction = async function (context: Context, myBlob: any): Promise<void> {\r\n    context.log(\"Blob trigger function processed blob \\n Name:\", context.bindingData.name, \"\\n Blob Size:\", myBlob.length, \"Bytes\");\r\n};\r\n\r\nexport default blobTrigger;\r\n",
        "readme.md": "# BlobTrigger - TypeScript\r\n\r\nThe `BlobTrigger` makes it incredibly easy to react to new Blobs inside of Azure Blob Storage. This sample demonstrates a simple use case of processing data from a given Blob using TypeScript.\r\n\r\n## How it works\r\n\r\nFor a `BlobTrigger` to work, you provide a path which dictates where the blobs are located inside your container, and can also help restrict the types of blobs you wish to return. For instance, you can set the path to `samples/{name}.png` to restrict the trigger to only the samples path and only blobs with \".png\" at the end of their name.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
        "sample.dat": "samples-workitems/workitem.txt"
      },
      "function": {
        "bindings": [
          {
            "name": "myBlob",
            "type": "blobTrigger",
            "direction": "in",
            "path": "samples-workitems/{name}",
            "connection": ""
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "BlobTrigger",
        "description": "$BlobTrigger_description",
        "name": "Azure Blob Storage trigger",
        "language": "TypeScript",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "blob",
        "enabledInTryMode": true,
        "userPrompt": [
          "connection",
          "path"
        ]
      }
    },
    {
      "id": "CosmosDBTrigger-CSharp",
      "runtime": "2",
      "files": {
        "run.csx": "#r \"Microsoft.Azure.DocumentDB.Core\"\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing Microsoft.Azure.Documents;\r\n\r\npublic static void Run(IReadOnlyList<Document> input, ILogger log)\r\n{\r\n    if (input != null && input.Count > 0)\r\n    {\r\n        log.LogInformation(\"Documents modified \" + input.Count);\r\n        log.LogInformation(\"First document Id \" + input[0].Id);\r\n    }\r\n}\r\n"
      },
      "function": {
        "bindings": [
          {
            "type": "cosmosDBTrigger",
            "name": "input",
            "direction": "in",
            "connectionStringSetting": "",
            "databaseName": "",
            "collectionName": "",
            "leaseCollectionName": "leases",
            "createLeaseCollectionIfNotExists": true
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "CosmosTrigger",
        "description": "$CosmosDBTrigger_description",
        "name": "Azure Cosmos DB trigger",
        "language": "C#",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "cosmosDB",
        "enabledInTryMode": false,
        "userPrompt": [
          "connectionStringSetting",
          "databaseName",
          "collectionName",
          "leaseCollectionName",
          "createLeaseCollectionIfNotExists"
        ]
      }
    },
    {
      "id": "CosmosDBTrigger-Custom",
      "runtime": "2",
      "files": {},
      "function": {
        "bindings": [
          {
            "type": "cosmosDBTrigger",
            "name": "documents",
            "direction": "in",
            "leaseCollectionName": "leases",
            "connectionStringSetting": "",
            "databaseName": "",
            "collectionName": "",
            "createLeaseCollectionIfNotExists": true
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "CosmosTrigger",
        "description": "$CosmosDBTrigger_description",
        "name": "Azure Cosmos DB trigger",
        "language": "Custom",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "cosmosDB",
        "enabledInTryMode": false,
        "userPrompt": [
          "connectionStringSetting",
          "databaseName",
          "collectionName",
          "leaseCollectionName",
          "createLeaseCollectionIfNotExists"
        ]
      }
    },
    {
      "id": "CosmosDBTrigger-JavaScript",
      "runtime": "2",
      "files": {
        "index.js": "module.exports = async function (context, documents) {\r\n    if (!!documents && documents.length > 0) {\r\n        context.log('Document Id: ', documents[0].id);\r\n    }\r\n}\r\n",
        "sample.dat": "[\r\n\t{\r\n\t\t\"id\": \"sample\"\r\n\t}\r\n]"
      },
      "function": {
        "bindings": [
          {
            "type": "cosmosDBTrigger",
            "name": "documents",
            "direction": "in",
            "leaseCollectionName": "leases",
            "connectionStringSetting": "",
            "databaseName": "",
            "collectionName": "",
            "createLeaseCollectionIfNotExists": true
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "CosmosTrigger",
        "description": "$CosmosDBTrigger_description",
        "name": "Azure Cosmos DB trigger",
        "language": "JavaScript",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "cosmosDB",
        "enabledInTryMode": false,
        "userPrompt": [
          "connectionStringSetting",
          "databaseName",
          "collectionName",
          "leaseCollectionName",
          "createLeaseCollectionIfNotExists"
        ]
      }
    },
    {
      "id": "CosmosDBTrigger-PowerShell",
      "runtime": "2",
      "files": {
        "run.ps1": "# Input bindings are passed in via param block.\nparam($Documents, $TriggerMetadata)\n\nif ($Documents.Count -gt 0) {\n    Write-Host \"Document Id: $($Documents[0].id)\"\n}\n",
        "sample.dat": "[\r\n\t{\r\n\t\t\"id\": \"sample\"\r\n\t}\r\n]\r\n"
      },
      "function": {
        "bindings": [
          {
            "type": "cosmosDBTrigger",
            "name": "Documents",
            "direction": "in",
            "leaseCollectionName": "leases",
            "connectionStringSetting": "",
            "databaseName": "",
            "collectionName": "",
            "createLeaseCollectionIfNotExists": true
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "CosmosTrigger",
        "description": "$CosmosDBTrigger_description",
        "name": "Azure Cosmos DB trigger",
        "language": "PowerShell",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "cosmosDB",
        "enabledInTryMode": false,
        "userPrompt": [
          "connectionStringSetting",
          "databaseName",
          "collectionName",
          "leaseCollectionName",
          "createLeaseCollectionIfNotExists"
        ]
      }
    },
    {
      "id": "CosmosDBTrigger-Python",
      "runtime": "2",
      "files": {
        "sample.dat": "[\r\n\t{\r\n\t\t\"id\": \"sample\"\r\n\t}\r\n]",
        "__init__.py": "import logging\r\n\r\nimport azure.functions as func\r\n\r\n\r\ndef main(documents: func.DocumentList) -> str:\r\n    if documents:\r\n        logging.info('Document id: %s', documents[0]['id'])\r\n"
      },
      "function": {
        "scriptFile": "__init__.py",
        "bindings": [
          {
            "type": "cosmosDBTrigger",
            "name": "documents",
            "direction": "in",
            "leaseCollectionName": "leases",
            "connectionStringSetting": "",
            "databaseName": "",
            "collectionName": "",
            "createLeaseCollectionIfNotExists": true
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "CosmosTrigger",
        "description": "$CosmosDBTrigger_description",
        "name": "Azure Cosmos DB trigger",
        "language": "Python",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "cosmosDB",
        "enabledInTryMode": false,
        "userPrompt": [
          "connectionStringSetting",
          "databaseName",
          "collectionName",
          "leaseCollectionName",
          "createLeaseCollectionIfNotExists"
        ],
        "filters": [
          "Python3"
        ]
      }
    },
    {
      "id": "CosmosDBTrigger-Python-Preview",
      "runtime": "2",
      "files": {
        "cosmosdb_trigger_template.md": "# Azure Functions: Cosmos DB in Python\r\n\r\n## Cosmos DB Trigger\r\n\r\nThe Azure Cosmos DB Trigger uses the Azure Cosmos DB Change Feed to listen for inserts and updates across partitions. The change feed publishes inserts and updates, not deletions.\r\n\r\n## Using the Template\r\n\r\nFollowing is an example code snippet for Cosmos DB Trigger using the [Python programming model V2](https://aka.ms/pythonprogrammingmodel) (currently in Preview).\r\n\r\n```python\r\nimport logging\r\n\r\nimport azure.functions as func\r\n\r\napp = func.FunctionApp()\r\n\r\n@app.function_name(name=\"CosmosDBTrigger1\")\r\n@app.cosmos_db_trigger(arg_name=\"documents\", database_name=\"\", collection_name=\"\", connection_string_setting=\"\",\r\n lease_collection_name=\"leases\", create_lease_collection_if_not_exists=\"true\")\r\ndef test_function(documents: func.DocumentList) -> str:\r\n    if documents:\r\n        logging.info('Document id: %s', documents[0]['id'])\r\n```\r\n\r\nTo run the code snippet generated through the command palette, note the following:\r\n\r\n- The function application is defined and named `app`.\r\n- Confirm that the parameters within the trigger reflect values that correspond with your storage account.\r\n- The name of the file must be `function_app.py`.\r\n  \r\nNote that Cosmos DB input and output bindings are also supported in Azure Functions. To learn more, see [Azure Cosmos DB storage trigger and bindings overview](https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-cosmosdb-v2?tabs=in-process%2Cfunctionsv2&pivots=programming-language-python)\r\n\r\n## Programming Model V2 (Preview)\r\n\r\nThe new programming model in Azure Functions Python delivers an experience that aligns with Python development principles, and subsequently with commonly used Python frameworks. \r\n\r\nThe improved programming model requires fewer files than the default model, and specifically eliminates the need for a configuration file (`function.json`). Instead, triggers and bindings are represented in the `function_app.py` file as decorators. Moreover, functions can be logically organized with support for multiple functions to be stored in the same file. Functions within the same function application can also be stored in different files, and be referenced as blueprints.\r\n\r\nTo learn more about using the new Python programming model for Azure Functions, see the [Azure Functions Python developer guide](https://aka.ms/pythondeveloperguide). Note that in addition to the documentation, [hints](https://aka.ms/functions-python-hints) are available in code editors that support type checking with PYI files.\r\n\r\nTo learn more about the new programming model for Azure Functions in Python, see [Programming Models in Azure Functions](https://aka.ms/functions-programming-models).",
        "function_app.py": "import logging\r\n\r\nimport azure.functions as func\r\n\r\napp = func.FunctionApp()\r\n\r\n@app.function_name(name=\"CosmosDBTrigger1\")\r\n@app.cosmos_db_trigger(arg_name=\"documents\", database_name=\"\", collection_name=\"\", connection_string_setting=\"\",\r\n lease_collection_name=\"leases\", create_lease_collection_if_not_exists=\"true\")\r\ndef test_function(documents: func.DocumentList) -> str:\r\n    if documents:\r\n        logging.info('Document id: %s', documents[0]['id'])"
      },
      "metadata": {
        "defaultFunctionName": "CosmosTrigger",
        "description": "$CosmosDBTrigger_description",
        "name": "Azure Cosmos DB trigger",
        "language": "Python",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "cosmosDB",
        "enabledInTryMode": false,
        "userPrompt": [
          "connectionStringSetting",
          "databaseName",
          "collectionName",
          "leaseCollectionName",
          "createLeaseCollectionIfNotExists"
        ],
        "filters": [
          "Python3"
        ]
      }
    },
    {
      "id": "CosmosDBTrigger-Python-Preview-Append",
      "runtime": "2",
      "files": {
        "cosmosdb_trigger_template.md": "# Azure Functions: Cosmos DB in Python\r\n\r\n## Cosmos DB Trigger\r\n\r\nThe Azure Cosmos DB Trigger uses the Azure Cosmos DB Change Feed to listen for inserts and updates across partitions. The change feed publishes inserts and updates, not deletions.\r\n\r\n## Using the Template\r\n\r\nFollowing is an example code snippet for Cosmos DB Trigger using the [Python programming model V2](https://aka.ms/pythonprogrammingmodel) (currently in Preview).\r\n\r\n```python\r\nimport logging\r\n\r\nimport azure.functions as func\r\n\r\napp = func.FunctionApp()\r\n\r\n@app.function_name(name=\"CosmosDBTrigger1\")\r\n@app.cosmos_db_trigger(arg_name=\"documents\", database_name=\"\", collection_name=\"\", connection_string_setting=\"\",\r\n lease_collection_name=\"leases\", create_lease_collection_if_not_exists=\"true\")\r\ndef test_function(documents: func.DocumentList) -> str:\r\n    if documents:\r\n        logging.info('Document id: %s', documents[0]['id'])\r\n```\r\n\r\nTo run the code snippet generated through the command palette, note the following:\r\n\r\n- The function application is defined and named `app`.\r\n- Confirm that the parameters within the trigger reflect values that correspond with your storage account.\r\n- The name of the file must be `function_app.py`.\r\n  \r\nNote that Cosmos DB input and output bindings are also supported in Azure Functions. To learn more, see [Azure Cosmos DB storage trigger and bindings overview](https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-cosmosdb-v2?tabs=in-process%2Cfunctionsv2&pivots=programming-language-python)\r\n\r\n## Programming Model V2 (Preview)\r\n\r\nThe new programming model in Azure Functions Python delivers an experience that aligns with Python development principles, and subsequently with commonly used Python frameworks. \r\n\r\nThe improved programming model requires fewer files than the default model, and specifically eliminates the need for a configuration file (`function.json`). Instead, triggers and bindings are represented in the `function_app.py` file as decorators. Moreover, functions can be logically organized with support for multiple functions to be stored in the same file. Functions within the same function application can also be stored in different files, and be referenced as blueprints.\r\n\r\nTo learn more about using the new Python programming model for Azure Functions, see the [Azure Functions Python developer guide](https://aka.ms/pythondeveloperguide). Note that in addition to the documentation, [hints](https://aka.ms/functions-python-hints) are available in code editors that support type checking with PYI files.\r\n\r\nTo learn more about the new programming model for Azure Functions in Python, see [Programming Models in Azure Functions](https://aka.ms/functions-programming-models).",
        "function_app.py": "@app.function_name(name=\"CosmosDBTrigger1\")\n@app.cosmos_db_trigger(arg_name=\"documents\", database_name=\"cosmosdb014\", collection_name=\"testc\", connection_string_setting=\"\",\n lease_collection_name=\"leases\", create_lease_collection_if_not_exists=\"true\")\ndef test_function(documents: func.DocumentList) -> str:\n    if documents:\n        logging.info('Document id: %s', documents[0]['id'])"
      },
      "metadata": {
        "defaultFunctionName": "CosmosTrigger",
        "description": "$CosmosDBTrigger_description",
        "name": "Azure Cosmos DB trigger",
        "language": "Python",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "cosmosDB",
        "enabledInTryMode": false,
        "userPrompt": [
          "connectionStringSetting",
          "databaseName",
          "collectionName",
          "leaseCollectionName",
          "createLeaseCollectionIfNotExists"
        ],
        "filters": [
          "Python3"
        ]
      }
    },
    {
      "id": "CosmosDBTrigger-TypeScript",
      "runtime": "2",
      "files": {
        "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\r\n\r\nconst cosmosDBTrigger: AzureFunction = async function (context: Context, documents: any[]): Promise<void> {\r\n    if (!!documents && documents.length > 0) {\r\n        context.log('Document Id: ', documents[0].id);\r\n    }\r\n}\r\n\r\nexport default cosmosDBTrigger;\r\n",
        "sample.dat": "[\r\n\t{\r\n\t\t\"id\": \"sample\"\r\n\t}\r\n]"
      },
      "function": {
        "bindings": [
          {
            "type": "cosmosDBTrigger",
            "name": "documents",
            "direction": "in",
            "leaseCollectionName": "leases",
            "connectionStringSetting": "",
            "databaseName": "",
            "collectionName": "",
            "createLeaseCollectionIfNotExists": true
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "CosmosTrigger",
        "description": "$CosmosDBTrigger_description",
        "name": "Azure Cosmos DB trigger",
        "language": "TypeScript",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "cosmosDB",
        "enabledInTryMode": false,
        "userPrompt": [
          "connectionStringSetting",
          "databaseName",
          "collectionName",
          "leaseCollectionName",
          "createLeaseCollectionIfNotExists"
        ]
      }
    },
    {
      "id": "DurableFunctionsActivity-CSharp",
      "runtime": "2",
      "files": {
        "run.csx": "/*\n * This function is not intended to be invoked directly. Instead it will be\n * triggered by an orchestrator function.\n * \n * Before running this sample, please:\n * - create a Durable orchestration function\n * - create a Durable HTTP starter function\n */\n\n#r \"Microsoft.Azure.WebJobs.Extensions.DurableTask\"\n\nusing Microsoft.Azure.WebJobs.Extensions.DurableTask;\n\npublic static string Run(string name)\n{\n    return $\"Hello {name}!\";\n}"
      },
      "function": {
        "bindings": [
          {
            "name": "name",
            "type": "activityTrigger",
            "direction": "in"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "Hello",
        "description": "$DurableFunctionsActivity_description",
        "name": "Durable Functions activity",
        "language": "C#",
        "category": [
          "$temp_category_core",
          "$temp_category_durableFunctions"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": []
      }
    },
    {
      "id": "DurableFunctionsActivity-JavaScript",
      "runtime": "2",
      "files": {
        "index.js": "﻿/*\n * This function is not intended to be invoked directly. Instead it will be\n * triggered by an orchestrator function.\n * \n * Before running this sample, please:\n * - create a Durable orchestration function\n * - create a Durable HTTP starter function\n * - run 'npm install durable-functions' from the wwwroot folder of your\n *   function app in Kudu\n */\n\nmodule.exports = async function (context) {\n    return `Hello ${context.bindings.name}!`;\n};"
      },
      "function": {
        "bindings": [
          {
            "name": "name",
            "type": "activityTrigger",
            "direction": "in"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "Hello",
        "description": "$DurableFunctionsActivity_description",
        "name": "Durable Functions activity",
        "language": "JavaScript",
        "category": [
          "$temp_category_core",
          "$temp_category_durableFunctions"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": []
      }
    },
    {
      "id": "DurableFunctionsActivity-PowerShell",
      "runtime": "2",
      "files": {
        "run.ps1": "param($name)\n\n\"Hello $name!\"\n"
      },
      "function": {
        "bindings": [
          {
            "name": "name",
            "type": "activityTrigger",
            "direction": "in"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "Hello",
        "description": "$DurableFunctionsActivity_description",
        "name": "Durable Functions activity",
        "language": "PowerShell",
        "category": [
          "$temp_category_core",
          "$temp_category_durableFunctions"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": []
      }
    },
    {
      "id": "DurableFunctionsActivity-Python",
      "runtime": "2",
      "files": {
        "__init__.py": "# This function is not intended to be invoked directly. Instead it will be\n# triggered by an orchestrator function.\n# Before running this sample, please:\n# - create a Durable orchestration function\n# - create a Durable HTTP starter function\n# - add azure-functions-durable to requirements.txt\n# - run pip install -r requirements.txt\n\nimport logging\n\n\ndef main(name: str) -> str:\n    return f\"Hello {name}!\"\n"
      },
      "function": {
        "scriptFile": "__init__.py",
        "bindings": [
          {
            "name": "name",
            "type": "activityTrigger",
            "direction": "in"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "Hello",
        "description": "$DurableFunctionsActivity_description",
        "name": "Durable Functions activity",
        "language": "Python",
        "category": [
          "$temp_category_core",
          "$temp_category_durableFunctions"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": []
      }
    },
    {
      "id": "DurableFunctionsActivity-TypeScript",
      "runtime": "2",
      "files": {
        "index.ts": "﻿/*\n * This function is not intended to be invoked directly. Instead it will be\n * triggered by an orchestrator function.\n * \n * Before running this sample, please:\n * - create a Durable orchestration function\n * - create a Durable HTTP starter function\n * - run 'npm install durable-functions' from the wwwroot folder of your\n *   function app in Kudu\n */\n\nimport { AzureFunction, Context } from \"@azure/functions\"\n\nconst activityFunction: AzureFunction = async function (context: Context): Promise<string> {\n    return `Hello ${context.bindings.name}!`;\n};\n\nexport default activityFunction;\n"
      },
      "function": {
        "bindings": [
          {
            "name": "name",
            "type": "activityTrigger",
            "direction": "in"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "Hello",
        "description": "$DurableFunctionsActivity_description",
        "name": "Durable Functions activity",
        "language": "TypeScript",
        "category": [
          "$temp_category_core",
          "$temp_category_durableFunctions"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": []
      }
    },
    {
      "id": "DurableFunctionsEntity-JavaScript",
      "runtime": "2",
      "files": {
        "index.js": "﻿/*\n* This function is not intended to be invoked directly. Instead it will be\n* triggered by a client function.\n* \n* Before running this sample, please:\n* - create a Durable entity HTTP function\n* - run 'npm install durable-functions' from the root of your app\n*/\n\nconst df = require(\"durable-functions\");\n\nmodule.exports = df.entity(function (context) {\n    const currentValue = context.df.getState(() => 0);\n    switch (context.df.operationName) {\n        case \"add\":\n            const amount = context.df.getInput();\n            context.df.setState(currentValue + amount);\n            break;\n        case \"reset\":\n            context.df.setState(0);\n            break;\n        case \"get\":\n            context.df.return(currentValue);\n            break;\n    }\n});"
      },
      "function": {
        "bindings": [
          {
            "name": "context",
            "type": "entityTrigger",
            "direction": "in"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "Counter",
        "description": "$DurableFunctionsEntity_description",
        "name": "Durable Functions entity",
        "language": "JavaScript",
        "category": [
          "$temp_category_core",
          "$temp_category_durableFunctions"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": []
      }
    },
    {
      "id": "DurableFunctionsEntity-Python",
      "runtime": "2",
      "files": {
        "__init__.py": "import logging\nimport json\n\nimport azure.functions as func\nimport azure.durable_functions as df\n\n\ndef entity_function(context: df.DurableOrchestrationContext):\n\n    current_value = context.get_state(lambda: 0)\n    operation = context.operation_name\n    if operation == \"add\":\n        amount = context.get_input()\n        current_value += amount\n        context.set_result(current_value)\n    elif operation == \"reset\":\n        current_value = 0\n    elif operation == \"get\":\n        context.set_result(current_value)\n    \n    context.set_state(current_value)\n\nmain = df.Entity.create(entity_function)"
      },
      "function": {
        "scriptFile": "__init__.py",
        "bindings": [
          {
            "name": "context",
            "type": "entityTrigger",
            "direction": "in"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "DurableFunctionsEntityPy",
        "description": "$DurableFunctionsEntity_description",
        "name": "Durable Functions entity",
        "language": "Python",
        "category": [
          "$temp_category_core",
          "$temp_category_durableFunctions"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": []
      }
    },
    {
      "id": "DurableFunctionsEntity-TypeScript",
      "runtime": "2",
      "files": {
        "index.ts": "﻿/*\n* This function is not intended to be invoked directly. Instead it will be\n* triggered by a client function.\n* \n* Before running this sample, please:\n* - create a Durable entity HTTP function\n* - run 'npm install durable-functions' from the root of your app\n*/\n\nimport * as df from \"durable-functions\"\n\nconst entity = df.entity(function (context) {\n    const currentValue = context.df.getState(() => 0) as number;\n    switch (context.df.operationName) {\n        case \"add\":\n            const amount = context.df.getInput() as number;\n            context.df.setState(currentValue + amount);\n            break;\n        case \"reset\":\n            context.df.setState(0);\n            break;\n    }\n});\n\nexport default entity;"
      },
      "function": {
        "bindings": [
          {
            "name": "context",
            "type": "entityTrigger",
            "direction": "in"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "Counter",
        "description": "$DurableFunctionsEntity_description",
        "name": "Durable Functions entity",
        "language": "TypeScript",
        "category": [
          "$temp_category_core",
          "$temp_category_durableFunctions"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": []
      }
    },
    {
      "id": "DurableFunctionsEntityClass-CSharp",
      "runtime": "2",
      "files": {
        "run.csx": "/*\n* This function is not intended to be invoked directly. Instead it will be\n* triggered by a client function.\n* \n* Before running this sample, please:\n* - create a Durable entity HTTP function\n*/\n\n#r \"Microsoft.Azure.WebJobs.Extensions.DurableTask\"\n#r \"Newtonsoft.Json\"\n\nusing Newtonsoft.Json;\nusing Microsoft.Azure.WebJobs.Extensions.DurableTask;\n\npublic class Counter\n{\n\n    [JsonProperty(\"value\")]\n    public int CurrentValue { get; set; }\n\n    public void Add(int amount) => this.CurrentValue += amount;\n\n    public void Reset() => this.CurrentValue = 0;\n\n    public int Get() => this.CurrentValue;\n}\n\npublic static void Run(IDurableEntityContext context)\n    => context.DispatchAsync<Counter>();"
      },
      "function": {
        "bindings": [
          {
            "name": "context",
            "type": "entityTrigger",
            "direction": "in"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "Counter",
        "description": "$DurableFunctionsEntityClass_description",
        "name": "Durable Functions entity (class)",
        "language": "C#",
        "category": [
          "$temp_category_durableFunctions"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": []
      }
    },
    {
      "id": "DurableFunctionsEntityFunction-CSharp",
      "runtime": "2",
      "files": {
        "run.csx": "/*\n* This function is not intended to be invoked directly. Instead it will be\n* triggered by a client function.\n* \n* Before running this sample, please:\n* - create a Durable entity HTTP function\n*/\n\n#r \"Microsoft.Azure.WebJobs.Extensions.DurableTask\"\n\nusing Microsoft.Azure.WebJobs.Extensions.DurableTask;\n\npublic static void Run(IDurableEntityContext context)\n{\n    switch (context.OperationName.ToLowerInvariant())\n    {\n        case \"add\":\n            context.SetState(context.GetState<int>() + context.GetInput<int>());\n            break;\n        case \"reset\":\n            context.SetState(0);\n            break;\n        case \"get\":\n            context.Return(context.GetState<int>());\n            break;\n    }\n}"
      },
      "function": {
        "bindings": [
          {
            "name": "context",
            "type": "entityTrigger",
            "direction": "in"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "Counter",
        "description": "$DurableFunctionsEntityFunction_description",
        "name": "Durable Functions entity (function)",
        "language": "C#",
        "category": [
          "$temp_category_durableFunctions"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": []
      }
    },
    {
      "id": "DurableFunctionsEntityHttpStart-CSharp",
      "runtime": "2",
      "files": {
        "run.csx": "#r \"Microsoft.Azure.WebJobs.Extensions.DurableTask\"\n#r \"Newtonsoft.Json\"\n\nusing System.Net;\nusing Newtonsoft.Json.Linq;\nusing Microsoft.Azure.WebJobs.Extensions.DurableTask;\nusing Microsoft.AspNetCore.Mvc;\n\npublic static async Task<IActionResult> Run(\n    HttpRequest req,\n    IDurableEntityClient client,\n    string entityKey)\n{\n    var entityId = new EntityId(\"Counter\", entityKey);\n\n    if (req.Method.Equals(\"POST\"))\n    {\n        await client.SignalEntityAsync(entityId, \"add\", 1);\n        return new OkObjectResult(\"Added to the entity\");\n    }\n\n    EntityStateResponse<JToken> stateResponse = await client.ReadEntityStateAsync<JToken>(entityId);\n    return new OkObjectResult(stateResponse);\n}"
      },
      "function": {
        "bindings": [
          {
            "authLevel": "function",
            "name": "req",
            "type": "httpTrigger",
            "direction": "in",
            "route": "{entityKey}",
            "methods": [
              "post",
              "get"
            ]
          },
          {
            "name": "$return",
            "type": "http",
            "direction": "out"
          },
          {
            "name": "client",
            "type": "durableClient",
            "direction": "in"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "DurableFunctionsEntityHttpStart",
        "description": "$DurableFunctionsHttpStart_description",
        "name": "Durable Functions Entity HTTP starter",
        "language": "C#",
        "category": [
          "$temp_category_core",
          "$temp_category_durableFunctions"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": []
      }
    },
    {
      "id": "DurableFunctionsEntityHttpStart-JavaScript",
      "runtime": "2",
      "files": {
        "index.js": "﻿const df = require(\"durable-functions\");\n\nmodule.exports = async function (context, req) {\n    const client = df.getClient(context);\n    const id = context.bindingData.id;\n    const entityId = new df.EntityId(\"Counter\", id);\n\n    if (req.method === \"POST\") {\n        // increment value\n        await client.signalEntity(entityId, \"add\", 1);\n    } else {\n        // reads current state of entity\n        const stateResponse = await client.readEntityState(entityId);\n        return { body: stateResponse.entityState };\n    }\n};"
      },
      "function": {
        "bindings": [
          {
            "authLevel": "function",
            "name": "req",
            "type": "httpTrigger",
            "direction": "in",
            "route": "counters/{id}",
            "methods": [
              "post",
              "get"
            ]
          },
          {
            "name": "$return",
            "type": "http",
            "direction": "out"
          },
          {
            "name": "starter",
            "type": "orchestrationClient",
            "direction": "in"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "DurableFunctionsEntityHttpStart",
        "description": "$DurableFunctionsHttpStart_description",
        "name": "Durable Functions Entity HTTP starter",
        "language": "JavaScript",
        "category": [
          "$temp_category_core",
          "$temp_category_durableFunctions"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": []
      }
    },
    {
      "id": "DurableFunctionsEntityHttpStart-TypeScript",
      "runtime": "2",
      "files": {
        "index.ts": "﻿import { AzureFunction, Context, HttpRequest } from \"@azure/functions\"\nimport * as df from \"durable-functions\"\n\nconst httpStart: AzureFunction = async function (context: Context, req: HttpRequest) {\n    const client = df.getClient(context);\n    const id: string = req.params.id;\n    const entityId = new df.EntityId(\"Counter\", id);\n\n    if (req.method === \"POST\") {\n        // increment value\n        await client.signalEntity(entityId, \"add\", 1);\n    } else {\n        // reads current state of entity\n        const stateResponse = await client.readEntityState<number>(entityId);\n        return { body: stateResponse.entityState };\n    }\n};\n\nexport default httpStart;"
      },
      "function": {
        "bindings": [
          {
            "authLevel": "anonymous",
            "name": "req",
            "type": "httpTrigger",
            "direction": "in",
            "route": "counters/{id}",
            "methods": [
              "post",
              "get"
            ]
          },
          {
            "name": "$return",
            "type": "http",
            "direction": "out"
          },
          {
            "name": "client",
            "type": "durableClient",
            "direction": "in"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "DurableFunctionsEntityHttpStart",
        "description": "$DurableFunctionsHttpStart_description",
        "name": "Durable Functions Entity HTTP starter",
        "language": "TypeScript",
        "category": [
          "$temp_category_core",
          "$temp_category_durableFunctions"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": [
          "authLevel"
        ]
      }
    },
    {
      "id": "DurableFunctionsHttpStart-CSharp",
      "runtime": "2",
      "files": {
        "run.csx": "#r \"Microsoft.Azure.WebJobs.Extensions.DurableTask\"\n#r \"Newtonsoft.Json\"\n\nusing System.Net;\nusing Microsoft.Azure.WebJobs.Extensions.DurableTask;\n\npublic static async Task<HttpResponseMessage> Run(\n    HttpRequestMessage req,\n    IDurableOrchestrationClient starter,\n    string functionName,\n    ILogger log)\n{\n    // Function input comes from the request content.\n    dynamic eventData = await req.Content.ReadAsAsync<object>();\n\n    // Pass the function name as part of the route \n    string instanceId = await starter.StartNewAsync(functionName, eventData);\n\n    log.LogInformation($\"Started orchestration with ID = '{instanceId}'.\");\n\n    return starter.CreateCheckStatusResponse(req, instanceId);\n}"
      },
      "function": {
        "bindings": [
          {
            "authLevel": "function",
            "name": "req",
            "type": "httpTrigger",
            "direction": "in",
            "route": "orchestrators/{functionName}",
            "methods": [
              "post",
              "get"
            ]
          },
          {
            "name": "$return",
            "type": "http",
            "direction": "out"
          },
          {
            "name": "starter",
            "type": "durableClient",
            "direction": "in"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "DurableFunctionsHttpStart",
        "description": "$DurableFunctionsHttpStart_description",
        "name": "Durable Functions HTTP starter",
        "language": "C#",
        "category": [
          "$temp_category_core",
          "$temp_category_durableFunctions"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": []
      }
    },
    {
      "id": "DurableFunctionsHttpStart-JavaScript",
      "runtime": "2",
      "files": {
        "index.js": "﻿const df = require(\"durable-functions\");\n\nmodule.exports = async function (context, req) {\n    const client = df.getClient(context);\n    const instanceId = await client.startNew(req.params.functionName, undefined, req.body);\n\n    context.log(`Started orchestration with ID = '${instanceId}'.`);\n\n    return client.createCheckStatusResponse(context.bindingData.req, instanceId);\n};"
      },
      "function": {
        "bindings": [
          {
            "authLevel": "function",
            "name": "req",
            "type": "httpTrigger",
            "direction": "in",
            "route": "orchestrators/{functionName}",
            "methods": [
              "post",
              "get"
            ]
          },
          {
            "name": "$return",
            "type": "http",
            "direction": "out"
          },
          {
            "name": "starter",
            "type": "orchestrationClient",
            "direction": "in"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "DurableFunctionsHttpStart",
        "description": "$DurableFunctionsHttpStart_description",
        "name": "Durable Functions HTTP starter",
        "language": "JavaScript",
        "category": [
          "$temp_category_core",
          "$temp_category_durableFunctions"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": [
          "authLevel"
        ]
      }
    },
    {
      "id": "DurableFunctionsHttpStart-PowerShell",
      "runtime": "2",
      "files": {
        "run.ps1": "using namespace System.Net\n\nparam($Request, $TriggerMetadata)\n\n$FunctionName = $Request.Params.FunctionName\n$InstanceId = Start-DurableOrchestration -FunctionName $FunctionName\nWrite-Host \"Started orchestration with ID = '$InstanceId'\"\n\n$Response = New-DurableOrchestrationCheckStatusResponse -Request $Request -InstanceId $InstanceId\nPush-OutputBinding -Name Response -Value $Response\n"
      },
      "function": {
        "bindings": [
          {
            "authLevel": "function",
            "name": "Request",
            "type": "httpTrigger",
            "direction": "in",
            "route": "orchestrators/{FunctionName}",
            "methods": [
              "post",
              "get"
            ]
          },
          {
            "type": "http",
            "direction": "out",
            "name": "Response"
          },
          {
            "name": "starter",
            "type": "durableClient",
            "direction": "in"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "DurableFunctionsHttpStart",
        "description": "$DurableFunctionsHttpStart_description",
        "name": "Durable Functions HTTP starter",
        "language": "PowerShell",
        "category": [
          "$temp_category_core",
          "$temp_category_durableFunctions"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": [
          "authLevel"
        ]
      }
    },
    {
      "id": "DurableFunctionsHttpStart-Python",
      "runtime": "2",
      "files": {
        "__init__.py": "# This function an HTTP starter function for Durable Functions.\n# Before running this sample, please:\n# - create a Durable orchestration function\n# - create a Durable activity function (default name is \"Hello\")\n# - add azure-functions-durable to requirements.txt\n# - run pip install -r requirements.txt\n \nimport logging\n\nimport azure.functions as func\nimport azure.durable_functions as df\n\n\nasync def main(req: func.HttpRequest, starter: str) -> func.HttpResponse:\n    client = df.DurableOrchestrationClient(starter)\n    instance_id = await client.start_new(req.route_params[\"functionName\"], None, None)\n\n    logging.info(f\"Started orchestration with ID = '{instance_id}'.\")\n\n    return client.create_check_status_response(req, instance_id)"
      },
      "function": {
        "scriptFile": "__init__.py",
        "bindings": [
          {
            "authLevel": "function",
            "name": "req",
            "type": "httpTrigger",
            "direction": "in",
            "route": "orchestrators/{functionName}",
            "methods": [
              "post",
              "get"
            ]
          },
          {
            "name": "$return",
            "type": "http",
            "direction": "out"
          },
          {
            "name": "starter",
            "type": "durableClient",
            "direction": "in"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "DurableFunctionsHttpStart",
        "description": "$DurableFunctionsHttpStart_description",
        "name": "Durable Functions HTTP starter",
        "language": "Python",
        "category": [
          "$temp_category_core",
          "$temp_category_durableFunctions"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": [
          "authLevel"
        ]
      }
    },
    {
      "id": "DurableFunctionsHttpStart-TypeScript",
      "runtime": "2",
      "files": {
        "index.ts": "﻿import * as df from \"durable-functions\"\nimport { AzureFunction, Context, HttpRequest } from \"@azure/functions\"\n\nconst httpStart: AzureFunction = async function (context: Context, req: HttpRequest): Promise<any> {\n    const client = df.getClient(context);\n    const instanceId = await client.startNew(req.params.functionName, undefined, req.body);\n\n    context.log(`Started orchestration with ID = '${instanceId}'.`);\n\n    return client.createCheckStatusResponse(context.bindingData.req, instanceId);\n};\n\nexport default httpStart;\n"
      },
      "function": {
        "bindings": [
          {
            "authLevel": "function",
            "name": "req",
            "type": "httpTrigger",
            "direction": "in",
            "route": "orchestrators/{functionName}",
            "methods": [
              "post",
              "get"
            ]
          },
          {
            "name": "$return",
            "type": "http",
            "direction": "out"
          },
          {
            "name": "starter",
            "type": "orchestrationClient",
            "direction": "in"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "DurableFunctionsHttpStart",
        "description": "$DurableFunctionsHttpStart_description",
        "name": "Durable Functions HTTP starter",
        "language": "TypeScript",
        "category": [
          "$temp_category_core",
          "$temp_category_durableFunctions"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": [
          "authLevel"
        ]
      }
    },
    {
      "id": "DurableFunctionsOrchestrator-CSharp",
      "runtime": "2",
      "files": {
        "run.csx": "/*\n * This function is not intended to be invoked directly. Instead it will be\n * triggered by an HTTP starter function.\n * \n * Before running this sample, please:\n * - create a Durable activity function (default name is \"Hello\")\n * - create a Durable HTTP starter function\n */\n\n#r \"Microsoft.Azure.WebJobs.Extensions.DurableTask\"\n\nusing Microsoft.Azure.WebJobs.Extensions.DurableTask;\n\npublic static async Task<List<string>> Run(IDurableOrchestrationContext context)\n{\n    var outputs = new List<string>();\n\n    // Replace \"Hello\" with the name of your Durable Activity Function.\n    outputs.Add(await context.CallActivityAsync<string>(\"Hello\", \"Tokyo\"));\n    outputs.Add(await context.CallActivityAsync<string>(\"Hello\", \"Seattle\"));\n    outputs.Add(await context.CallActivityAsync<string>(\"Hello\", \"London\"));\n\n    // returns [\"Hello Tokyo!\", \"Hello Seattle!\", \"Hello London!\"]\n    return outputs;\n}"
      },
      "function": {
        "bindings": [
          {
            "name": "context",
            "type": "orchestrationTrigger",
            "direction": "in"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "DurableFunctionsOrchestrator",
        "description": "$DurableFunctionsOrchestrator_description",
        "name": "Durable Functions orchestrator",
        "language": "C#",
        "category": [
          "$temp_category_core",
          "$temp_category_durableFunctions"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": []
      }
    },
    {
      "id": "DurableFunctionsOrchestrator-JavaScript",
      "runtime": "2",
      "files": {
        "index.js": "﻿/*\n * This function is not intended to be invoked directly. Instead it will be\n * triggered by an HTTP starter function.\n * \n * Before running this sample, please:\n * - create a Durable activity function (default name is \"Hello\")\n * - create a Durable HTTP starter function\n * - run 'npm install durable-functions' from the wwwroot folder of your \n *    function app in Kudu\n */\n\nconst df = require(\"durable-functions\");\n\nmodule.exports = df.orchestrator(function* (context) {\n    const outputs = [];\n\n    // Replace \"Hello\" with the name of your Durable Activity Function.\n    outputs.push(yield context.df.callActivity(\"Hello\", \"Tokyo\"));\n    outputs.push(yield context.df.callActivity(\"Hello\", \"Seattle\"));\n    outputs.push(yield context.df.callActivity(\"Hello\", \"London\"));\n\n    // returns [\"Hello Tokyo!\", \"Hello Seattle!\", \"Hello London!\"]\n    return outputs;\n});"
      },
      "function": {
        "bindings": [
          {
            "name": "context",
            "type": "orchestrationTrigger",
            "direction": "in"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "DurableFunctionsOrchestratorJS",
        "description": "$DurableFunctionsOrchestrator_description",
        "name": "Durable Functions orchestrator",
        "language": "JavaScript",
        "category": [
          "$temp_category_core",
          "$temp_category_durableFunctions"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": []
      }
    },
    {
      "id": "DurableFunctionsOrchestrator-PowerShell",
      "runtime": "2",
      "files": {
        "run.ps1": "param($Context)\n\n$output = @()\n\n$output += Invoke-DurableActivity -FunctionName 'Hello' -Input 'Tokyo'\n$output += Invoke-DurableActivity -FunctionName 'Hello' -Input 'Seattle'\n$output += Invoke-DurableActivity -FunctionName 'Hello' -Input 'London'\n\n$output\n"
      },
      "function": {
        "bindings": [
          {
            "name": "Context",
            "type": "orchestrationTrigger",
            "direction": "in"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "DurableFunctionsOrchestrator",
        "description": "$DurableFunctionsOrchestrator_description",
        "name": "Durable Functions orchestrator",
        "language": "PowerShell",
        "category": [
          "$temp_category_core",
          "$temp_category_durableFunctions"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": []
      }
    },
    {
      "id": "DurableFunctionsOrchestrator-Python",
      "runtime": "2",
      "files": {
        "__init__.py": "# This function is not intended to be invoked directly. Instead it will be\n# triggered by an HTTP starter function.\n# Before running this sample, please:\n# - create a Durable activity function (default name is \"Hello\")\n# - create a Durable HTTP starter function\n# - add azure-functions-durable to requirements.txt\n# - run pip install -r requirements.txt\n\nimport logging\nimport json\n\nimport azure.functions as func\nimport azure.durable_functions as df\n\n\ndef orchestrator_function(context: df.DurableOrchestrationContext):\n    result1 = yield context.call_activity('Hello', \"Tokyo\")\n    result2 = yield context.call_activity('Hello', \"Seattle\")\n    result3 = yield context.call_activity('Hello', \"London\")\n    return [result1, result2, result3]\n\nmain = df.Orchestrator.create(orchestrator_function)"
      },
      "function": {
        "scriptFile": "__init__.py",
        "bindings": [
          {
            "name": "context",
            "type": "orchestrationTrigger",
            "direction": "in"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "DurableFunctionsOrchestrator",
        "description": "$DurableFunctionsOrchestrator_description",
        "name": "Durable Functions orchestrator",
        "language": "Python",
        "category": [
          "$temp_category_core",
          "$temp_category_durableFunctions"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": []
      }
    },
    {
      "id": "DurableFunctionsOrchestrator-TypeScript",
      "runtime": "2",
      "files": {
        "index.ts": "﻿/*\n * This function is not intended to be invoked directly. Instead it will be\n * triggered by an HTTP starter function.\n * \n * Before running this sample, please:\n * - create a Durable activity function (default name is \"Hello\")\n * - create a Durable HTTP starter function\n * - run 'npm install durable-functions' from the wwwroot folder of your \n *    function app in Kudu\n */\n\nimport * as df from \"durable-functions\"\n\nconst orchestrator = df.orchestrator(function* (context) {\n    const outputs = [];\n\n    // Replace \"Hello\" with the name of your Durable Activity Function.\n    outputs.push(yield context.df.callActivity(\"Hello\", \"Tokyo\"));\n    outputs.push(yield context.df.callActivity(\"Hello\", \"Seattle\"));\n    outputs.push(yield context.df.callActivity(\"Hello\", \"London\"));\n\n    // returns [\"Hello Tokyo!\", \"Hello Seattle!\", \"Hello London!\"]\n    return outputs;\n});\n\nexport default orchestrator;\n"
      },
      "function": {
        "bindings": [
          {
            "name": "context",
            "type": "orchestrationTrigger",
            "direction": "in"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "DurableFunctionsOrchestratorJS",
        "description": "$DurableFunctionsOrchestrator_description",
        "name": "Durable Functions orchestrator",
        "language": "TypeScript",
        "category": [
          "$temp_category_core",
          "$temp_category_durableFunctions"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": []
      }
    },
    {
      "id": "EventGridTrigger-CSharp",
      "runtime": "2",
      "files": {
        "run.csx": "#r \"Azure.Messaging.EventGrid\"\r\n\r\nusing Azure.Messaging.EventGrid;\r\n\r\npublic static void Run(EventGridEvent eventGridEvent, ILogger log)\r\n{\r\n    log.LogInformation(eventGridEvent.EventType.ToString());\r\n}\r\n",
        "sample.dat": "{\n  \"topic\": \"/subscriptions/5b4b650e-28b9-4790-b3ab-ddbd88d727c4/resourcegroups/test/providers/Microsoft.EventHub/namespaces/test\",\n  \"subject\": \"eventhubs/test\",\n  \"eventType\": \"captureFileCreated\",\n  \"eventTime\": \"2017-07-14T23:10:27.7689666Z\",\n  \"id\": \"7b11c4ce-1c34-4416-848b-1730e766f126\",\n  \"data\": {\n    \"fileUrl\": \"https://test.blob.core.windows.net/debugging/testblob.txt\",\n    \"fileType\": \"AzureBlockBlob\",\n    \"partitionId\": \"1\",\n    \"sizeInBytes\": 0,\n    \"eventCount\": 0,\n    \"firstSequenceNumber\": -1,\n    \"lastSequenceNumber\": -1,\n    \"firstEnqueueTime\": \"0001-01-01T00:00:00\",\n    \"lastEnqueueTime\": \"0001-01-01T00:00:00\"\n  },\n  \"dataVersion\": \"\",\n  \"metadataVersion\": \"1\" \n}\n"
      },
      "function": {
        "bindings": [
          {
            "type": "eventGridTrigger",
            "name": "eventGridEvent",
            "direction": "in"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "EventGridTrigger",
        "description": "$EventGridTrigger_description",
        "name": "Azure Event Grid trigger",
        "language": "C#",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "eventGrid",
        "enabledInTryMode": false,
        "userPrompt": []
      }
    },
    {
      "id": "EventGridTrigger-Custom",
      "runtime": "2",
      "files": {},
      "function": {
        "bindings": [
          {
            "type": "eventGridTrigger",
            "name": "eventGridEvent",
            "direction": "in"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "EventGridTrigger",
        "description": "$EventGridTrigger_description",
        "name": "Azure Event Grid trigger",
        "language": "Custom",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "eventGrid",
        "enabledInTryMode": false,
        "userPrompt": []
      }
    },
    {
      "id": "EventGridTrigger-JavaScript",
      "runtime": "2",
      "files": {
        "index.js": "module.exports = async function (context, eventGridEvent) {\r\n    context.log(typeof eventGridEvent);\r\n    context.log(eventGridEvent);\r\n};",
        "sample.dat": "{\n  \"topic\": \"/subscriptions/5b4b650e-28b9-4790-b3ab-ddbd88d727c4/resourcegroups/test/providers/Microsoft.EventHub/namespaces/test\",\n  \"subject\": \"eventhubs/test\",\n  \"eventType\": \"captureFileCreated\",\n  \"eventTime\": \"2017-07-14T23:10:27.7689666Z\",\n  \"id\": \"7b11c4ce-1c34-4416-848b-1730e766f126\",\n  \"data\": {\n    \"fileUrl\": \"https://test.blob.core.windows.net/debugging/testblob.txt\",\n    \"fileType\": \"AzureBlockBlob\",\n    \"partitionId\": \"1\",\n    \"sizeInBytes\": 0,\n    \"eventCount\": 0,\n    \"firstSequenceNumber\": -1,\n    \"lastSequenceNumber\": -1,\n    \"firstEnqueueTime\": \"0001-01-01T00:00:00\",\n    \"lastEnqueueTime\": \"0001-01-01T00:00:00\"\n  },\n  \"dataVersion\": \"\", \n  \"metadataVersion\": \"1\" \n}\n"
      },
      "function": {
        "bindings": [
          {
            "type": "eventGridTrigger",
            "name": "eventGridEvent",
            "direction": "in"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "EventGridTrigger",
        "description": "$EventGridTrigger_description",
        "name": "Azure Event Grid trigger",
        "language": "JavaScript",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "eventGrid",
        "enabledInTryMode": false,
        "userPrompt": []
      }
    },
    {
      "id": "EventGridTrigger-PowerShell",
      "runtime": "2",
      "files": {
        "run.ps1": "param($eventGridEvent, $TriggerMetadata)\r\n\r\n# Make sure to pass hashtables to Out-String so they're logged correctly\r\n$eventGridEvent | Out-String | Write-Host\r\n",
        "sample.dat": "{\n  \"topic\": \"/subscriptions/5b4b650e-28b9-4790-b3ab-ddbd88d727c4/resourcegroups/test/providers/Microsoft.EventHub/namespaces/test\",\n  \"subject\": \"eventhubs/test\",\n  \"eventType\": \"captureFileCreated\",\n  \"eventTime\": \"2017-07-14T23:10:27.7689666Z\",\n  \"id\": \"7b11c4ce-1c34-4416-848b-1730e766f126\",\n  \"data\": {\n    \"fileUrl\": \"https://test.blob.core.windows.net/debugging/testblob.txt\",\n    \"fileType\": \"AzureBlockBlob\",\n    \"partitionId\": \"1\",\n    \"sizeInBytes\": 0,\n    \"eventCount\": 0,\n    \"firstSequenceNumber\": -1,\n    \"lastSequenceNumber\": -1,\n    \"firstEnqueueTime\": \"0001-01-01T00:00:00\",\n    \"lastEnqueueTime\": \"0001-01-01T00:00:00\"\n  },\n  \"dataVersion\": \"\", \n  \"metadataVersion\": \"1\" \n}\n"
      },
      "function": {
        "bindings": [
          {
            "type": "eventGridTrigger",
            "name": "eventGridEvent",
            "direction": "in"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "EventGridTrigger",
        "description": "$EventGridTrigger_description",
        "name": "Azure Event Grid trigger",
        "language": "PowerShell",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "eventGrid",
        "enabledInTryMode": false,
        "userPrompt": []
      }
    },
    {
      "id": "EventGridTrigger-Python",
      "runtime": "2",
      "files": {
        "sample.dat": "{\n  'topic': '/subscriptions/5b4b650e-28b9-4790-b3ab-ddbd88d727c4/resourcegroups/test/providers/Microsoft.EventHub/namespaces/test',\n  'subject': 'eventhubs/test',\n  'eventType': 'captureFileCreated',\n  'eventTime': '2017-07-14T23:10:27.7689666Z',\n  'id': '7b11c4ce-1c34-4416-848b-1730e766f126',\n  'data': {\n    'fileUrl': 'https://test.blob.core.windows.net/debugging/testblob.txt',\n    'fileType': 'AzureBlockBlob',\n    'partitionId': '1',\n    'sizeInBytes': 0,\n    'eventCount': 0,\n    'firstSequenceNumber': -1,\n    'lastSequenceNumber': -1,\n    'firstEnqueueTime': '0001-01-01T00:00:00',\n    'lastEnqueueTime': '0001-01-01T00:00:00'\n  },\n  \"dataVersion\": \"\", \n  \"metadataVersion\": \"1\" \n}\n",
        "__init__.py": "import json\r\nimport logging\r\n\r\nimport azure.functions as func\r\n\r\n\r\ndef main(event: func.EventGridEvent):\r\n    result = json.dumps({\r\n        'id': event.id,\r\n        'data': event.get_json(),\r\n        'topic': event.topic,\r\n        'subject': event.subject,\r\n        'event_type': event.event_type,\r\n    })\r\n\r\n    logging.info('Python EventGrid trigger processed an event: %s', result)\r\n"
      },
      "function": {
        "scriptFile": "__init__.py",
        "bindings": [
          {
            "type": "eventGridTrigger",
            "name": "event",
            "direction": "in"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "EventGridTrigger",
        "description": "$EventGridTrigger_description",
        "name": "Azure Event Grid trigger",
        "language": "Python",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "eventGrid",
        "enabledInTryMode": false,
        "userPrompt": []
      }
    },
    {
      "id": "EventGridTrigger-TypeScript",
      "runtime": "2",
      "files": {
        "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\r\n\r\nconst eventGridTrigger: AzureFunction = async function (context: Context, eventGridEvent: any): Promise<void> {\r\n    context.log(typeof eventGridEvent);\r\n    context.log(eventGridEvent);\r\n};\r\n\r\nexport default eventGridTrigger;\r\n",
        "sample.dat": "{\n  \"topic\": \"/subscriptions/5b4b650e-28b9-4790-b3ab-ddbd88d727c4/resourcegroups/test/providers/Microsoft.EventHub/namespaces/test\",\n  \"subject\": \"eventhubs/test\",\n  \"eventType\": \"captureFileCreated\",\n  \"eventTime\": \"2017-07-14T23:10:27.7689666Z\",\n  \"id\": \"7b11c4ce-1c34-4416-848b-1730e766f126\",\n  \"data\": {\n    \"fileUrl\": \"https://test.blob.core.windows.net/debugging/testblob.txt\",\n    \"fileType\": \"AzureBlockBlob\",\n    \"partitionId\": \"1\",\n    \"sizeInBytes\": 0,\n    \"eventCount\": 0,\n    \"firstSequenceNumber\": -1,\n    \"lastSequenceNumber\": -1,\n    \"firstEnqueueTime\": \"0001-01-01T00:00:00\",\n    \"lastEnqueueTime\": \"0001-01-01T00:00:00\"\n  },\n  \"dataVersion\": \"\", \n  \"metadataVersion\": \"1\" \n}\n"
      },
      "function": {
        "bindings": [
          {
            "type": "eventGridTrigger",
            "name": "eventGridEvent",
            "direction": "in"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "EventGridTrigger",
        "description": "$EventGridTrigger_description",
        "name": "Azure Event Grid trigger",
        "language": "TypeScript",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "eventGrid",
        "enabledInTryMode": false,
        "userPrompt": []
      }
    },
    {
      "id": "EventHubTrigger-CSharp",
      "runtime": "2",
      "files": {
        "run.csx": "#r \"Azure.Messaging.EventHubs\"\r\n#r \"System.Memory.Data\"\r\n\r\nusing System;\r\nusing System.Text;\r\nusing Azure.Messaging.EventHubs;\r\n\r\npublic static async Task Run(EventData[] events, ILogger log)\r\n{\r\n    var exceptions = new List<Exception>();\r\n\r\n    foreach (EventData eventData in events)\r\n    {\r\n        try\r\n        {\r\n            // Replace these two lines with your processing logic.\r\n            log.LogInformation($\"C# Event Hub trigger function processed a message: {eventData.EventBody}\");\r\n            await Task.Yield();\r\n        }\r\n        catch (Exception e)\r\n        {\r\n            // We need to keep processing the rest of the batch - capture this exception and continue.\r\n            // Also, consider capturing details of the message that failed processing so it can be processed again later.\r\n            exceptions.Add(e);\r\n        }\r\n    }\r\n\r\n    // Once processing of the batch is complete, if any messages in the batch failed processing throw an exception so that there is a record of the failure.\r\n\r\n    if (exceptions.Count > 1)\r\n        throw new AggregateException(exceptions);\r\n\r\n    if (exceptions.Count == 1)\r\n        throw exceptions.Single();\r\n}\r\n",
        "sample.dat": "Test Message"
      },
      "function": {
        "bindings": [
          {
            "type": "eventHubTrigger",
            "name": "events",
            "direction": "in",
            "eventHubName": "samples-workitems",
            "cardinality": "many",
            "connection": "",
            "consumerGroup": "$Default"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "EventHubTrigger",
        "description": "$EventHubTrigger_description",
        "name": "Azure Event Hub trigger",
        "language": "C#",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "eventHub",
        "enabledInTryMode": false,
        "userPrompt": [
          "connection",
          "eventHubName",
          "consumerGroup"
        ]
      }
    },
    {
      "id": "EventHubTrigger-Custom",
      "runtime": "2",
      "files": {},
      "function": {
        "bindings": [
          {
            "type": "eventHubTrigger",
            "name": "eventHubMessages",
            "direction": "in",
            "eventHubName": "samples-workitems",
            "connection": "",
            "cardinality": "many",
            "consumerGroup": "$Default"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "EventHubTrigger",
        "description": "$EventHubTrigger_description",
        "name": "Azure Event Hub trigger",
        "language": "Custom",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "eventHub",
        "enabledInTryMode": false,
        "userPrompt": [
          "connection",
          "eventHubName",
          "consumerGroup"
        ]
      }
    },
    {
      "id": "EventHubTrigger-JavaScript",
      "runtime": "2",
      "files": {
        "index.js": "module.exports = async function (context, eventHubMessages) {\r\n    context.log(`JavaScript eventhub trigger function called for message array ${eventHubMessages}`);\r\n    \r\n    eventHubMessages.forEach((message, index) => {\r\n        context.log(`Processed message ${message}`);\r\n    });\r\n};",
        "sample.dat": "\"Test Message\""
      },
      "function": {
        "bindings": [
          {
            "type": "eventHubTrigger",
            "name": "eventHubMessages",
            "direction": "in",
            "eventHubName": "samples-workitems",
            "connection": "",
            "cardinality": "many",
            "consumerGroup": "$Default",
            "dataType": "string"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "EventHubTrigger",
        "description": "$EventHubTrigger_description",
        "name": "Azure Event Hub trigger",
        "language": "JavaScript",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "eventHub",
        "enabledInTryMode": false,
        "userPrompt": [
          "connection",
          "eventHubName",
          "consumerGroup"
        ]
      }
    },
    {
      "id": "EventHubTrigger-PowerShell",
      "runtime": "2",
      "files": {
        "run.ps1": "param($eventHubMessages, $TriggerMetadata)\r\n\r\nWrite-Host \"PowerShell eventhub trigger function called for message array: $eventHubMessages\"\r\n\r\n$eventHubMessages | ForEach-Object { Write-Host \"Processed message: $_\" }\r\n",
        "sample.dat": "\"Test Message\""
      },
      "function": {
        "bindings": [
          {
            "type": "eventHubTrigger",
            "name": "eventHubMessages",
            "direction": "in",
            "eventHubName": "samples-workitems",
            "connection": "",
            "cardinality": "many",
            "consumerGroup": "$Default"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "EventHubTrigger",
        "description": "$EventHubTrigger_description",
        "name": "Azure Event Hub trigger",
        "language": "PowerShell",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "eventHub",
        "enabledInTryMode": false,
        "userPrompt": [
          "connection",
          "eventHubName",
          "consumerGroup"
        ]
      }
    },
    {
      "id": "EventHubTrigger-Python",
      "runtime": "2",
      "files": {
        "sample.dat": "Test Message",
        "__init__.py": "import logging\r\n\r\nimport azure.functions as func\r\n\r\n\r\ndef main(event: func.EventHubEvent):\r\n    logging.info('Python EventHub trigger processed an event: %s',\r\n                 event.get_body().decode('utf-8'))\r\n"
      },
      "function": {
        "scriptFile": "__init__.py",
        "bindings": [
          {
            "type": "eventHubTrigger",
            "name": "event",
            "direction": "in",
            "eventHubName": "samples-workitems",
            "connection": "",
            "cardinality": "many",
            "consumerGroup": "$Default"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "EventHubTrigger",
        "description": "$EventHubTrigger_description",
        "name": "Azure Event Hub trigger",
        "language": "Python",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "eventHub",
        "enabledInTryMode": false,
        "userPrompt": [
          "connection",
          "eventHubName",
          "consumerGroup"
        ]
      }
    },
    {
      "id": "EventHubTrigger-Python-Preview",
      "runtime": "2",
      "files": {
        "eventhub_trigger_template.md": "# Azure Functions: Event Hub Trigger in Python\r\n\r\n## Event Hub Trigger\r\n\r\nThe Event Hub function trigger can be used to respond to an event sent to an event hub event stream. You must have read access to the underlying event hub to set up the trigger. When the function is triggered, the message passed to the function is typed as a string.\r\n\r\n## Using the Template\r\n\r\nFollowing is an example code snippet for Event Hub Trigger using the [Python programming model V2](https://aka.ms/pythonprogrammingmodel) (currently in Preview).\r\n\r\n```python\r\nimport logging\r\n\r\nimport azure.functions as func\r\n\r\napp = func.FunctionApp()\r\n\r\n@app.function_name(name=\"EventHubTrigger1\")\r\n@app.event_hub_message_trigger(arg_name=\"myhub\", event_hub_name=\"samples-workitems\",\r\n                               connection=\"\") \r\n\r\ndef test_function(myhub: func.EventHubEvent):\r\n    logging.info('Python EventHub trigger processed an event: %s',\r\n                myhub.get_body().decode('utf-8'))\r\n```\r\n\r\nTo run the code snippet generated through the command palette, note the following:\r\n\r\n- The function application is defined and named `app`.\r\n- Confirm that the parameters within the trigger reflect values that correspond with your storage account.\r\n- The name of the file must be `function_app.py`.\r\n  \r\nNote that Event Hub output bindings are also supported in Azure Functions. To learn more, see [Azure Event Hubs trigger and bindings for Azure Functions](https://docs.microsoft.com/azure/azure-functions/functions-bindings-event-hubs?tabs=in-process%2Cextensionv5&pivots=programming-language-python)\r\n\r\n## Programming Model V2 (Preview)\r\n\r\nThe new programming model in Azure Functions Python delivers an experience that aligns with Python development principles, and subsequently with commonly used Python frameworks. \r\n\r\nThe improved programming model requires fewer files than the default model, and specifically eliminates the need for a configuration file (`function.json`). Instead, triggers and bindings are represented in the `function_app.py` file as decorators. Moreover, functions can be logically organized with support for multiple functions to be stored in the same file. Functions within the same function application can also be stored in different files, and be referenced as blueprints.\r\n\r\nTo learn more about using the new Python programming model for Azure Functions, see the [Azure Functions Python developer guide](https://aka.ms/pythondeveloperguide). Note that in addition to the documentation, [hints](https://aka.ms/functions-python-hints) are available in code editors that support type checking with PYI files.\r\n\r\nTo learn more about the new programming model for Azure Functions in Python, see [Programming Models in Azure Functions](https://aka.ms/functions-programming-models).",
        "function_app.py": "import logging\n\nimport azure.functions as func\n\napp = func.FunctionApp()\n\n@app.function_name(name=\"EventHubTrigger1\")\n@app.event_hub_message_trigger(arg_name=\"myhub\", event_hub_name=\"samples-workitems\",\n                               connection=\"\") \n\ndef test_function(myhub: func.EventHubEvent):\n    logging.info('Python EventHub trigger processed an event: %s',\n                myhub.get_body().decode('utf-8'))"
      },
      "metadata": {
        "defaultFunctionName": "EventHubTrigger",
        "description": "$EventHubTrigger_description",
        "name": "Azure Event Hub trigger",
        "language": "Python",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "eventHub",
        "enabledInTryMode": false,
        "userPrompt": [
          "connection",
          "eventHubName",
          "consumerGroup"
        ]
      }
    },
    {
      "id": "EventHubTrigger-Python-Preview-Append",
      "runtime": "2",
      "files": {
        "eventhub_trigger_template.md": "# Azure Functions: Event Hub Trigger in Python\r\n\r\n## Event Hub Trigger\r\n\r\nThe Event Hub function trigger can be used to respond to an event sent to an event hub event stream. You must have read access to the underlying event hub to set up the trigger. When the function is triggered, the message passed to the function is typed as a string.\r\n\r\n## Using the Template\r\n\r\nFollowing is an example code snippet for Event Hub Trigger using the [Python programming model V2](https://aka.ms/pythonprogrammingmodel) (currently in Preview).\r\n\r\n```python\r\nimport logging\r\n\r\nimport azure.functions as func\r\n\r\napp = func.FunctionApp()\r\n\r\n@app.function_name(name=\"EventHubTrigger1\")\r\n@app.event_hub_message_trigger(arg_name=\"myhub\", event_hub_name=\"samples-workitems\",\r\n                               connection=\"\") \r\n\r\ndef test_function(myhub: func.EventHubEvent):\r\n    logging.info('Python EventHub trigger processed an event: %s',\r\n                myhub.get_body().decode('utf-8'))\r\n```\r\n\r\nTo run the code snippet generated through the command palette, note the following:\r\n\r\n- The function application is defined and named `app`.\r\n- Confirm that the parameters within the trigger reflect values that correspond with your storage account.\r\n- The name of the file must be `function_app.py`.\r\n  \r\nNote that Event Hub output bindings are also supported in Azure Functions. To learn more, see [Azure Event Hubs trigger and bindings for Azure Functions](https://docs.microsoft.com/azure/azure-functions/functions-bindings-event-hubs?tabs=in-process%2Cextensionv5&pivots=programming-language-python)\r\n\r\n## Programming Model V2 (Preview)\r\n\r\nThe new programming model in Azure Functions Python delivers an experience that aligns with Python development principles, and subsequently with commonly used Python frameworks. \r\n\r\nThe improved programming model requires fewer files than the default model, and specifically eliminates the need for a configuration file (`function.json`). Instead, triggers and bindings are represented in the `function_app.py` file as decorators. Moreover, functions can be logically organized with support for multiple functions to be stored in the same file. Functions within the same function application can also be stored in different files, and be referenced as blueprints.\r\n\r\nTo learn more about using the new Python programming model for Azure Functions, see the [Azure Functions Python developer guide](https://aka.ms/pythondeveloperguide). Note that in addition to the documentation, [hints](https://aka.ms/functions-python-hints) are available in code editors that support type checking with PYI files.\r\n\r\nTo learn more about the new programming model for Azure Functions in Python, see [Programming Models in Azure Functions](https://aka.ms/functions-programming-models).",
        "function_app.py": "@app.function_name(name=\"EventHubTrigger1\")\n@app.event_hub_message_trigger(arg_name=\"myhub\", event_hub_name=\"samples-workitems\",\n                               connection=\"\") \n\ndef test_function(myhub: func.EventHubEvent):\n    logging.info('Python EventHub trigger processed an event: %s',\n                myhub.get_body().decode('utf-8'))"
      },
      "metadata": {
        "defaultFunctionName": "EventHubTrigger",
        "description": "$EventHubTrigger_description",
        "name": "Azure Event Hub trigger",
        "language": "Python",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "eventHub",
        "enabledInTryMode": false,
        "userPrompt": [
          "connection",
          "eventHubName",
          "consumerGroup"
        ]
      }
    },
    {
      "id": "EventHubTrigger-TypeScript",
      "runtime": "2",
      "files": {
        "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\r\n\r\nconst eventHubTrigger: AzureFunction = async function (context: Context, eventHubMessages: any[]): Promise<void> {\r\n    context.log(`Eventhub trigger function called for message array ${eventHubMessages}`);\r\n    \r\n    eventHubMessages.forEach((message, index) => {\r\n        context.log(`Processed message ${message}`);\r\n    });\r\n};\r\n\r\nexport default eventHubTrigger;\r\n",
        "sample.dat": "\"Test Message\""
      },
      "function": {
        "bindings": [
          {
            "type": "eventHubTrigger",
            "name": "eventHubMessages",
            "direction": "in",
            "eventHubName": "samples-workitems",
            "connection": "",
            "cardinality": "many",
            "consumerGroup": "$Default",
            "dataType": "string"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "EventHubTrigger",
        "description": "$EventHubTrigger_description",
        "name": "Azure Event Hub trigger",
        "language": "TypeScript",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "eventHub",
        "enabledInTryMode": false,
        "userPrompt": [
          "connection",
          "eventHubName",
          "consumerGroup"
        ]
      }
    },
    {
      "id": "FunctionApp-Python-Preview",
      "runtime": "2",
      "files": {
        "function_app.py": "import azure.functions as func\r\nimport logging\r\n\r\napp = func.FunctionApp()\r\n\r\n# Learn more at aka.ms/pythonprogrammingmodel\r\n\r\n# Get started by running the following code to create a function using a HTTP trigger.\r\n\r\n# @app.function_name(name=\"HttpTrigger1\")\r\n# @app.route(route=\"hello\")\r\n# def test_function(req: func.HttpRequest) -> func.HttpResponse:\r\n#      logging.info('Python HTTP trigger function processed a request.')\r\n# \r\n#      name = req.params.get('name')\r\n#      if not name:\r\n#         try:\r\n#             req_body = req.get_json()\r\n#         except ValueError:\r\n#             pass\r\n#         else:\r\n#             name = req_body.get('name')\r\n#\r\n#      if name:\r\n#         return func.HttpResponse(f\"Hello, {name}. This HTTP triggered function executed successfully.\")\r\n#      else:\r\n#         return func.HttpResponse(\r\n#              \"This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response.\",\r\n#              status_code=200\r\n#         )",
        "getting_started.md": "# Getting Started with Azure Functions in Python\r\n  \r\n\r\n## Python Programming Model V2 (Preview)\r\n\r\nThe new programming model in Azure Functions Python delivers an experience that aligns with Python development principles, and subsequently with commonly used Python frameworks. \r\n\r\nThe improved programming model requires fewer files than the default model, and specifically eliminates the need for a configuration file (`function.json`). Instead, triggers and bindings are represented in the `function_app.py` file as decorators. Moreover, functions can be logically organized with support for multiple functions to be stored in the same file. Functions within the same function application can also be stored in different files, and be referenced as blueprints.\r\n\r\nIn addition to the [documentation](https://docs.microsoft.com/azure/azure-functions/functions-reference-python?tabs=asgi%2Capplication-level), hints are available in code editors that support type checking with PYI files.\r\n\r\nTo learn more about the new programming model for Azure Functions in Python, see [Programming Models in Azure Functions](https://aka.ms/functions-programming-models).\r\n\r\n## Notes\r\n\r\n- Mix and match of Functions written in the V1 programming model and the V2 programming model in the same Function App will not be supported.\r\n- At this time, the main functions file must be named `function_app.py`.\r\n\r\nTo learn more about the new programming model for Azure Functions in Python, see the [Azure Functions Python developer guide](https://docs.microsoft.com/en-us/azure/azure-functions/functions-reference-python?tabs=asgi%2Capplication-level).\r\n\r\n## Getting Started\r\n\r\nProject Structure\r\n\r\nThe main project folder (<project_root>) can contain the following files:\r\n\r\n* *function_app.py*: Functions along with their triggers and bindings are defined here.\r\n* *local.settings.json*: Used to store app settings and connection strings when running locally. This file doesn't get published to Azure.\r\n* *requirements.txt*: Contains the list of Python packages the system installs when publishing to Azure.\r\n* *host.json*: Contains configuration options that affect all functions in a function app instance. This file does get published to Azure. Not all options are supported when running locally.\r\n* *blueprint.py*: (Optional) Functions that are defined in a separate file for logical organization and grouping, that can be referenced in `function_app.py`.    \r\n* *.vscode/*: (Optional) Contains store VSCode configuration.\r\n* *.venv/*: (Optional) Contains a Python virtual environment used by local development.\r\n* *Dockerfile*: (Optional) Used when publishing your project in a custom container.\r\n* *tests/*: (Optional) Contains the test cases of your function app.\r\n* *.funcignore*: (Optional) Declares files that shouldn't get published to Azure. Usually, this file contains `.vscode/` to ignore your editor setting, `.venv/` to ignore local Python virtual environment, `tests/` to ignore test cases, and `local.settings.json` to prevent local app settings being published.\r\n  \r\n## Developing your first Python function using VS Code\r\n\r\nIf you have not already, please checkout our [quickstart](https://aka.ms/fxpythonquickstart) to get you started with Azure Functions developments in Python.\r\n\r\n## Publishing your function app to Azure\r\n  \r\nFor more information on deployment options for Azure Functions, please visit this [guide](https://docs.microsoft.com/en-us/azure/azure-functions/create-first-function-vs-code-python#publish-the-project-to-azure).\r\n\r\n## Next Steps\r\n  \r\nTo learn more specific guidance on developing Azure Functions with Python, please visit [Azure Functions Developer Python Guide](https://docs.microsoft.com/en-us/azure/azure-functions/functions-reference-python?tabs=asgi%2Capplication-level).",
        "host.json": "{\r\n    \"version\": \"2.0\",\r\n    \"logging\": {\r\n      \"applicationInsights\": {\r\n        \"samplingSettings\": {\r\n          \"isEnabled\": true,\r\n          \"excludedTypes\": \"Request\"\r\n        }\r\n      }\r\n    },\r\n    \"extensionBundle\": {\r\n      \"id\": \"Microsoft.Azure.Functions.ExtensionBundle\",\r\n      \"version\": \"[3.15.0, 4.0.0)\"\r\n    }\r\n  }",
        "local.settings.json": "{\r\n    \"IsEncrypted\": false,\r\n    \"Values\": {\r\n      \"FUNCTIONS_WORKER_RUNTIME\": \"python\",\r\n      \"AzureWebJobsStorage\": \"\",\r\n      \"AzureWebJobsFeatureFlags\": \"EnableWorkerIndexing\"\r\n    }\r\n  }",
        "requirements.txt": "# DO NOT include azure-functions-worker in this file\r\n# The Python Worker is managed by Azure Functions platform\r\n# Manually managing azure-functions-worker may cause unexpected issues\r\n\r\nazure-functions"
      },
      "metadata": {
        "defaultFunctionName": "FunctionApp",
        "description": "$FunctionApp_description",
        "name": "FunctionApp",
        "language": "Python",
        "category": [
          "$temp_category_core"
        ],
        "categoryStyle": "projectroot",
        "enabledInTryMode": false,
        "userPrompt": [
          "connection"
        ]
      }
    },
    {
      "id": "HttpTrigger-CSharp",
      "runtime": "2",
      "files": {
        "readme.md": "# HttpTrigger - C<span>#</span>\r\n\r\nThe `HttpTrigger` makes it incredibly easy to have your functions executed via an HTTP call to your function.\r\n\r\n## How it works\r\n\r\nWhen you call the function, be sure you checkout which security rules you apply. If you're using an apikey, you'll need to include that in your request.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
        "run.csx": "#r \"Newtonsoft.Json\"\r\n\r\nusing System.Net;\r\nusing Microsoft.AspNetCore.Mvc;\r\nusing Microsoft.Extensions.Primitives;\r\nusing Newtonsoft.Json;\r\n\r\npublic static async Task<IActionResult> Run(HttpRequest req, ILogger log)\r\n{\r\n    log.LogInformation(\"C# HTTP trigger function processed a request.\");\r\n\r\n    string name = req.Query[\"name\"];\r\n\r\n    string requestBody = await new StreamReader(req.Body).ReadToEndAsync();\r\n    dynamic data = JsonConvert.DeserializeObject(requestBody);\r\n    name = name ?? data?.name;\r\n\r\n    string responseMessage = string.IsNullOrEmpty(name)\r\n        ? \"This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response.\"\r\n                : $\"Hello, {name}. This HTTP triggered function executed successfully.\";\r\n\r\n            return new OkObjectResult(responseMessage);\r\n}",
        "sample.dat": "{\r\n    \"name\": \"Azure\"\r\n}"
      },
      "function": {
        "bindings": [
          {
            "authLevel": "function",
            "name": "req",
            "type": "httpTrigger",
            "direction": "in",
            "methods": [
              "get",
              "post"
            ]
          },
          {
            "name": "$return",
            "type": "http",
            "direction": "out"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "HttpTrigger",
        "description": "$HttpTrigger_description",
        "name": "HTTP trigger",
        "language": "C#",
        "category": [
          "$temp_category_core",
          "$temp_category_api"
        ],
        "categoryStyle": "http",
        "enabledInTryMode": true,
        "userPrompt": [
          "authLevel"
        ]
      }
    },
    {
      "id": "HttpTrigger-Custom",
      "runtime": "2",
      "files": {},
      "function": {
        "bindings": [
          {
            "authLevel": "function",
            "type": "httpTrigger",
            "direction": "in",
            "name": "req",
            "methods": [
              "get",
              "post"
            ]
          },
          {
            "type": "http",
            "direction": "out",
            "name": "res"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "HttpTrigger",
        "description": "$HttpTrigger_description",
        "name": "HTTP trigger",
        "trigger": "HttpTrigger",
        "language": "Custom",
        "category": [
          "$temp_category_core",
          "$temp_category_api"
        ],
        "categoryStyle": "http",
        "enabledInTryMode": false,
        "userPrompt": [
          "authLevel"
        ]
      }
    },
    {
      "id": "HttpTrigger-JavaScript",
      "runtime": "2",
      "files": {
        "index.js": "module.exports = async function (context, req) {\r\n    context.log('JavaScript HTTP trigger function processed a request.');\r\n\r\n    const name = (req.query.name || (req.body && req.body.name));\r\n    const responseMessage = name\r\n        ? \"Hello, \" + name + \". This HTTP triggered function executed successfully.\"\r\n        : \"This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response.\";\r\n\r\n    context.res = {\r\n        // status: 200, /* Defaults to 200 */\r\n        body: responseMessage\r\n    };\r\n}",
        "sample.dat": "{\r\n    \"name\": \"Azure\"\r\n}"
      },
      "function": {
        "bindings": [
          {
            "authLevel": "function",
            "type": "httpTrigger",
            "direction": "in",
            "name": "req",
            "methods": [
              "get",
              "post"
            ]
          },
          {
            "type": "http",
            "direction": "out",
            "name": "res"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "HttpTrigger",
        "description": "$HttpTrigger_description",
        "name": "HTTP trigger",
        "language": "JavaScript",
        "trigger": "HttpTrigger",
        "category": [
          "$temp_category_core",
          "$temp_category_api"
        ],
        "categoryStyle": "http",
        "enabledInTryMode": true,
        "userPrompt": [
          "authLevel"
        ]
      }
    },
    {
      "id": "HttpTrigger-PowerShell",
      "runtime": "2",
      "files": {
        "run.ps1": "using namespace System.Net\n\n# Input bindings are passed in via param block.\nparam($Request, $TriggerMetadata)\n\n# Write to the Azure Functions log stream.\nWrite-Host \"PowerShell HTTP trigger function processed a request.\"\n\n# Interact with query parameters or the body of the request.\n$name = $Request.Query.Name\nif (-not $name) {\n    $name = $Request.Body.Name\n}\n\n$body = \"This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response.\"\n\nif ($name) {\n    $body = \"Hello, $name. This HTTP triggered function executed successfully.\"\n}\n\n# Associate values to output bindings by calling 'Push-OutputBinding'.\nPush-OutputBinding -Name Response -Value ([HttpResponseContext]@{\n    StatusCode = [HttpStatusCode]::OK\n    Body = $body\n})\n",
        "sample.dat": "{\r\n    \"name\": \"Azure\"\r\n}\r\n"
      },
      "function": {
        "bindings": [
          {
            "authLevel": "function",
            "type": "httpTrigger",
            "direction": "in",
            "name": "Request",
            "methods": [
              "get",
              "post"
            ]
          },
          {
            "type": "http",
            "direction": "out",
            "name": "Response"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "HttpTrigger",
        "description": "$HttpTrigger_description",
        "name": "HTTP trigger",
        "language": "PowerShell",
        "trigger": "HttpTrigger",
        "category": [
          "$temp_category_core",
          "$temp_category_api"
        ],
        "categoryStyle": "http",
        "enabledInTryMode": true,
        "userPrompt": [
          "authLevel"
        ]
      }
    },
    {
      "id": "HttpTrigger-Python",
      "runtime": "2",
      "files": {
        "sample.dat": "{\r\n    \"name\": \"Azure\"\r\n}",
        "__init__.py": "import logging\r\n\r\nimport azure.functions as func\r\n\r\n\r\ndef main(req: func.HttpRequest) -> func.HttpResponse:\r\n    logging.info('Python HTTP trigger function processed a request.')\r\n\r\n    name = req.params.get('name')\r\n    if not name:\r\n        try:\r\n            req_body = req.get_json()\r\n        except ValueError:\r\n            pass\r\n        else:\r\n            name = req_body.get('name')\r\n\r\n    if name:\r\n        return func.HttpResponse(f\"Hello, {name}. This HTTP triggered function executed successfully.\")\r\n    else:\r\n        return func.HttpResponse(\r\n             \"This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response.\",\r\n             status_code=200\r\n        )\r\n"
      },
      "function": {
        "scriptFile": "__init__.py",
        "bindings": [
          {
            "authLevel": "function",
            "type": "httpTrigger",
            "direction": "in",
            "name": "req",
            "methods": [
              "get",
              "post"
            ]
          },
          {
            "type": "http",
            "direction": "out",
            "name": "$return"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "HttpTrigger",
        "description": "$HttpTrigger_description",
        "name": "HTTP trigger",
        "language": "Python",
        "trigger": "HttpTrigger",
        "category": [
          "$temp_category_core",
          "$temp_category_api"
        ],
        "categoryStyle": "http",
        "enabledInTryMode": true,
        "userPrompt": [
          "authLevel"
        ],
        "filters": [
          "Python3"
        ]
      }
    },
    {
      "id": "HttpTrigger-Python-Preview",
      "runtime": "2",
      "files": {
        "function_app.py": "import azure.functions as func\nimport logging\n\napp = func.FunctionApp(auth_level=func.AuthLevel.ANONYMOUS)\n\n@app.function_name(name=\"HttpTrigger1\")\n@app.route(route=\"hello\")\ndef test_function(req: func.HttpRequest) -> func.HttpResponse:\n     logging.info('Python HTTP trigger function processed a request.')\n\n     name = req.params.get('name')\n     if not name:\n        try:\n            req_body = req.get_json()\n        except ValueError:\n            pass\n        else:\n            name = req_body.get('name')\n\n     if name:\n        return func.HttpResponse(f\"Hello, {name}. This HTTP triggered function executed successfully.\")\n     else:\n        return func.HttpResponse(\n             \"This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response.\",\n             status_code=200\n        )\n",
        "http_trigger_template.md": "# Azure Functions: HTTP Trigger in Python\r\n\r\n## HTTP Trigger\r\n\r\nThe HTTP trigger lets you invoke a function with an HTTP request. You can use an HTTP trigger to build serverless APIs and respond to webhooks.\r\n\r\n## Using the Template\r\n\r\nFollowing is an example code snippet for HTTP Trigger using the [Python programming model V2](https://aka.ms/pythonprogrammingmodel) (currently in Preview).\r\n\r\n```python\r\nimport azure.functions as func\r\nimport logging\r\n\r\napp = func.FunctionApp(auth_level=func.AuthLevel.ANONYMOUS)\r\n\r\n@app.function_name(name=\"HttpTrigger1\")\r\n@app.route(route=\"hello\")\r\ndef test_function(req: func.HttpRequest) -> func.HttpResponse:\r\n     logging.info('Python HTTP trigger function processed a request.')\r\n\r\n     name = req.params.get('name')\r\n     if not name:\r\n        try:\r\n            req_body = req.get_json()\r\n        except ValueError:\r\n            pass\r\n        else:\r\n            name = req_body.get('name')\r\n\r\n     if name:\r\n        return func.HttpResponse(f\"Hello, {name}. This HTTP triggered function executed successfully.\")\r\n     else:\r\n        return func.HttpResponse(\r\n             \"This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response.\",\r\n             status_code=200\r\n        )\r\n```\r\n\r\nTo run the code snippet generated through the command palette, note the following:\r\n\r\n- The function application is defined and named `app`.\r\n- Confirm that the parameters within the trigger reflect values that correspond with your storage account.\r\n- The name of the file must be `function_app.py`.\r\n  \r\nNote that HTTP output bindings are also supported in Azure Functions. To learn more, see [Azure Functions HTTP triggers and bindings overview](https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-http-webhook?tabs=in-process%2Cfunctionsv2&pivots=programming-language-python)\r\n\r\n## Programming Model V2 (Preview)\r\n\r\nThe new programming model in Azure Functions Python delivers an experience that aligns with Python development principles, and subsequently with commonly used Python frameworks. \r\n\r\nThe improved programming model requires fewer files than the default model, and specifically eliminates the need for a configuration file (`function.json`). Instead, triggers and bindings are represented in the `function_app.py` file as decorators. Moreover, functions can be logically organized with support for multiple functions to be stored in the same file. Functions within the same function application can also be stored in different files, and be referenced as blueprints.\r\n\r\nTo learn more about using the new Python programming model for Azure Functions, see the [Azure Functions Python developer guide](https://aka.ms/pythondeveloperguide). Note that in addition to the documentation, [hints](https://aka.ms/functions-python-hints) are available in code editors that support type checking with PYI files.\r\n\r\nTo learn more about the new programming model for Azure Functions in Python, see [Programming Models in Azure Functions](https://aka.ms/functions-programming-models)."
      },
      "metadata": {
        "defaultFunctionName": "HttpTrigger",
        "description": "$HttpTrigger_description",
        "name": "HTTP trigger",
        "language": "Python",
        "trigger": "HttpTrigger",
        "category": [
          "$temp_category_core",
          "$temp_category_api"
        ],
        "categoryStyle": "http",
        "enabledInTryMode": true,
        "userPrompt": [
          "authLevel"
        ],
        "filters": [
          "Python3"
        ]
      }
    },
    {
      "id": "HttpTrigger-Python-Preview-Append",
      "runtime": "2",
      "files": {
        "function_app.py": "@app.function_name(name=\"HttpTrigger1\")\n@app.route(route=\"hello\")\ndef test_function(req: func.HttpRequest) -> func.HttpResponse:\n     logging.info('Python HTTP trigger function processed a request.')\n\n     name = req.params.get('name')\n     if not name:\n        try:\n            req_body = req.get_json()\n        except ValueError:\n            pass\n        else:\n            name = req_body.get('name')\n\n     if name:\n        return func.HttpResponse(f\"Hello, {name}. This HTTP triggered function executed successfully.\")\n     else:\n        return func.HttpResponse(\n             \"This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response.\",\n             status_code=200\n        )\n",
        "http_trigger_template.md": "# Azure Functions: HTTP Trigger in Python\r\n\r\n## HTTP Trigger\r\n\r\nThe HTTP trigger lets you invoke a function with an HTTP request. You can use an HTTP trigger to build serverless APIs and respond to webhooks.\r\n\r\n## Using the Template\r\n\r\nFollowing is an example code snippet for HTTP Trigger using the [Python programming model V2](https://aka.ms/pythonprogrammingmodel) (currently in Preview).\r\n\r\n```python\r\nimport azure.functions as func\r\nimport logging\r\n\r\napp = func.FunctionApp(auth_level=func.AuthLevel.ANONYMOUS)\r\n\r\n@app.function_name(name=\"HttpTrigger1\")\r\n@app.route(route=\"hello\")\r\ndef test_function(req: func.HttpRequest) -> func.HttpResponse:\r\n     logging.info('Python HTTP trigger function processed a request.')\r\n\r\n     name = req.params.get('name')\r\n     if not name:\r\n        try:\r\n            req_body = req.get_json()\r\n        except ValueError:\r\n            pass\r\n        else:\r\n            name = req_body.get('name')\r\n\r\n     if name:\r\n        return func.HttpResponse(f\"Hello, {name}. This HTTP triggered function executed successfully.\")\r\n     else:\r\n        return func.HttpResponse(\r\n             \"This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response.\",\r\n             status_code=200\r\n        )\r\n```\r\n\r\nTo run the code snippet generated through the command palette, note the following:\r\n\r\n- The function application is defined and named `app`.\r\n- Confirm that the parameters within the trigger reflect values that correspond with your storage account.\r\n- The name of the file must be `function_app.py`.\r\n  \r\nNote that HTTP output bindings are also supported in Azure Functions. To learn more, see [Azure Functions HTTP triggers and bindings overview](https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-http-webhook?tabs=in-process%2Cfunctionsv2&pivots=programming-language-python)\r\n\r\n## Programming Model V2 (Preview)\r\n\r\nThe new programming model in Azure Functions Python delivers an experience that aligns with Python development principles, and subsequently with commonly used Python frameworks. \r\n\r\nThe improved programming model requires fewer files than the default model, and specifically eliminates the need for a configuration file (`function.json`). Instead, triggers and bindings are represented in the `function_app.py` file as decorators. Moreover, functions can be logically organized with support for multiple functions to be stored in the same file. Functions within the same function application can also be stored in different files, and be referenced as blueprints.\r\n\r\nTo learn more about using the new Python programming model for Azure Functions, see the [Azure Functions Python developer guide](https://aka.ms/pythondeveloperguide). Note that in addition to the documentation, [hints](https://aka.ms/functions-python-hints) are available in code editors that support type checking with PYI files.\r\n\r\nTo learn more about the new programming model for Azure Functions in Python, see [Programming Models in Azure Functions](https://aka.ms/functions-programming-models)."
      },
      "metadata": {
        "defaultFunctionName": "HttpTrigger",
        "description": "$HttpTrigger_description",
        "name": "HTTP trigger",
        "language": "Python",
        "trigger": "HttpTrigger",
        "category": [
          "$temp_category_core",
          "$temp_category_api"
        ],
        "categoryStyle": "http",
        "enabledInTryMode": true,
        "userPrompt": [
          "authLevel"
        ],
        "filters": [
          "Python3"
        ]
      }
    },
    {
      "id": "HttpTrigger-TypeScript",
      "runtime": "2",
      "files": {
        "index.ts": "import { AzureFunction, Context, HttpRequest } from \"@azure/functions\"\r\n\r\nconst httpTrigger: AzureFunction = async function (context: Context, req: HttpRequest): Promise<void> {\r\n    context.log('HTTP trigger function processed a request.');\r\n    const name = (req.query.name || (req.body && req.body.name));\r\n    const responseMessage = name\r\n        ? \"Hello, \" + name + \". This HTTP triggered function executed successfully.\"\r\n        : \"This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response.\";\r\n\r\n    context.res = {\r\n        // status: 200, /* Defaults to 200 */\r\n        body: responseMessage\r\n    };\r\n\r\n};\r\n\r\nexport default httpTrigger;",
        "sample.dat": "{\r\n    \"name\": \"Azure\"\r\n}"
      },
      "function": {
        "bindings": [
          {
            "authLevel": "function",
            "type": "httpTrigger",
            "direction": "in",
            "name": "req",
            "methods": [
              "get",
              "post"
            ]
          },
          {
            "type": "http",
            "direction": "out",
            "name": "res"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "HttpTrigger",
        "description": "$HttpTrigger_description",
        "name": "HTTP trigger",
        "language": "TypeScript",
        "trigger": "HttpTrigger",
        "category": [
          "$temp_category_core",
          "$temp_category_api"
        ],
        "categoryStyle": "http",
        "enabledInTryMode": true,
        "userPrompt": [
          "authLevel"
        ]
      }
    },
    {
      "id": "IoTHubTrigger-CSharp",
      "runtime": "2",
      "files": {
        "run.csx": "using System;\n\npublic static void Run(string myIoTHubMessage, ILogger log)\n{\n    log.LogInformation($\"C# IoT Hub trigger function processed a message: {myIoTHubMessage}\");\n}",
        "sample.dat": "Test Message"
      },
      "function": {
        "bindings": [
          {
            "type": "eventHubTrigger",
            "name": "myIoTHubMessage",
            "direction": "in",
            "eventHubName": "samples-workitems",
            "connection": "",
            "consumerGroup": "$Default"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "IoTHub_EventHub",
        "description": "$IoTHubTrigger_description",
        "name": "IoT Hub (Event Hub)",
        "language": "C#",
        "category": [
          "$temp_category_IoTHub"
        ],
        "categoryStyle": "iot",
        "enabledInTryMode": false,
        "userPrompt": [
          "connection",
          "path",
          "consumerGroup"
        ]
      }
    },
    {
      "id": "IoTHubTrigger-Custom",
      "runtime": "2",
      "files": {},
      "function": {
        "bindings": [
          {
            "type": "eventHubTrigger",
            "name": "IoTHubMessages",
            "direction": "in",
            "eventHubName": "samples-workitems",
            "connection": "",
            "cardinality": "many",
            "consumerGroup": "$Default"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "IoTHub_EventHub",
        "description": "$IoTHubTrigger_description",
        "name": "IoT Hub (Event Hub)",
        "language": "Custom",
        "category": [
          "$temp_category_IoTHub"
        ],
        "categoryStyle": "iot",
        "enabledInTryMode": false,
        "userPrompt": [
          "connection",
          "path",
          "consumerGroup"
        ]
      }
    },
    {
      "id": "IoTHubTrigger-JavaScript",
      "runtime": "2",
      "files": {
        "index.js": "module.exports = function (context, IoTHubMessages) {\n    context.log(`JavaScript eventhub trigger function called for message array: ${IoTHubMessages}`);\n    \n    IoTHubMessages.forEach(message => {\n        context.log(`Processed message: ${message}`);\n    });\n\n    context.done();\n};",
        "sample.dat": "Test Message"
      },
      "function": {
        "bindings": [
          {
            "type": "eventHubTrigger",
            "name": "IoTHubMessages",
            "direction": "in",
            "eventHubName": "samples-workitems",
            "connection": "",
            "cardinality": "many",
            "consumerGroup": "$Default",
            "dataType": "string"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "IoTHub_EventHub",
        "description": "$IoTHubTrigger_description",
        "name": "IoT Hub (Event Hub)",
        "language": "JavaScript",
        "category": [
          "$temp_category_IoTHub"
        ],
        "categoryStyle": "iot",
        "enabledInTryMode": false,
        "userPrompt": [
          "connection",
          "path",
          "consumerGroup"
        ]
      }
    },
    {
      "id": "IoTHubTrigger-PowerShell",
      "runtime": "2",
      "files": {
        "run.ps1": "param($IoTHubMessages, $TriggerMetadata)\n\nWrite-Host \"PowerShell eventhub trigger function called for message array: $IoTHubMessages\"\n\n$IoTHubMessages | ForEach-Object { Write-Host \"Processed message: $_\" }\n",
        "sample.dat": "Test Message"
      },
      "function": {
        "bindings": [
          {
            "type": "eventHubTrigger",
            "name": "IoTHubMessages",
            "direction": "in",
            "eventHubName": "samples-workitems",
            "connection": "",
            "cardinality": "many",
            "consumerGroup": "$Default"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "IoTHub_EventHub",
        "description": "$IoTHubTrigger_description",
        "name": "IoT Hub (Event Hub)",
        "language": "PowerShell",
        "category": [
          "$temp_category_IoTHub"
        ],
        "categoryStyle": "iot",
        "enabledInTryMode": false,
        "userPrompt": [
          "connection",
          "path",
          "consumerGroup"
        ]
      }
    },
    {
      "id": "IoTHubTrigger-TypeScript",
      "runtime": "2",
      "files": {
        "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\n\nconst IoTHubTrigger: AzureFunction = async function (context: Context, IoTHubMessages: any[]): Promise<void> {\n    context.log(`Eventhub trigger function called for message array: ${IoTHubMessages}`);\n    \n    IoTHubMessages.forEach(message => {\n        context.log(`Processed message: ${message}`);\n    });\n};\n\nexport default IoTHubTrigger;\n",
        "sample.dat": "Test Message"
      },
      "function": {
        "bindings": [
          {
            "type": "eventHubTrigger",
            "name": "IoTHubMessages",
            "direction": "in",
            "eventHubName": "samples-workitems",
            "connection": "",
            "cardinality": "many",
            "consumerGroup": "$Default",
            "dataType": "string"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "IoTHub_EventHub",
        "description": "$IoTHubTrigger_description",
        "name": "IoT Hub (Event Hub)",
        "language": "TypeScript",
        "category": [
          "$temp_category_IoTHub"
        ],
        "categoryStyle": "iot",
        "enabledInTryMode": false,
        "userPrompt": [
          "connection",
          "path",
          "consumerGroup"
        ]
      }
    },
    {
      "id": "KafkaOutput-CSharp",
      "runtime": "2",
      "files": {
        "readme.md": "# KafkaOutput - C<span>#</span>\n\nThe `KafkaOutput` makes it incredibly easy to sent a new events to a Kafka Broker. This sample demonstrates a simple use case of sending data to a given Kafka Broker using C#.\n\n## How it works\n\nFor a `KafkaOutput` to work, you must provide a topic name which dictates where the messages should be sent to with authentication.\n\n## Configuration\n\n### EventHubs for Kafka\n\nAdd `BrokerList` and `KafkaPassword` to your `local.settings.json`\n\n_local.settings.json_\n\n```json\n{\n  \"IsEncrypted\": false,\n  \"Values\": {\n    \"AzureWebJobsStorage\": \"UseDevelopmentStorage=true\",\n    \"FUNCTIONS_WORKER_RUNTIME\": \"dotnet\",\n    \"BrokerList\": \"{YOUR_EVENT_HUBS_NAMESPACE}.servicebus.windows.net:9093\",\n    \"KafkaPassword\": \"{EVENT_HUBS_CONNECTION_STRING}\"\n  }\n}\n```\n\n### Others\n\nModify `function.json` or `KafkaOutput` attribute according to your broker.",
        "run.csx": "#r \"Microsoft.Azure.WebJobs.Extensions.Kafka\"\n#r \"Newtonsoft.Json\"\n\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Azure.WebJobs;\nusing Microsoft.Azure.WebJobs.Extensions.Http;\nusing Microsoft.Azure.WebJobs.Extensions.Kafka;\nusing Microsoft.Extensions.Logging;\nusing Newtonsoft.Json;\n\npublic static IActionResult Run(\n    HttpRequest req,\n    out string eventData,\n    ILogger log)\n{\n    log.LogInformation(\"C# HTTP trigger function processed a request.\");\n\n    string message = req.Query[\"message\"];\n\n    string requestBody = await new StreamReader(req.Body).ReadToEndAsync();\n    dynamic data = JsonConvert.DeserializeObject(requestBody);\n    message = message ?? data?.message;\n\n    string responseMessage = string.IsNullOrEmpty(message)\n        ? \"This HTTP triggered function executed successfully. Pass a message in the query string\"\n        : $\"Message {message} sent to the broker. This HTTP triggered function executed successfully.\";\n    eventData = $\"Received message: {message}\";\n\n    return new OkObjectResult(responseMessage);\n}\n",
        "sample.dat": "{\n    \"message\": \"hello\"\n}"
      },
      "function": {
        "bindings": [
          {
            "authLevel": "function",
            "name": "req",
            "type": "httpTrigger",
            "direction": "in",
            "methods": [
              "get"
            ]
          },
          {
            "name": "$return",
            "type": "http",
            "direction": "out"
          },
          {
            "name": "eventData",
            "type": "kafka",
            "direction": "out",
            "brokerList": "BrokerList",
            "topic": "topic",
            "username": "$ConnectionString",
            "password": "%KafkaPassword%",
            "protocol": "saslSsl",
            "authenticationMode": "plain"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "KafkaOutput",
        "description": "$KafkaOutput_description",
        "name": "Kafka output",
        "language": "C#",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": [
          "brokerList",
          "topic",
          "username",
          "password",
          "protocol",
          "authenticationMode"
        ]
      }
    },
    {
      "id": "KafkaOutput-JavaScript",
      "runtime": "2",
      "files": {
        "index.js": "// This sample will create topic \"topic\" and send message to it. \n// KafkaTrigger will be trigged.\nmodule.exports = async function (context, req) {\n    context.log('JavaScript HTTP trigger function processed a request.');\n\n    const message = (req.query.message || (req.body && req.body.message));\n    const responseMessage = message\n        ? \"Message received: \" + message + \". The message transfered to the kafka broker.\"\n        : \"This HTTP triggered function executed successfully. Pass a message in the query string or in the request body for a personalized response.\";\n    context.bindings.outputKafkaMessage = \"Message : \" + message;\n    context.res = {\n        // status: 200, /* Defaults to 200 */\n        body: responseMessage\n    };\n}",
        "readme.md": "# KafkaOutput - JavaScript\n\nThe `KafkaOutput` makes it incredibly easy to send a new events to a Kafka Broker. This sample demonstrates a simple use case of sending data to a given Kafka Broker using JavaScript.\n\n## How it works\n\nFor a `KafkaOutput` to work, you must provide a topic name which dictates where the messages should be sent to with authentication.\n\n## Configuration\n\n### EventHubs for Kafka\n\nAdd `BrokerList` and `KafkaPassword` to your `local.settings.json`\n\n_local.settings.json_\n\n```json\n{\n  \"IsEncrypted\": false,\n  \"Values\": {\n    \"AzureWebJobsStorage\": \"UseDevelopmentStorage=true\",\n    \"FUNCTIONS_WORKER_RUNTIME\": \"node\",\n    \"BrokerList\": \"{YOUR_EVENT_HUBS_NAMESPACE}.servicebus.windows.net:9093\",\n    \"KafkaPassword\": \"{EVENT_HUBS_CONNECTION_STRING}\"\n  }\n}\n```\n\n### Others\n\nModify `function.json` or `KafkaOutput` attribute according to your broker.",
        "sample.dat": "{\n    \"message\": \"hello\"\n}"
      },
      "function": {
        "bindings": [
          {
            "authLevel": "function",
            "type": "httpTrigger",
            "direction": "in",
            "name": "req",
            "methods": [
              "get",
              "post"
            ]
          },
          {
            "type": "kafka",
            "name": "outputKafkaMessage",
            "brokerList": "BrokerList",
            "topic": "topic",
            "username": "$ConnectionString",
            "password": "%KafkaPassword%",
            "protocol": "SASLSSL",
            "authenticationMode": "PLAIN",
            "direction": "out"
          },
          {
            "type": "http",
            "direction": "out",
            "name": "res"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "KafkaOutput",
        "description": "$KafkaOutput_description",
        "name": "Kafka output",
        "language": "JavaScript",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": [
          "brokerList",
          "topic",
          "username",
          "password",
          "protocol",
          "authenticationMode"
        ]
      }
    },
    {
      "id": "KafkaOutput-PowerShell",
      "runtime": "2",
      "files": {
        "readme.md": "# KafkaOutput - PowerShell\n\nThe `KafkaOutput` makes it incredibly easy to send a new events to a Kafka Broker. This sample demonstrates a simple use case of sending data to a given Kafka Broker using PowerShell.\n\n## How it works\n\nFor a `KafkaOutput` to work, you must provide a topic name which dictates where the messages should be sent to with authentication.\n\n## Configuration\n\n### EventHubs for Kafka\n\nAdd `BrokerList` and `KafkaPassword` to your `local.settings.json`\n\n_local.settings.json_\n\n```json\n{\n  \"IsEncrypted\": false,\n  \"Values\": {\n    \"AzureWebJobsStorage\": \"UseDevelopmentStorage=true\",\n    \"FUNCTIONS_WORKER_RUNTIME\": \"node\",\n    \"BrokerList\": \"{YOUR_EVENT_HUBS_NAMESPACE}.servicebus.windows.net:9093\",\n    \"KafkaPassword\": \"{EVENT_HUBS_CONNECTION_STRING}\"\n  }\n}\n```\n\n### Others\n\nModify `function.json` or `KafkaOutput` attribute according to your broker.",
        "run.ps1": "using namespace System.Net\n\n# Input bindings are passed in via param block.\nparam($Request, $TriggerMetadata)\n\n# Write to the Azure Functions log stream.\nWrite-Host \"PowerShell HTTP trigger function processed a request.\"\n\n# Interact with query parameters or the body of the request.\n$message = $Request.Query.Message\nif (-not $message) {\n    $message = $Request.Body.Message\n}\n\n$body = \"This HTTP triggered function executed successfully. Pass a message in the query string or in the request body for a personalized response.\"\n\nif ($message) {\n    $body = \"Message received:  $message. The message transfered to the kafka broker.\"\n}\n\nPush-OutputBinding -Name Message -Value (\"Message: \" + $message)\n\n# Associate values to output bindings by calling 'Push-OutputBinding'.\nPush-OutputBinding -Name Response -Value ([HttpResponseContext]@{\n    StatusCode = [HttpStatusCode]::OK\n    Body = $body\n})\n",
        "sample.dat": "{\n    \"message\": \"hello\"\n}"
      },
      "function": {
        "bindings": [
          {
            "authLevel": "function",
            "type": "httpTrigger",
            "direction": "in",
            "name": "Request",
            "methods": [
              "get",
              "post"
            ]
          },
          {
            "type": "kafka",
            "name": "Message",
            "brokerList": "BrokerList",
            "topic": "topic",
            "username": "$ConnectionString",
            "password": "%KafkaPassword%",
            "protocol": "SASLSSL",
            "authenticationMode": "PLAIN",
            "direction": "out"
          },
          {
            "type": "http",
            "direction": "out",
            "name": "Response"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "KafkaOutput",
        "description": "$KafkaOutput_description",
        "name": "Kafka output",
        "language": "PowerShell",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": [
          "brokerList",
          "topic",
          "username",
          "password",
          "protocol",
          "authenticationMode"
        ]
      }
    },
    {
      "id": "KafkaOutput-Python",
      "runtime": "2",
      "files": {
        "readme.md": "# KafkaOutput - Python\n\nThe `KafkaOutput` makes it incredibly easy to send a new events to a Kafka Broker. This sample demonstrates a simple use case of sending data to a given Kafka Broker using Python.\n\n## How it works\n\nFor a `KafkaOutput` to work, you must provide a topic name which dictates where the messages should be sent to with authentication.\n\n## Configuration\n\n### EventHubs for Kafka\n\nAdd `BrokerList` and `KafkaPassword` to your `local.settings.json`\n\n_local.settings.json_\n\n```json\n{\n  \"IsEncrypted\": false,\n  \"Values\": {\n    \"AzureWebJobsStorage\": \"UseDevelopmentStorage=true\",\n    \"FUNCTIONS_WORKER_RUNTIME\": \"node\",\n    \"BrokerList\": \"{YOUR_EVENT_HUBS_NAMESPACE}.servicebus.windows.net:9093\",\n    \"KafkaPassword\": \"{EVENT_HUBS_CONNECTION_STRING}\"\n  }\n}\n```\n\n### Others\n\nModify `function.json` or `KafkaOutput` attribute according to your broker.",
        "sample.dat": "{\n    \"message\": \"hello\"\n}",
        "__init__.py": "import logging\n\nimport azure.functions as func\n\n\ndef main(req: func.HttpRequest, out: func.Out[str]) -> func.HttpResponse:\n    logging.info('Python HTTP trigger function processed a request.')\n\n    message = req.params.get('message')\n    if not message:\n        try:\n            req_body = req.get_json()\n        except ValueError:\n            pass\n        else:\n            message = req_body.get('message')\n\n    if message:\n        out.set(message)\n        return func.HttpResponse(f\"Message received: {message}. The message transfered to the kafka broker.\")\n    else:\n        return func.HttpResponse(\n             \"This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response.\",\n             status_code=200\n        )\n"
      },
      "function": {
        "scriptFile": "__init__.py",
        "bindings": [
          {
            "authLevel": "function",
            "type": "httpTrigger",
            "direction": "in",
            "name": "req",
            "methods": [
              "get",
              "post"
            ]
          },
          {
            "type": "kafka",
            "direction": "out",
            "name": "out",
            "brokerList": "BrokerList",
            "topic": "topic",
            "username": "$ConnectionString",
            "password": "%KafkaPassword%",
            "protocol": "SASLSSL",
            "authenticationMode": "PLAIN"
          },
          {
            "type": "http",
            "direction": "out",
            "name": "$return"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "KafkaOutput",
        "description": "$KafkaOutput_description",
        "name": "Kafka output",
        "language": "Python",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": [
          "brokerList",
          "topic",
          "username",
          "password",
          "protocol",
          "authenticationMode"
        ]
      }
    },
    {
      "id": "KafkaOutput-TypeScript",
      "runtime": "2",
      "files": {
        "index.ts": "import { AzureFunction, Context, HttpRequest } from \"@azure/functions\"\n\nconst httpTrigger: AzureFunction = async function (context: Context, req: HttpRequest): Promise<void> {\n    context.log('HTTP trigger function processed a request.');\n    const message = (req.query.message || (req.body && req.body.message));\n    const responseMessage = message\n        ? \"Message received: \" + message + \". The message transfered to the kafka broker.\"\n        : \"This HTTP triggered function executed successfully. Pass a message in the query string or in the request body for a personalized response.\";\n    context.bindings.outputKafkaMessage = \"Message : \" + message;\n    context.res = {\n        // status: 200, /* Defaults to 200 */\n        body: responseMessage\n    };\n\n};\n\nexport default httpTrigger;",
        "readme.md": "# KafkaOutput - TypeScript\n\nThe `KafkaOutput` makes it incredibly easy to send a new events to a Kafka Broker. This sample demonstrates a simple use case of sending data to a given Kafka Broker using TypeScript.\n\n## How it works\n\nFor a `KafkaOutput` to work, you must provide a topic name which dictates where the messages should be sent to with authentication.\n\n## Configuration\n\n### EventHubs for Kafka\n\nAdd `BrokerList` and `KafkaPassword` to your `local.settings.json`\n\n_local.settings.json_\n\n```json\n{\n  \"IsEncrypted\": false,\n  \"Values\": {\n    \"AzureWebJobsStorage\": \"UseDevelopmentStorage=true\",\n    \"FUNCTIONS_WORKER_RUNTIME\": \"node\",\n    \"BrokerList\": \"{YOUR_EVENT_HUBS_NAMESPACE}.servicebus.windows.net:9093\",\n    \"KafkaPassword\": \"{EVENT_HUBS_CONNECTION_STRING}\"\n  }\n}\n```\n\n### Others\n\nModify `function.json` or `KafkaOutput` attribute according to your broker.",
        "sample.dat": "{\n    \"message\": \"hello\"\n}"
      },
      "function": {
        "bindings": [
          {
            "authLevel": "function",
            "type": "httpTrigger",
            "direction": "in",
            "name": "req",
            "methods": [
              "get",
              "post"
            ]
          },
          {
            "type": "kafka",
            "name": "outputKafkaMessage",
            "brokerList": "BrokerList",
            "topic": "topic",
            "username": "$ConnectionString",
            "password": "%KafkaPassword%",
            "protocol": "SASLSSL",
            "authenticationMode": "PLAIN",
            "direction": "out"
          },
          {
            "type": "http",
            "direction": "out",
            "name": "res"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "KafkaOutput",
        "description": "$KafkaOutput_description",
        "name": "Kafka output",
        "language": "TypeScript",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": [
          "brokerList",
          "topic",
          "username",
          "password",
          "protocol",
          "authenticationMode"
        ]
      }
    },
    {
      "id": "KafkaTrigger-CSharp",
      "runtime": "2",
      "files": {
        "readme.md": "# KafkaTrigger - C<span>#</span>\n\nThe `KafkaTrigger` makes it incredibly easy to react to new events from a Kafka Broker. This sample demonstrates a simple use case of processing data from a given Kafka Broker using C#.\n\n## How it works\n\nFor a `KafkaTrigger` to work, you must provide a topic name which dictates where the messages should be read from with authentication.\n\n## Configuration\n\n### EventHubs for Kafka\n\nAdd `BrokerList` and `KafkaPassword` to your `local.settings.json`\n\n_local.settings.json_\n\n```json\n{\n  \"IsEncrypted\": false,\n  \"Values\": {\n    \"AzureWebJobsStorage\": \"UseDevelopmentStorage=true\",\n    \"FUNCTIONS_WORKER_RUNTIME\": \"dotnet\",\n    \"BrokerList\": \"{YOUR_EVENT_HUBS_NAMESPACE}.servicebus.windows.net:9093\",\n    \"KafkaPassword\": \"{EVENT_HUBS_CONNECTION_STRING}\"\n  }\n}\n```\n\n### Others\n\nModify `function.json` or `KafkaTrigger` attribute according to your broker.",
        "run.csx": "#r \"Microsoft.Azure.WebJobs.Extensions.Kafka\"\n\nusing System;\nusing System.Text;\nusing Microsoft.Azure.WebJobs.Extensions.Kafka;\n\npublic static void Run(KafkaEventData<string> eventData, ILogger log)\n{\n    log.LogInformation($\"C# Queue trigger function processed: {eventData.Value}\");\n}\n",
        "sample.dat": "sample queue data"
      },
      "function": {
        "bindings": [
          {
            "name": "eventData",
            "type": "kafkaTrigger",
            "direction": "in",
            "brokerList": "BrokerList",
            "topic": "topic",
            "username": "$ConnectionString",
            "password": "%KafkaPassword%",
            "protocol": "saslSsl",
            "authenticationMode": "plain",
            "consumerGroup": "$Default"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "KafkaTrigger",
        "description": "$KafkaTrigger_description",
        "name": "Kafka trigger",
        "language": "C#",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": [
          "brokerList",
          "topic",
          "username",
          "password",
          "protocol",
          "authenticationMode",
          "consumerGroup"
        ]
      }
    },
    {
      "id": "KafkaTrigger-Custom",
      "runtime": "2",
      "files": {},
      "function": {
        "bindings": [
          {
            "name": "eventData",
            "type": "kafkaTrigger",
            "direction": "in",
            "brokerList": "BrokerList",
            "topic": "topic",
            "username": "$ConnectionString",
            "password": "%KafkaPassword%",
            "protocol": "saslSsl",
            "authenticationMode": "plain",
            "consumerGroup": "$Default"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "KafkaTrigger",
        "description": "$KafkaTrigger_description",
        "name": "Kafka trigger",
        "language": "Custom",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": [
          "brokerList",
          "topic",
          "username",
          "password",
          "protocol",
          "authenticationMode",
          "consumerGroup"
        ]
      }
    },
    {
      "id": "KafkaTrigger-JavaScript",
      "runtime": "2",
      "files": {
        "index.js": "var string_decode = require('string_decoder').StringDecoder;\n\nmodule.exports = async function (context, event) {\n    const dec = new string_decode('utf-8');\n    let event_str = dec.write(event);\n\n    context.log.info(`JavaScript Kafka trigger function called for message ${event_str}`);\n};",
        "readme.md": "# KafkaTrigger - JavaScript\n\nThe `KafkaTrigger` makes it incredibly easy to react to new events from a Kafka Broker. This sample demonstrates a simple use case of processing data from a given Kafka Broker using JavaScript.\n\n## How it works\n\nFor a `KafkaTrigger` to work, you must provide a topic name which dictates where the messages should be read from with authentication.\n\n## Configuration\n\n### EventHubs for Kafka\n\nAdd `BrokerList` and `KafkaPassword` to your `local.settings.json`\n\n_local.settings.json_\n\n```json\n{\n  \"IsEncrypted\": false,\n  \"Values\": {\n    \"AzureWebJobsStorage\": \"UseDevelopmentStorage=true\",\n    \"FUNCTIONS_WORKER_RUNTIME\": \"node\",\n    \"BrokerList\": \"{YOUR_EVENT_HUBS_NAMESPACE}.servicebus.windows.net:9093\",\n    \"KafkaPassword\": \"{EVENT_HUBS_CONNECTION_STRING}\"\n  }\n}\n```\n\n### Others\n\nModify `function.json` or `KafkaTrigger` attribute according to your broker.",
        "sample.dat": "sample queue data"
      },
      "function": {
        "bindings": [
          {
            "type": "kafkaTrigger",
            "name": "event",
            "direction": "in",
            "brokerList": "BrokerList",
            "topic": "topic",
            "username": "$ConnectionString",
            "password": "%KafkaPassword%",
            "protocol": "saslSsl",
            "authenticationMode": "plain",
            "consumerGroup": "$Default",
            "dataType": "binary"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "KafkaTrigger",
        "description": "$KafkaTrigger_description",
        "name": "Kafka trigger",
        "language": "JavaScript",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": [
          "brokerList",
          "topic",
          "username",
          "password",
          "protocol",
          "authenticationMode",
          "consumerGroup"
        ]
      }
    },
    {
      "id": "KafkaTrigger-PowerShell",
      "runtime": "2",
      "files": {
        "readme.md": "# KafkaTrigger - PowerShell\n\nThe `KafkaTrigger` makes it incredibly easy to react to new events from a Kafka Broker. This sample demonstrates a simple use case of processing data from a given Kafka Broker using PowerShell.\n\n## How it works\n\nFor a `KafkaTrigger` to work, you must provide a topic name which dictates where the messages should be read from with authentication.\n\n## Configuration\n\n### EventHubs for Kafka\n\nAdd `BrokerList` and `KafkaPassword` to your `local.settings.json`\n\n_local.settings.json_\n\n```json\n{\n  \"IsEncrypted\": false,\n  \"Values\": {\n    \"AzureWebJobsStorage\": \"UseDevelopmentStorage=true\",\n    \"FUNCTIONS_WORKER_RUNTIME\": \"powershell\",\n    \"FUNCTIONS_WORKER_RUNTIME_VERSION\": \"~7\",\n    \"BrokerList\": \"{YOUR_EVENT_HUBS_NAMESPACE}.servicebus.windows.net:9093\",\n    \"KafkaPassword\": \"{EVENT_HUBS_CONNECTION_STRING}\"\n  }\n}\n```\n\n### Others\n\nModify `function.json` or `KafkaTrigger` attribute according to your broker.",
        "run.ps1": "using namespace System.Net\n\nparam($kafkaEvent, $TriggerMetadata)\n\n$kafkaEvent \n\n$TriggerMetadata",
        "sample.dat": "sample queue data"
      },
      "function": {
        "bindings": [
          {
            "type": "kafkaTrigger",
            "name": "kafkaEvent",
            "direction": "in",
            "brokerList": "BrokerList",
            "topic": "topic",
            "username": "$ConnectionString",
            "password": "%KafkaPassword%",
            "protocol": "saslSsl",
            "authenticationMode": "plain",
            "consumerGroup": "$Default"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "KafkaTrigger",
        "description": "$KafkaTrigger_description",
        "name": "Kafka trigger",
        "language": "PowerShell",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": [
          "brokerList",
          "topic",
          "username",
          "password",
          "protocol",
          "authenticationMode",
          "consumerGroup"
        ]
      }
    },
    {
      "id": "KafkaTrigger-Python",
      "runtime": "2",
      "files": {
        "readme.md": "# KafkaTrigger - Python\n\nThe `KafkaTrigger` makes it incredibly easy to react to new events from a Kafka Broker. This sample demonstrates a simple use case of processing data from a given Kafka Broker using Python.\n\n## How it works\n\nFor a `KafkaTrigger` to work, you must provide a topic name which dictates where the messages should be read from with authentication.\n\n## Configuration\n\n### EventHubs for Kafka\n\nAdd `BrokerList` and `KafkaPassword` to your `local.settings.json`\n\n_local.settings.json_\n\n```json\n{\n  \"IsEncrypted\": false,\n  \"Values\": {\n    \"AzureWebJobsStorage\": \"UseDevelopmentStorage=true\",\n    \"FUNCTIONS_WORKER_RUNTIME\": \"python\",\n    \"BrokerList\": \"{YOUR_EVENT_HUBS_NAMESPACE}.servicebus.windows.net:9093\",\n    \"KafkaPassword\": \"{EVENT_HUBS_CONNECTION_STRING}\"\n  }\n}\n```\n\n### Others\n\nModify `function.json` or `KafkaTrigger` attribute according to your broker.",
        "sample.dat": "sample queue data",
        "__init__.py": "import logging\nfrom azure.functions import KafkaEvent\n\ndef main(kevent : KafkaEvent):\n    logging.info(kevent.get_body().decode('utf-8'))\n    logging.info(kevent.metadata)\n"
      },
      "function": {
        "scriptFile": "__init__.py",
        "bindings": [
          {
            "type": "kafkaTrigger",
            "name": "kevent",
            "direction": "in",
            "brokerList": "BrokerList",
            "topic": "topic",
            "username": "$ConnectionString",
            "password": "%KafkaPassword%",
            "protocol": "saslSsl",
            "authenticationMode": "plain",
            "consumerGroup": "$Default"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "KafkaTrigger",
        "description": "$KafkaTrigger_description",
        "name": "Kafka trigger",
        "language": "Python",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": [
          "brokerList",
          "topic",
          "username",
          "password",
          "protocol",
          "authenticationMode",
          "consumerGroup"
        ]
      }
    },
    {
      "id": "KafkaTrigger-TypeScript",
      "runtime": "2",
      "files": {
        "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\n\n// This is to describe the metadata of a Kafka event\nclass KafkaEvent {\n    Offset : number;\n    Partition : number;\n    Topic : string;\n    Timestamp : string;\n    Value : string;\n    \n    constructor(metadata:any) {\n        this.Offset = metadata.Offset;\n        this.Partition = metadata.Partition;\n        this.Topic = metadata.Topic;\n        this.Timestamp = metadata.Timestamp;\n        this.Value = metadata.Value;\n    }\n\n    public getValue<T>() : T {\n        return JSON.parse(this.Value).payload;\n    }\n}\n\nconst kafkaTrigger: AzureFunction = async function (context: Context, event_str: string): Promise<void> {\n\n    let event_obj = new KafkaEvent(eval(event_str));\n\n    context.log(\"Event Offset: \" + event_obj.Offset);\n    context.log(\"Event Partition: \" + event_obj.Partition);\n    context.log(\"Event Topic: \" + event_obj.Topic);\n    context.log(\"Event Timestamp: \" + event_obj.Timestamp);\n    context.log(\"Event Value (as string): \" + event_obj.Value);\n};\n\nexport default kafkaTrigger;",
        "readme.md": "# KafkaTrigger - TypeScript\n\nThe `KafkaTrigger` makes it incredibly easy to react to new events from a Kafka Broker. This sample demonstrates a simple use case of processing data from a given Kafka Broker using TypeScript.\n\n## How it works\n\nFor a `KafkaTrigger` to work, you must provide a topic name which dictates where the messages should be read from with authentication.\n\n## Configuration\n\n### EventHubs for Kafka\n\nAdd `BrokerList` and `KafkaPassword` to your `local.settings.json`\n\n_local.settings.json_\n\n```json\n{\n  \"IsEncrypted\": false,\n  \"Values\": {\n    \"AzureWebJobsStorage\": \"UseDevelopmentStorage=true\",\n    \"FUNCTIONS_WORKER_RUNTIME\": \"node\",\n    \"BrokerList\": \"{YOUR_EVENT_HUBS_NAMESPACE}.servicebus.windows.net:9093\",\n    \"KafkaPassword\": \"{EVENT_HUBS_CONNECTION_STRING}\"\n  }\n}\n```\n\n### Others\n\nModify `function.json` or `KafkaTrigger` attribute according to your broker.",
        "sample.dat": "sample queue data"
      },
      "function": {
        "bindings": [
          {
            "type": "kafkaTrigger",
            "direction": "in",
            "name": "event",
            "brokerList": "BrokerList",
            "topic": "topic",
            "username": "$ConnectionString",
            "password": "%KafkaPassword%",
            "protocol": "saslSsl",
            "authenticationMode": "plain",
            "consumerGroup": "$Default"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "KafkaTrigger",
        "description": "$KafkaTrigger_description",
        "name": "Kafka trigger",
        "language": "TypeScript",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": [
          "brokerList",
          "topic",
          "username",
          "password",
          "protocol",
          "authenticationMode",
          "consumerGroup"
        ]
      }
    },
    {
      "id": "QueueTrigger-CSharp",
      "runtime": "2",
      "files": {
        "readme.md": "# QueueTrigger - C<span>#</span>\r\n\r\nThe `QueueTrigger` makes it incredibly easy to react to new Queues inside of Azure Queue Storage. This sample demonstrates a simple use case of processing data from a given Queue using C#.\r\n\r\n## How it works\r\n\r\nFor a `QueueTrigger` to work, you must provide a queue name that defines the queue messages will be read from.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
        "run.csx": "using System;\r\n\r\npublic static void Run(string myQueueItem, ILogger log)\r\n{\r\n    log.LogInformation($\"C# Queue trigger function processed: {myQueueItem}\");\r\n}\r\n",
        "sample.dat": "sample queue data"
      },
      "function": {
        "bindings": [
          {
            "name": "myQueueItem",
            "type": "queueTrigger",
            "direction": "in",
            "queueName": "myqueue-items",
            "connection": ""
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "QueueTrigger",
        "description": "$QueueTrigger_description",
        "name": "Azure Queue Storage trigger",
        "language": "C#",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "queue",
        "enabledInTryMode": true,
        "userPrompt": [
          "connection",
          "queueName"
        ]
      }
    },
    {
      "id": "QueueTrigger-Custom",
      "runtime": "2",
      "files": {},
      "function": {
        "bindings": [
          {
            "name": "myQueueItem",
            "type": "queueTrigger",
            "direction": "in",
            "queueName": "js-queue-items",
            "connection": ""
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "QueueTrigger",
        "description": "$QueueTrigger_description",
        "name": "Azure Queue Storage trigger",
        "language": "Custom",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "queue",
        "enabledInTryMode": true,
        "userPrompt": [
          "connection",
          "queueName"
        ]
      }
    },
    {
      "id": "QueueTrigger-JavaScript",
      "runtime": "2",
      "files": {
        "index.js": "module.exports = async function (context, myQueueItem) {\r\n    context.log('JavaScript queue trigger function processed work item', myQueueItem);\r\n};",
        "readme.md": "# QueueTrigger - JavaScript\r\n\r\nThe `QueueTrigger` makes it incredibly easy to react to new Queues inside of Azure Queue Storage. This sample demonstrates a simple use case of processing data from a given Queue using C#.\r\n\r\n## How it works\r\n\r\nFor a `QueueTrigger` to work, you provide a path which dictates where the queue messages are located inside your container.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
        "sample.dat": "sample queue data"
      },
      "function": {
        "bindings": [
          {
            "name": "myQueueItem",
            "type": "queueTrigger",
            "direction": "in",
            "queueName": "js-queue-items",
            "connection": ""
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "QueueTrigger",
        "description": "$QueueTrigger_description",
        "name": "Azure Queue Storage trigger",
        "language": "JavaScript",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "queue",
        "enabledInTryMode": true,
        "userPrompt": [
          "connection",
          "queueName"
        ]
      }
    },
    {
      "id": "QueueTrigger-PowerShell",
      "runtime": "2",
      "files": {
        "readme.md": "# QueueTrigger - PowerShell\r\n\r\nThe `QueueTrigger` makes it incredibly easy to react to new Queues inside of [Azure Queue Storage](https://azure.microsoft.com/en-us/services/storage/queues/).\r\nThis sample demonstrates a simple use case of processing data from a given Queue using PowerShell.\r\n\r\n## How it works\r\n\r\nFor a `QueueTrigger` to work, you provide a path which dictates where the queue messages are located inside your container.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation\r\n",
        "run.ps1": "# Input bindings are passed in via param block.\r\nparam($QueueItem, $TriggerMetadata)\r\n\r\n# Write out the queue message and insertion time to the information log.\r\nWrite-Host \"PowerShell queue trigger function processed work item: $QueueItem\"\r\nWrite-Host \"Queue item insertion time: $($TriggerMetadata.InsertionTime)\"\r\n",
        "sample.dat": "sample queue data"
      },
      "function": {
        "bindings": [
          {
            "name": "QueueItem",
            "type": "queueTrigger",
            "direction": "in",
            "queueName": "ps-queue-items",
            "connection": ""
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "QueueTrigger",
        "description": "$QueueTrigger_description",
        "name": "Azure Queue Storage trigger",
        "language": "PowerShell",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "queue",
        "enabledInTryMode": true,
        "userPrompt": [
          "connection",
          "queueName"
        ]
      }
    },
    {
      "id": "QueueTrigger-Python",
      "runtime": "2",
      "files": {
        "readme.md": "# QueueTrigger - Python\r\n\r\nThe `QueueTrigger` makes it incredibly easy to react to new Queues inside of Azure Queue Storage. This sample demonstrates a simple use case of processing data from a given Queue.\r\n\r\n## How it works\r\n\r\nFor a `QueueTrigger` to work, you provide a path which dictates where the queue messages are located inside your container.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation\r\n",
        "sample.dat": "sample queue data",
        "__init__.py": "import logging\r\n\r\nimport azure.functions as func\r\n\r\n\r\ndef main(msg: func.QueueMessage) -> None:\r\n    logging.info('Python queue trigger function processed a queue item: %s',\r\n                 msg.get_body().decode('utf-8'))\r\n"
      },
      "function": {
        "scriptFile": "__init__.py",
        "bindings": [
          {
            "name": "msg",
            "type": "queueTrigger",
            "direction": "in",
            "queueName": "python-queue-items",
            "connection": ""
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "QueueTrigger",
        "description": "$QueueTrigger_description",
        "name": "Azure Queue Storage trigger",
        "language": "Python",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "queue",
        "enabledInTryMode": true,
        "userPrompt": [
          "connection",
          "queueName"
        ],
        "filters": [
          "Python3"
        ]
      }
    },
    {
      "id": "QueueTrigger-Python-Preview",
      "runtime": "2",
      "files": {
        "function_app.py": "import logging\n\nimport azure.functions as func\n\napp = func.FunctionApp()\n\n@app.function_name(name=\"QueueTrigger1\")\n@app.queue_trigger(arg_name=\"msg\", queue_name=\"python-queue-items\",\n                   connection=\"\")  \ndef test_function(msg: func.QueueMessage):\n    logging.info('Python EventHub trigger processed an event: %s',\n                 msg.get_body().decode('utf-8'))",
        "queue_trigger_template.md": "# Azure Functions: Queue Trigger in Python\r\n\r\n## Queue Trigger\r\n\r\nThe queue storage trigger runs a function as messages are added to Azure Queue storage.\r\n\r\n## Using the Template\r\n\r\nFollowing is an example code snippet for Queue Trigger using the [Python programming model V2](https://aka.ms/pythonprogrammingmodel) (currently in Preview).\r\n\r\n```python\r\nimport logging\r\n\r\nimport azure.functions as func\r\n\r\napp = func.FunctionApp()\r\n\r\n@app.function_name(name=\"QueueTrigger1\")\r\n@app.queue_trigger(arg_name=\"msg\", queue_name=\"python-queue-items\",\r\n                   connection=\"\")  \r\ndef test_function(msg: func.QueueMessage):\r\n    logging.info('Python EventHub trigger processed an event: %s',\r\n                 msg.get_body().decode('utf-8'))\r\n```\r\n\r\nTo run the code snippet generated through the command palette, note the following:\r\n\r\n- The function application is defined and named `app`.\r\n- Confirm that the parameters within the trigger reflect values that correspond with your storage account.\r\n- The name of the file must be `function_app.py`.\r\n  \r\nNote that Queue output bindings are also supported in Azure Functions. To learn more, see [Azure Queue storage trigger and bindings for Azure Functions overview](https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-queue?tabs=in-process%2Cextensionv5%2Cextensionv3&pivots=programming-language-python)\r\n\r\n## Programming Model V2 (Preview)\r\n\r\nThe new programming model in Azure Functions Python delivers an experience that aligns with Python development principles, and subsequently with commonly used Python frameworks. \r\n\r\nThe improved programming model requires fewer files than the default model, and specifically eliminates the need for a configuration file (`function.json`). Instead, triggers and bindings are represented in the `function_app.py` file as decorators. Moreover, functions can be logically organized with support for multiple functions to be stored in the same file. Functions within the same function application can also be stored in different files, and be referenced as blueprints.\r\n\r\nTo learn more about using the new Python programming model for Azure Functions, see the [Azure Functions Python developer guide](https://aka.ms/pythondeveloperguide). Note that in addition to the documentation, [hints](https://aka.ms/functions-python-hints) are available in code editors that support type checking with PYI files.\r\n\r\nTo learn more about the new programming model for Azure Functions in Python, see [Programming Models in Azure Functions](https://aka.ms/functions-programming-models)."
      },
      "metadata": {
        "defaultFunctionName": "QueueTrigger",
        "description": "$QueueTrigger_description",
        "name": "Azure Queue Storage trigger",
        "language": "Python",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "queue",
        "enabledInTryMode": true,
        "userPrompt": [
          "connection",
          "queueName"
        ],
        "filters": [
          "Python3"
        ]
      }
    },
    {
      "id": "QueueTrigger-Python-Preview-Append",
      "runtime": "2",
      "files": {
        "function_app.py": "@app.function_name(name=\"QueueTrigger1\")\n@app.queue_trigger(arg_name=\"msg\", queue_name=\"python-queue-items\",\n                   connection=\"\")  \ndef test_function(msg: func.QueueMessage):\n    logging.info('Python EventHub trigger processed an event: %s',\n                 msg.get_body().decode('utf-8'))",
        "queue_trigger_template.md": "# Azure Functions: Queue Trigger in Python\r\n\r\n## Queue Trigger\r\n\r\nThe queue storage trigger runs a function as messages are added to Azure Queue storage.\r\n\r\n## Using the Template\r\n\r\nFollowing is an example code snippet for Queue Trigger using the [Python programming model V2](https://aka.ms/pythonprogrammingmodel) (currently in Preview).\r\n\r\n```python\r\nimport logging\r\n\r\nimport azure.functions as func\r\n\r\napp = func.FunctionApp()\r\n\r\n@app.function_name(name=\"QueueTrigger1\")\r\n@app.queue_trigger(arg_name=\"msg\", queue_name=\"python-queue-items\",\r\n                   connection=\"\")  \r\ndef test_function(msg: func.QueueMessage):\r\n    logging.info('Python EventHub trigger processed an event: %s',\r\n                 msg.get_body().decode('utf-8'))\r\n```\r\n\r\nTo run the code snippet generated through the command palette, note the following:\r\n\r\n- The function application is defined and named `app`.\r\n- Confirm that the parameters within the trigger reflect values that correspond with your storage account.\r\n- The name of the file must be `function_app.py`.\r\n  \r\nNote that Queue output bindings are also supported in Azure Functions. To learn more, see [Azure Queue storage trigger and bindings for Azure Functions overview](https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-queue?tabs=in-process%2Cextensionv5%2Cextensionv3&pivots=programming-language-python)\r\n\r\n## Programming Model V2 (Preview)\r\n\r\nThe new programming model in Azure Functions Python delivers an experience that aligns with Python development principles, and subsequently with commonly used Python frameworks. \r\n\r\nThe improved programming model requires fewer files than the default model, and specifically eliminates the need for a configuration file (`function.json`). Instead, triggers and bindings are represented in the `function_app.py` file as decorators. Moreover, functions can be logically organized with support for multiple functions to be stored in the same file. Functions within the same function application can also be stored in different files, and be referenced as blueprints.\r\n\r\nTo learn more about using the new Python programming model for Azure Functions, see the [Azure Functions Python developer guide](https://aka.ms/pythondeveloperguide). Note that in addition to the documentation, [hints](https://aka.ms/functions-python-hints) are available in code editors that support type checking with PYI files.\r\n\r\nTo learn more about the new programming model for Azure Functions in Python, see [Programming Models in Azure Functions](https://aka.ms/functions-programming-models)."
      },
      "metadata": {
        "defaultFunctionName": "QueueTrigger",
        "description": "$QueueTrigger_description",
        "name": "Azure Queue Storage trigger",
        "language": "Python",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "queue",
        "enabledInTryMode": true,
        "userPrompt": [
          "connection",
          "queueName"
        ],
        "filters": [
          "Python3"
        ]
      }
    },
    {
      "id": "QueueTrigger-TypeScript",
      "runtime": "2",
      "files": {
        "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\r\n\r\nconst queueTrigger: AzureFunction = async function (context: Context, myQueueItem: string): Promise<void> {\r\n    context.log('Queue trigger function processed work item', myQueueItem);\r\n};\r\n\r\nexport default queueTrigger;\r\n",
        "readme.md": "# QueueTrigger - TypeScript\r\n\r\nThe `QueueTrigger` makes it incredibly easy to react to new Queues inside of Azure Queue Storage. This sample demonstrates a simple use case of processing data from a given Queue using C#.\r\n\r\n## How it works\r\n\r\nFor a `QueueTrigger` to work, you provide a path which dictates where the queue messages are located inside your container.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
        "sample.dat": "sample queue data"
      },
      "function": {
        "bindings": [
          {
            "name": "myQueueItem",
            "type": "queueTrigger",
            "direction": "in",
            "queueName": "js-queue-items",
            "connection": ""
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "QueueTrigger",
        "description": "$QueueTrigger_description",
        "name": "Azure Queue Storage trigger",
        "language": "TypeScript",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "queue",
        "enabledInTryMode": true,
        "userPrompt": [
          "connection",
          "queueName"
        ]
      }
    },
    {
      "id": "RabbitMQTrigger-CSharp",
      "runtime": "2",
      "files": {
        "readme.md": "# RabbitMQTrigger - C<span>#</span>\n\nThe `RabbitMQTrigger` makes it incredibly easy to react to new events from a RabbitMQ queue. This sample demonstrates a simple use case of processing data from a given RabbitMQ Queue using C#.\n\n## How it works\n\nFor a `RabbitMQTrigger` to work, you must provide a queue name which dictates where the queue messages should be read from.",
        "run.csx": "using System;\n\npublic static void Run(string myQueueItem, ILogger log)\n{\n    log.LogInformation($\"C# Queue trigger function processed: {myQueueItem}\");\n}\n",
        "sample.dat": "sample queue data"
      },
      "function": {
        "bindings": [
          {
            "name": "myQueueItem",
            "type": "rabbitMQTrigger",
            "direction": "in",
            "queueName": "",
            "connectionStringSetting": ""
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "RabbitMQTrigger",
        "description": "$RabbitMQTrigger_description",
        "name": "RabbitMQ trigger",
        "language": "C#",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "RabbitMQ",
        "enabledInTryMode": true,
        "userPrompt": [
          "connectionStringSetting",
          "queueName"
        ]
      }
    },
    {
      "id": "RabbitMQTrigger-Custom",
      "runtime": "2",
      "files": {},
      "function": {
        "bindings": [
          {
            "name": "myQueueItem",
            "type": "rabbitMqTrigger",
            "direction": "in",
            "queueName": "",
            "connectionStringSetting": ""
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "RabbitMQTrigger",
        "description": "$RabbitMQTrigger_description",
        "name": "RabbitMQ trigger",
        "language": "Custom",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "RabbitMQ",
        "enabledInTryMode": true,
        "userPrompt": [
          "connectionStringSetting",
          "queueName"
        ]
      }
    },
    {
      "id": "RabbitMQTrigger-JavaScript",
      "runtime": "2",
      "files": {
        "index.js": "module.exports = async function (context, myQueueItem) {\n    context.log('JavaScript rabbitmq trigger function processed work item', myQueueItem);\n};",
        "readme.md": "# RabbitMQTrigger - C<span>#</span>\n\nThe `RabbitMQTrigger` makes it incredibly easy to react to new events from a RabbitMQ queue. This sample demonstrates a simple use case of processing data from a given RabbitMQ Queue using C#.\n\n## How it works\n\nFor a `RabbitMQTrigger` to work, you must provide a queue name which dictates where the queue messages should be read from.",
        "sample.dat": "sample queue data"
      },
      "function": {
        "bindings": [
          {
            "name": "myQueueItem",
            "type": "rabbitMqTrigger",
            "direction": "in",
            "queueName": "",
            "connectionStringSetting": ""
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "RabbitMQTrigger",
        "description": "$RabbitMQTrigger_description",
        "name": "RabbitMQ trigger",
        "language": "JavaScript",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "RabbitMQ",
        "enabledInTryMode": true,
        "userPrompt": [
          "connectionStringSetting",
          "queueName"
        ]
      }
    },
    {
      "id": "RabbitMQTrigger-PowerShell",
      "runtime": "2",
      "files": {
        "readme.md": "# RabbitMQTrigger - C<span>#</span>\n\nThe `RabbitMQTrigger` makes it incredibly easy to react to new events from a RabbitMQ queue. This sample demonstrates a simple use case of processing data from a given RabbitMQ Queue using C#.\n\n## How it works\n\nFor a `RabbitMQTrigger` to work, you must provide a queue name which dictates where the queue messages should be read from.",
        "run.ps1": "# Input bindings are passed in via param block.\nparam([string] $MyQueueItem, $TriggerMetadata)\n\n# Write out the queue message and insertion time to the information log.\nWrite-Host \"PowerShell rabbitmq trigger function processed work item: $MyQueueItem\"\nWrite-Host \"Queue item insertion time: $($TriggerMetadata.InsertionTime)\"\n",
        "sample.dat": "sample queue data"
      },
      "function": {
        "bindings": [
          {
            "name": "myQueueItem",
            "type": "rabbitMqTrigger",
            "direction": "in",
            "queueName": "",
            "connectionStringSetting": ""
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "RabbitMQTrigger",
        "description": "$RabbitMQTrigger_description",
        "name": "RabbitMQ trigger",
        "language": "Powershell",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "RabbitMQ",
        "enabledInTryMode": true,
        "userPrompt": [
          "connectionStringSetting",
          "queueName"
        ]
      }
    },
    {
      "id": "RabbitMQTrigger-Python",
      "runtime": "2",
      "files": {
        "readme.md": "# RabbitMQTrigger - C<span>#</span>\n\nThe `RabbitMQTrigger` makes it incredibly easy to react to new events from a RabbitMQ queue. This sample demonstrates a simple use case of processing data from a given RabbitMQ Queue using C#.\n\n## How it works\n\nFor a `RabbitMQTrigger` to work, you must provide a queue name which dictates where the queue messages should be read from.",
        "sample.dat": "sample queue data",
        "__init__.py": "import logging\n\nimport azure.functions as func\n\n\ndef main(myQueueItem) -> None:\n    logging.info('Python rabbitmq trigger function processed a queue item: %s', myQueueItem)\n"
      },
      "function": {
        "scriptFile": "__init__.py",
        "bindings": [
          {
            "name": "myQueueItem",
            "type": "rabbitMqTrigger",
            "direction": "in",
            "queueName": "",
            "connectionStringSetting": ""
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "RabbitMQTrigger",
        "description": "$RabbitMQTrigger_description",
        "name": "RabbitMQ trigger",
        "language": "Python",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "RabbitMQ",
        "enabledInTryMode": true,
        "userPrompt": [
          "connectionStringSetting",
          "queueName"
        ]
      }
    },
    {
      "id": "RabbitMQTrigger-TypeScript",
      "runtime": "2",
      "files": {
        "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\n\nconst rabbitmqTrigger: AzureFunction = async function (context: Context, myQueueItem: string): Promise<void> {\n    context.log('RabbitMQ trigger function processed work item', myQueueItem);\n};\n\nexport default rabbitmqTrigger;\n",
        "readme.md": "# RabbitMQTrigger - C<span>#</span>\n\nThe `RabbitMQTrigger` makes it incredibly easy to react to new events from a RabbitMQ queue. This sample demonstrates a simple use case of processing data from a given RabbitMQ Queue using C#.\n\n## How it works\n\nFor a `RabbitMQTrigger` to work, you must provide a queue name which dictates where the queue messages should be read from.",
        "sample.dat": "sample queue data"
      },
      "function": {
        "bindings": [
          {
            "name": "myQueueItem",
            "type": "rabbitMqTrigger",
            "direction": "in",
            "queueName": "",
            "connectionStringSetting": ""
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "RabbitMQTrigger",
        "description": "$RabbitMQTrigger_description",
        "name": "RabbitMQ trigger",
        "language": "TypeScript",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "RabbitMQ",
        "enabledInTryMode": true,
        "userPrompt": [
          "connectionStringSetting",
          "queueName"
        ]
      }
    },
    {
      "id": "SendGrid-CSharp",
      "runtime": "2",
      "files": {
        "run.csx": "// The 'From' and 'To' fields are automatically populated with the values specified by the binding settings.\r\n//\r\n// You can also optionally configure the default From/To addresses globally via host.config, e.g.:\r\n//\r\n// {\r\n//   \"sendGrid\": {\r\n//      \"to\": \"user@host.com\",\r\n//      \"from\": \"Azure Functions <samples@functions.com>\"\r\n//   }\r\n// }\r\n#r \"SendGrid\"\r\n\r\nusing System;\r\nusing SendGrid.Helpers.Mail;\r\nusing Microsoft.Azure.WebJobs.Host;\r\n\r\npublic static SendGridMessage Run(Order order, ILogger log)\r\n{\r\n    log.LogInformation($\"C# Queue trigger function processed order: {order.OrderId}\");\r\n\r\n    SendGridMessage message = new SendGridMessage()\r\n    {\r\n        Subject = $\"Thanks for your order (#{order.OrderId})!\"\r\n    };\r\n\r\n    message.AddContent(\"text/plain\", $\"{order.CustomerName}, your order ({order.OrderId}) is being processed!\");\r\n    return message;\r\n}\r\npublic class Order\r\n{\r\n    public string OrderId { get; set; }\r\n    public string CustomerName { get; set; }\r\n    public string CustomerEmail { get; set; }\r\n}\r\n",
        "sample.dat": "{ \"OrderId\": 12345, \"CustomerName\": \"Joe Schmoe\", \"CustomerEmail\": \"joeschmoe@foo.com\" }"
      },
      "function": {
        "bindings": [
          {
            "type": "queueTrigger",
            "name": "order",
            "direction": "in",
            "queueName": "samples-orders"
          },
          {
            "type": "sendGrid",
            "name": "$return",
            "direction": "out",
            "apiKey": "SendGridApiKey",
            "from": "Azure Functions <samples@functions.com>",
            "to": "{CustomerEmail}"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "SendGrid",
        "description": "$SendGrid_description",
        "name": "SendGrid",
        "language": "C#",
        "category": [
          "$temp_category_samples",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": [
          "to",
          "from",
          "apiKey"
        ]
      }
    },
    {
      "id": "SendGrid-Custom",
      "runtime": "2",
      "files": {},
      "function": {
        "bindings": [
          {
            "type": "queueTrigger",
            "name": "order",
            "direction": "in",
            "queueName": "samples-orders"
          },
          {
            "type": "sendGrid",
            "name": "message",
            "direction": "out",
            "apiKey": "SendGridApiKey",
            "from": "Azure Functions <samples@functions.com>",
            "to": "{customerEmail}",
            "subject": "",
            "text": ""
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "SendGrid",
        "description": "$SendGrid_description",
        "name": "SendGrid",
        "language": "Custom",
        "category": [
          "$temp_category_samples",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": [
          "to",
          "from",
          "subject",
          "text",
          "apiKey"
        ]
      }
    },
    {
      "id": "SendGrid-JavaScript",
      "runtime": "2",
      "files": {
        "index.js": "var util = require('util');\r\n\r\n// The 'From' and 'To' fields are automatically populated with the values specified by the binding settings.\r\n//\r\n// You can also optionally configure the default From/To addresses globally via host.config, e.g.:\r\n//\r\n// {\r\n//   \"sendGrid\": {\r\n//      \"to\": \"user@host.com\",\r\n//      \"from\": \"Azure Functions <samples@functions.com>\"\r\n//   }\r\n// }\r\nmodule.exports = async function (context, order) {\r\n    context.log('JavaScript queue trigger function processed order', order.orderId);\r\n\r\n    context.bindings.message = {\r\n        subject: util.format('Thanks for your order (#%d)!', order.orderId),\r\n        content: [{\r\n            type: 'text/plain',\r\n            value: util.format(\"%s, your order (%d) is being processed!\", order.customerName, order.orderId)\r\n        }]\r\n    };\r\n}",
        "sample.dat": "{ \"orderId\": 12345, \"customerName\": \"Joe Schmoe\", \"customerEmail\": \"joeschmoe@foo.com\" }"
      },
      "function": {
        "bindings": [
          {
            "type": "queueTrigger",
            "name": "order",
            "direction": "in",
            "queueName": "samples-orders"
          },
          {
            "type": "sendGrid",
            "name": "message",
            "direction": "out",
            "apiKey": "SendGridApiKey",
            "from": "Azure Functions <samples@functions.com>",
            "to": "{customerEmail}",
            "subject": "",
            "text": ""
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "SendGrid",
        "description": "$SendGrid_description",
        "name": "SendGrid",
        "language": "JavaScript",
        "category": [
          "$temp_category_samples",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": [
          "to",
          "from",
          "subject",
          "text",
          "apiKey"
        ]
      }
    },
    {
      "id": "SendGrid-PowerShell",
      "runtime": "2",
      "files": {
        "run.ps1": "# The 'From' and 'To' fields are automatically populated with the values specified by the binding settings.\r\n#\r\n# You can also optionally configure the default From/To addresses globally via host.config, e.g.:\r\n#\r\n# {\r\n#   \"sendGrid\": {\r\n#      \"to\": \"user@host.com\",\r\n#      \"from\": \"Azure Functions <samples@functions.com>\"\r\n#   }\r\n# }\r\nparam($order, $TriggerMetadata)\r\n\r\nWrite-Host \"JavaScript queue trigger function processed order: $($order.orderId)\"\r\n\r\nPush-OutputBinding -Name Response -Value (@{\r\n    subject = \"Thanks for your order (#$($order.orderId))!\"\r\n    content = @(@{\r\n        type = 'text/plain'\r\n        value = \"$($order.customerName), your order ($($order.orderId)) is being processed!\"\r\n    })\r\n})\r\n",
        "sample.dat": "{ \"orderId\": 12345, \"customerName\": \"Joe Schmoe\", \"customerEmail\": \"joeschmoe@foo.com\" }"
      },
      "function": {
        "bindings": [
          {
            "type": "queueTrigger",
            "name": "order",
            "direction": "in",
            "queueName": "samples-orders"
          },
          {
            "type": "sendGrid",
            "name": "message",
            "direction": "out",
            "apiKey": "SendGridApiKey",
            "from": "Azure Functions <samples@functions.com>",
            "to": "{customerEmail}",
            "subject": "",
            "text": ""
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "SendGrid",
        "description": "$SendGrid_description",
        "name": "SendGrid",
        "language": "PowerShell",
        "category": [
          "$temp_category_samples",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": [
          "to",
          "from",
          "subject",
          "text",
          "apiKey"
        ]
      }
    },
    {
      "id": "SendGrid-TypeScript",
      "runtime": "2",
      "files": {
        "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\r\n\r\n// The 'From' and 'To' fields are automatically populated with the values specified by the binding settings.\r\n//\r\n// You can also optionally configure the default From/To addresses globally via host.config, e.g.:\r\n//\r\n// {\r\n//   \"sendGrid\": {\r\n//      \"to\": \"user@host.com\",\r\n//      \"from\": \"Azure Functions <samples@functions.com>\"\r\n//   }\r\n// }\r\n\r\nconst sendGrid: AzureFunction =  async function (context: Context, order: any): Promise<void> {\r\n    context.log('Queue trigger function processed order', order.orderId);\r\n\r\n    context.bindings.message = {\r\n        subject: `Thanks for your order (#${order.orderId})!`,\r\n        content: [{\r\n            type: 'text/plain',\r\n            value: `${order.customerName}, your order (${order.orderId}) is being processed!`\r\n        }]\r\n    };\r\n}\r\n\r\nexport default sendGrid;\r\n",
        "sample.dat": "{ \"orderId\": 12345, \"customerName\": \"Joe Schmoe\", \"customerEmail\": \"joeschmoe@foo.com\" }"
      },
      "function": {
        "bindings": [
          {
            "type": "queueTrigger",
            "name": "order",
            "direction": "in",
            "queueName": "samples-orders"
          },
          {
            "type": "sendGrid",
            "name": "message",
            "direction": "out",
            "apiKey": "SendGridApiKey",
            "from": "Azure Functions <samples@functions.com>",
            "to": "{customerEmail}",
            "subject": "",
            "text": ""
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "SendGrid",
        "description": "$SendGrid_description",
        "name": "SendGrid",
        "language": "TypeScript",
        "category": [
          "$temp_category_samples",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": [
          "to",
          "from",
          "subject",
          "text",
          "apiKey"
        ]
      }
    },
    {
      "id": "ServiceBusQueueTrigger-CSharp",
      "runtime": "2",
      "files": {
        "run.csx": "using System;\r\nusing System.Threading.Tasks;\r\n\r\npublic static void Run(string myQueueItem, ILogger log)\r\n{\r\n    log.LogInformation($\"C# ServiceBus queue trigger function processed message: {myQueueItem}\");\r\n}\r\n",
        "sample.dat": "Service Bus Message"
      },
      "function": {
        "bindings": [
          {
            "name": "myQueueItem",
            "type": "serviceBusTrigger",
            "direction": "in",
            "queueName": "myqueue",
            "connection": ""
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "ServiceBusQueueTrigger",
        "description": "$ServiceBusQueueTrigger_description",
        "name": "Azure Service Bus Queue trigger",
        "language": "C#",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "serviceBus",
        "enabledInTryMode": false,
        "userPrompt": [
          "connection",
          "queueName"
        ]
      }
    },
    {
      "id": "ServiceBusQueueTrigger-Custom",
      "runtime": "2",
      "files": {},
      "function": {
        "bindings": [
          {
            "name": "mySbMsg",
            "type": "serviceBusTrigger",
            "direction": "in",
            "queueName": "myinputqueue",
            "connection": ""
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "ServiceBusQueueTrigger",
        "description": "$ServiceBusQueueTrigger_description",
        "name": "Azure Service Bus Queue trigger",
        "language": "Custom",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "serviceBus",
        "enabledInTryMode": false,
        "userPrompt": [
          "connection",
          "queueName"
        ]
      }
    },
    {
      "id": "ServiceBusQueueTrigger-JavaScript",
      "runtime": "2",
      "files": {
        "index.js": "module.exports = async function(context, mySbMsg) {\r\n    context.log('JavaScript ServiceBus queue trigger function processed message', mySbMsg);\r\n};",
        "sample.dat": "Service Bus Message"
      },
      "function": {
        "bindings": [
          {
            "name": "mySbMsg",
            "type": "serviceBusTrigger",
            "direction": "in",
            "queueName": "myinputqueue",
            "connection": ""
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "ServiceBusQueueTrigger",
        "description": "$ServiceBusQueueTrigger_description",
        "name": "Azure Service Bus Queue trigger",
        "language": "JavaScript",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "serviceBus",
        "enabledInTryMode": false,
        "userPrompt": [
          "connection",
          "queueName"
        ]
      }
    },
    {
      "id": "ServiceBusQueueTrigger-PowerShell",
      "runtime": "2",
      "files": {
        "run.ps1": "param([string] $mySbMsg, $TriggerMetadata)\r\n\r\nWrite-Host \"PowerShell ServiceBus queue trigger function processed message: $mySbMsg\"\r\n",
        "sample.dat": "Service Bus Message"
      },
      "function": {
        "bindings": [
          {
            "name": "mySbMsg",
            "type": "serviceBusTrigger",
            "direction": "in",
            "queueName": "myinputqueue",
            "connection": ""
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "ServiceBusQueueTrigger",
        "description": "$ServiceBusQueueTrigger_description",
        "name": "Azure Service Bus Queue trigger",
        "language": "PowerShell",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "serviceBus",
        "enabledInTryMode": false,
        "userPrompt": [
          "connection",
          "queueName"
        ]
      }
    },
    {
      "id": "ServiceBusQueueTrigger-Python",
      "runtime": "2",
      "files": {
        "sample.dat": "Service Bus Message",
        "__init__.py": "import logging\r\n\r\nimport azure.functions as func\r\n\r\n\r\ndef main(msg: func.ServiceBusMessage):\r\n    logging.info('Python ServiceBus queue trigger processed message: %s',\r\n                 msg.get_body().decode('utf-8'))\r\n"
      },
      "function": {
        "scriptFile": "__init__.py",
        "bindings": [
          {
            "name": "msg",
            "type": "serviceBusTrigger",
            "direction": "in",
            "queueName": "myinputqueue",
            "connection": ""
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "ServiceBusQueueTrigger",
        "description": "$ServiceBusQueueTrigger_description",
        "name": "Azure Service Bus Queue trigger",
        "language": "Python",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "serviceBus",
        "enabledInTryMode": false,
        "userPrompt": [
          "connection",
          "queueName"
        ]
      }
    },
    {
      "id": "ServiceBusQueueTrigger-Python-Preview",
      "runtime": "2",
      "files": {
        "function_app.py": "import logging\n\nimport azure.functions as func\n\napp = func.FunctionApp()\n\n@app.function_name(name=\"ServiceBusQueueTrigger1\")\n@app.service_bus_queue_trigger(arg_name=\"msg\", queue_name=\"myinputqueue\", connection=\"\")\ndef test_function(msg: func.ServiceBusMessage):\n    logging.info('Python ServiceBus queue trigger processed message: %s',\n                 msg.get_body().decode('utf-8'))",
        "servicebus_queue_trigger_template.md": "# Azure Functions: Service Bus Queue Trigger in Python\r\n\r\n## Service Bus Queue Trigger\r\n\r\nUse the Service Bus Queue trigger to respond to messages from a Service Bus queue. Starting with extension version 3.1.0, you can trigger on a session-enabled queue.\r\n\r\n## Using the Template\r\n\r\nFollowing is an example code snippet for Service Bus Queue Trigger using the [Python programming model V2](https://aka.ms/pythonprogrammingmodel) (currently in Preview).\r\n\r\n```python\r\nimport logging\r\n\r\nimport azure.functions as func\r\n\r\napp = func.FunctionApp()\r\n\r\n@app.function_name(name=\"ServiceBusQueueTrigger1\")\r\n@app.service_bus_queue_trigger(arg_name=\"msg\", queue_name=\"myinputqueue\", connection=\"\")\r\ndef test_function(msg: func.ServiceBusMessage):\r\n    logging.info('Python ServiceBus queue trigger processed message: %s',\r\n                 msg.get_body().decode('utf-8'))\r\n```\r\n\r\nTo run the code snippet generated through the command palette, note the following:\r\n\r\n- The function application is defined and named `app`.\r\n- Confirm that the parameters within the trigger reflect values that correspond with your storage account.\r\n- The name of the file must be `function_app.py`.\r\n  \r\nNote that Service Bus output bindings are also supported in Azure Functions. To learn more, see [Azure Service Bus bindings for Azure Functions](https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-service-bus?tabs=in-process%2Cextensionv5%2Cextensionv3&pivots=programming-language-python)\r\n\r\n## Programming Model V2 (Preview)\r\n\r\nThe new programming model in Azure Functions Python delivers an experience that aligns with Python development principles, and subsequently with commonly used Python frameworks. \r\n\r\nThe improved programming model requires fewer files than the default model, and specifically eliminates the need for a configuration file (`function.json`). Instead, triggers and bindings are represented in the `function_app.py` file as decorators. Moreover, functions can be logically organized with support for multiple functions to be stored in the same file. Functions within the same function application can also be stored in different files, and be referenced as blueprints.\r\n\r\nTo learn more about using the new Python programming model for Azure Functions, see the [Azure Functions Python developer guide](https://aka.ms/pythondeveloperguide). Note that in addition to the documentation, [hints](https://aka.ms/functions-python-hints) are available in code editors that support type checking with PYI files.\r\n\r\nTo learn more about the new programming model for Azure Functions in Python, see [Programming Models in Azure Functions](https://aka.ms/functions-programming-models)."
      },
      "metadata": {
        "defaultFunctionName": "ServiceBusQueueTrigger",
        "description": "$ServiceBusQueueTrigger_description",
        "name": "Azure Service Bus Queue trigger",
        "language": "Python",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "serviceBus",
        "enabledInTryMode": false,
        "userPrompt": [
          "connection",
          "queueName"
        ]
      }
    },
    {
      "id": "ServiceBusQueueTrigger-Python-Preview-Append",
      "runtime": "2",
      "files": {
        "function_app.py": "@app.function_name(name=\"ServiceBusQueueTrigger1\")\n@app.service_bus_queue_trigger(arg_name=\"msg\", queue_name=\"myinputqueue\", connection=\"\")\ndef test_function(msg: func.ServiceBusMessage):\n    logging.info('Python ServiceBus queue trigger processed message: %s',\n                 msg.get_body().decode('utf-8'))",
        "servicebus_queue_trigger_template.md": "# Azure Functions: Service Bus Queue Trigger in Python\r\n\r\n## Service Bus Queue Trigger\r\n\r\nUse the Service Bus Queue trigger to respond to messages from a Service Bus queue. Starting with extension version 3.1.0, you can trigger on a session-enabled queue.\r\n\r\n## Using the Template\r\n\r\nFollowing is an example code snippet for Service Bus Queue Trigger using the [Python programming model V2](https://aka.ms/pythonprogrammingmodel) (currently in Preview).\r\n\r\n```python\r\nimport logging\r\n\r\nimport azure.functions as func\r\n\r\napp = func.FunctionApp()\r\n\r\n@app.function_name(name=\"ServiceBusQueueTrigger1\")\r\n@app.service_bus_queue_trigger(arg_name=\"msg\", queue_name=\"myinputqueue\", connection=\"\")\r\ndef test_function(msg: func.ServiceBusMessage):\r\n    logging.info('Python ServiceBus queue trigger processed message: %s',\r\n                 msg.get_body().decode('utf-8'))\r\n```\r\n\r\nTo run the code snippet generated through the command palette, note the following:\r\n\r\n- The function application is defined and named `app`.\r\n- Confirm that the parameters within the trigger reflect values that correspond with your storage account.\r\n- The name of the file must be `function_app.py`.\r\n  \r\nNote that Service Bus output bindings are also supported in Azure Functions. To learn more, see [Azure Service Bus bindings for Azure Functions](https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-service-bus?tabs=in-process%2Cextensionv5%2Cextensionv3&pivots=programming-language-python)\r\n\r\n## Programming Model V2 (Preview)\r\n\r\nThe new programming model in Azure Functions Python delivers an experience that aligns with Python development principles, and subsequently with commonly used Python frameworks. \r\n\r\nThe improved programming model requires fewer files than the default model, and specifically eliminates the need for a configuration file (`function.json`). Instead, triggers and bindings are represented in the `function_app.py` file as decorators. Moreover, functions can be logically organized with support for multiple functions to be stored in the same file. Functions within the same function application can also be stored in different files, and be referenced as blueprints.\r\n\r\nTo learn more about using the new Python programming model for Azure Functions, see the [Azure Functions Python developer guide](https://aka.ms/pythondeveloperguide). Note that in addition to the documentation, [hints](https://aka.ms/functions-python-hints) are available in code editors that support type checking with PYI files.\r\n\r\nTo learn more about the new programming model for Azure Functions in Python, see [Programming Models in Azure Functions](https://aka.ms/functions-programming-models)."
      },
      "metadata": {
        "defaultFunctionName": "ServiceBusQueueTrigger",
        "description": "$ServiceBusQueueTrigger_description",
        "name": "Azure Service Bus Queue trigger",
        "language": "Python",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "serviceBus",
        "enabledInTryMode": false,
        "userPrompt": [
          "connection",
          "queueName"
        ]
      }
    },
    {
      "id": "ServiceBusQueueTrigger-TypeScript",
      "runtime": "2",
      "files": {
        "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\r\n\r\nconst serviceBusQueueTrigger: AzureFunction = async function(context: Context, mySbMsg: any): Promise<void> {\r\n    context.log('ServiceBus queue trigger function processed message', mySbMsg);\r\n};\r\n\r\nexport default serviceBusQueueTrigger;\r\n",
        "sample.dat": "Service Bus Message"
      },
      "function": {
        "bindings": [
          {
            "name": "mySbMsg",
            "type": "serviceBusTrigger",
            "direction": "in",
            "queueName": "myinputqueue",
            "connection": ""
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "ServiceBusQueueTrigger",
        "description": "$ServiceBusQueueTrigger_description",
        "name": "Azure Service Bus Queue trigger",
        "language": "TypeScript",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "serviceBus",
        "enabledInTryMode": false,
        "userPrompt": [
          "connection",
          "queueName"
        ]
      }
    },
    {
      "id": "ServiceBusTopicTrigger-CSharp",
      "runtime": "2",
      "files": {
        "run.csx": "using System;\r\nusing System.Threading.Tasks;\r\n\r\npublic static void Run(string mySbMsg, ILogger log)\r\n{\r\n    log.LogInformation($\"C# ServiceBus topic trigger function processed message: {mySbMsg}\");\r\n}\r\n",
        "sample.dat": "Service Bus Message"
      },
      "function": {
        "bindings": [
          {
            "name": "mySbMsg",
            "type": "serviceBusTrigger",
            "direction": "in",
            "topicName": "mytopic",
            "subscriptionName": "mysubscription",
            "connection": ""
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "ServiceBusTopicTrigger",
        "description": "$ServiceBusTopicTrigger_description",
        "name": "Azure Service Bus Topic trigger",
        "language": "C#",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "serviceBus",
        "enabledInTryMode": false,
        "userPrompt": [
          "connection",
          "topicName",
          "subscriptionName"
        ]
      }
    },
    {
      "id": "ServiceBusTopicTrigger-Custom",
      "runtime": "2",
      "files": {},
      "function": {
        "bindings": [
          {
            "name": "mySbMsg",
            "type": "serviceBusTrigger",
            "direction": "in",
            "topicName": "mytopic",
            "subscriptionName": "mysubscription",
            "connection": ""
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "ServiceBusTopicTrigger",
        "description": "$ServiceBusTopicTrigger_description",
        "name": "Azure Service Bus Topic trigger",
        "language": "Custom",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "serviceBus",
        "enabledInTryMode": false,
        "userPrompt": [
          "connection",
          "topicName",
          "subscriptionName"
        ]
      }
    },
    {
      "id": "ServiceBusTopicTrigger-JavaScript",
      "runtime": "2",
      "files": {
        "index.js": "module.exports = async function(context, mySbMsg) {\r\n    context.log('JavaScript ServiceBus topic trigger function processed message', mySbMsg);\r\n};",
        "sample.dat": "Service Bus Message"
      },
      "function": {
        "bindings": [
          {
            "name": "mySbMsg",
            "type": "serviceBusTrigger",
            "direction": "in",
            "topicName": "mytopic",
            "subscriptionName": "mysubscription",
            "connection": ""
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "ServiceBusTopicTrigger",
        "description": "$ServiceBusTopicTrigger_description",
        "name": "Azure Service Bus Topic trigger",
        "language": "JavaScript",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "serviceBus",
        "enabledInTryMode": false,
        "userPrompt": [
          "connection",
          "topicName",
          "subscriptionName"
        ]
      }
    },
    {
      "id": "ServiceBusTopicTrigger-PowerShell",
      "runtime": "2",
      "files": {
        "run.ps1": "param([string] $mySbMsg, $TriggerMetadata)\r\n\r\nWrite-Host \"PowerShell ServiceBus topic trigger function processed message: $mySbMsg\"\r\n",
        "sample.dat": "Service Bus Message"
      },
      "function": {
        "bindings": [
          {
            "name": "mySbMsg",
            "type": "serviceBusTrigger",
            "direction": "in",
            "topicName": "mytopic",
            "subscriptionName": "mysubscription",
            "connection": ""
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "ServiceBusTopicTrigger",
        "description": "$ServiceBusTopicTrigger_description",
        "name": "Azure Service Bus Topic trigger",
        "language": "PowerShell",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "serviceBus",
        "enabledInTryMode": false,
        "userPrompt": [
          "connection",
          "topicName",
          "subscriptionName"
        ]
      }
    },
    {
      "id": "ServiceBusTopicTrigger-Python",
      "runtime": "2",
      "files": {
        "README.md": "# Python ServiceBusTopicTrigger\n",
        "sample.dat": "Service Bus Message",
        "__init__.py": "import logging\r\n\r\nimport azure.functions as func\r\n\r\n\r\ndef main(message: func.ServiceBusMessage):\r\n    # Log the Service Bus Message as plaintext\r\n\r\n    message_content_type = message.content_type\r\n    message_body = message.get_body().decode(\"utf-8\")\r\n\r\n    logging.info(\"Python ServiceBus topic trigger processed message.\")\r\n    logging.info(\"Message Content Type: \" + message_content_type)\r\n    logging.info(\"Message Body: \" + message_body)\r\n"
      },
      "function": {
        "scriptFile": "__init__.py",
        "entryPoint": "main",
        "bindings": [
          {
            "name": "message",
            "type": "serviceBusTrigger",
            "direction": "in",
            "topicName": "mytopic",
            "subscriptionName": "mysubscription",
            "connection": ""
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "ServiceBusTopicTrigger",
        "description": "$ServiceBusTopicTrigger_description",
        "name": "Azure Service Bus Topic trigger",
        "language": "Python",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "serviceBus",
        "enabledInTryMode": false,
        "userPrompt": [
          "connection",
          "topicName",
          "subscriptionName"
        ]
      }
    },
    {
      "id": "ServiceBusTopicTrigger-Python-Preview",
      "runtime": "2",
      "files": {
        "function_app.py": "import logging\n\nimport azure.functions as func\n\napp = func.FunctionApp()\n\n@app.function_name(name=\"ServiceBusTopicTrigger1\")\n@app.service_bus_topic_trigger(arg_name=\"message\", topic_name=\"mytopic\", connection=\"\", subscription_name=\"testsub\")\ndef test_function(message: func.ServiceBusMessage):\n    message_body = message.get_body().decode(\"utf-8\")\n\n    logging.info(\"Python ServiceBus topic trigger processed message.\")\n    logging.info(\"Message Body: \" + message_body)",
        "servicebus_topic_trigger_template.md": "# Azure Functions: Service Bus Topic Trigger in Python\r\n\r\n## Service Bus Topic Trigger\r\n\r\nUse the Service Bus Queue trigger to respond to messages from a Service Bus topic. Starting with extension version 3.1.0, you can trigger on a session-enabled topic.\r\n\r\n## Using the Template\r\n\r\nFollowing is an example code snippet for Service Bus Topic Trigger using the [Python programming model V2](https://aka.ms/pythonprogrammingmodel) (currently in Preview).\r\n\r\n```python\r\nimport logging\r\n\r\nimport azure.functions as func\r\n\r\napp = func.FunctionApp()\r\n\r\n@app.function_name(name=\"ServiceBusTopicTrigger1\")\r\n@app.service_bus_topic_trigger(arg_name=\"message\", topic_name=\"mytopic\", connection=\"\", subscription_name=\"testsub\")\r\ndef test_function(message: func.ServiceBusMessage):\r\n    message_body = message.get_body().decode(\"utf-8\")\r\n\r\n    logging.info(\"Python ServiceBus topic trigger processed message.\")\r\n    logging.info(\"Message Body: \" + message_body)\r\n```\r\n\r\nTo run the code snippet generated through the command palette, note the following:\r\n\r\n- The function application is defined and named `app`.\r\n- Confirm that the parameters within the trigger reflect values that correspond with your storage account.\r\n- The name of the file must be `function_app.py`.\r\n  \r\nNote that Service Bus output bindings are also supported in Azure Functions. To learn more, see [Azure Service Bus bindings for Azure Functions](https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-service-bus?tabs=in-process%2Cextensionv5%2Cextensionv3&pivots=programming-language-python)\r\n\r\n## Programming Model V2 (Preview)\r\n\r\nThe new programming model in Azure Functions Python delivers an experience that aligns with Python development principles, and subsequently with commonly used Python frameworks. \r\n\r\nThe improved programming model requires fewer files than the default model, and specifically eliminates the need for a configuration file (`function.json`). Instead, triggers and bindings are represented in the `function_app.py` file as decorators. Moreover, functions can be logically organized with support for multiple functions to be stored in the same file. Functions within the same function application can also be stored in different files, and be referenced as blueprints.\r\n\r\nTo learn more about using the new Python programming model for Azure Functions, see the [Azure Functions Python developer guide](https://aka.ms/pythondeveloperguide). Note that in addition to the documentation, [hints](https://aka.ms/functions-python-hints) are available in code editors that support type checking with PYI files.\r\n\r\nTo learn more about the new programming model for Azure Functions in Python, see [Programming Models in Azure Functions](https://aka.ms/functions-programming-models)."
      },
      "metadata": {
        "defaultFunctionName": "ServiceBusTopicTrigger",
        "description": "$ServiceBusTopicTrigger_description",
        "name": "Azure Service Bus Topic trigger",
        "language": "Python",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "serviceBus",
        "enabledInTryMode": false,
        "userPrompt": [
          "connection",
          "topicName",
          "subscriptionName"
        ]
      }
    },
    {
      "id": "ServiceBusTopicTrigger-Python-Preview-Append",
      "runtime": "2",
      "files": {
        "function_app.py": "@app.function_name(name=\"ServiceBusTopicTrigger1\")\n@app.service_bus_topic_trigger(arg_name=\"message\", topic_name=\"mytopic\", connection=\"\", subscription_name=\"testsub\")\ndef test_function(message: func.ServiceBusMessage):\n    message_body = message.get_body().decode(\"utf-8\")\n\n    logging.info(\"Python ServiceBus topic trigger processed message.\")\n    logging.info(\"Message Body: \" + message_body)",
        "servicebus_topic_trigger_template.md": "# Azure Functions: Service Bus Topic Trigger in Python\r\n\r\n## Service Bus Topic Trigger\r\n\r\nUse the Service Bus Queue trigger to respond to messages from a Service Bus topic. Starting with extension version 3.1.0, you can trigger on a session-enabled topic.\r\n\r\n## Using the Template\r\n\r\nFollowing is an example code snippet for Service Bus Topic Trigger using the [Python programming model V2](https://aka.ms/pythonprogrammingmodel) (currently in Preview).\r\n\r\n```python\r\nimport logging\r\n\r\nimport azure.functions as func\r\n\r\napp = func.FunctionApp()\r\n\r\n@app.function_name(name=\"ServiceBusTopicTrigger1\")\r\n@app.service_bus_topic_trigger(arg_name=\"message\", topic_name=\"mytopic\", connection=\"\", subscription_name=\"testsub\")\r\ndef test_function(message: func.ServiceBusMessage):\r\n    message_body = message.get_body().decode(\"utf-8\")\r\n\r\n    logging.info(\"Python ServiceBus topic trigger processed message.\")\r\n    logging.info(\"Message Body: \" + message_body)\r\n```\r\n\r\nTo run the code snippet generated through the command palette, note the following:\r\n\r\n- The function application is defined and named `app`.\r\n- Confirm that the parameters within the trigger reflect values that correspond with your storage account.\r\n- The name of the file must be `function_app.py`.\r\n  \r\nNote that Service Bus output bindings are also supported in Azure Functions. To learn more, see [Azure Service Bus bindings for Azure Functions](https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-service-bus?tabs=in-process%2Cextensionv5%2Cextensionv3&pivots=programming-language-python)\r\n\r\n## Programming Model V2 (Preview)\r\n\r\nThe new programming model in Azure Functions Python delivers an experience that aligns with Python development principles, and subsequently with commonly used Python frameworks. \r\n\r\nThe improved programming model requires fewer files than the default model, and specifically eliminates the need for a configuration file (`function.json`). Instead, triggers and bindings are represented in the `function_app.py` file as decorators. Moreover, functions can be logically organized with support for multiple functions to be stored in the same file. Functions within the same function application can also be stored in different files, and be referenced as blueprints.\r\n\r\nTo learn more about using the new Python programming model for Azure Functions, see the [Azure Functions Python developer guide](https://aka.ms/pythondeveloperguide). Note that in addition to the documentation, [hints](https://aka.ms/functions-python-hints) are available in code editors that support type checking with PYI files.\r\n\r\nTo learn more about the new programming model for Azure Functions in Python, see [Programming Models in Azure Functions](https://aka.ms/functions-programming-models)."
      },
      "metadata": {
        "defaultFunctionName": "ServiceBusTopicTrigger",
        "description": "$ServiceBusTopicTrigger_description",
        "name": "Azure Service Bus Topic trigger",
        "language": "Python",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "serviceBus",
        "enabledInTryMode": false,
        "userPrompt": [
          "connection",
          "topicName",
          "subscriptionName"
        ]
      }
    },
    {
      "id": "ServiceBusTopicTrigger-TypeScript",
      "runtime": "2",
      "files": {
        "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\r\n\r\nconst serviceBusTopicTrigger: AzureFunction = async function(context: Context, mySbMsg: any): Promise<void> {\r\n    context.log('ServiceBus topic trigger function processed message', mySbMsg);\r\n};\r\n\r\nexport default serviceBusTopicTrigger;\r\n",
        "sample.dat": "Service Bus Message"
      },
      "function": {
        "bindings": [
          {
            "name": "mySbMsg",
            "type": "serviceBusTrigger",
            "direction": "in",
            "topicName": "mytopic",
            "subscriptionName": "mysubscription",
            "connection": ""
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "ServiceBusTopicTrigger",
        "description": "$ServiceBusTopicTrigger_description",
        "name": "Azure Service Bus Topic trigger",
        "language": "TypeScript",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "serviceBus",
        "enabledInTryMode": false,
        "userPrompt": [
          "connection",
          "topicName",
          "subscriptionName"
        ]
      }
    },
    {
      "id": "SignalRConnectionInfoHttpTrigger-CSharp",
      "runtime": "2",
      "files": {
        "run.csx": "#r \"Microsoft.Azure.WebJobs.Extensions.SignalRService\"\nusing Microsoft.Azure.WebJobs.Extensions.SignalRService;\n\npublic static SignalRConnectionInfo Run(HttpRequest req, SignalRConnectionInfo connectionInfo)\n{\n    return connectionInfo;\n}\n",
        "sample.dat": ""
      },
      "function": {
        "disabled": false,
        "bindings": [
          {
            "authLevel": "anonymous",
            "type": "httpTrigger",
            "direction": "in",
            "methods": [
              "post"
            ],
            "name": "req",
            "route": "negotiate"
          },
          {
            "type": "http",
            "direction": "out",
            "name": "res"
          },
          {
            "type": "signalRConnectionInfo",
            "name": "connectionInfo",
            "hubName": "default",
            "connectionStringSetting": "AzureSignalRConnectionString",
            "direction": "in"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "negotiate",
        "description": "$signalRConnectionInfoNegotiate_description",
        "name": "SignalR negotiate HTTP trigger",
        "language": "C#",
        "category": [
          "$temp_category_core",
          "$temp_category_api"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": [
          "hubName",
          "connectionStringSetting",
          "route"
        ]
      }
    },
    {
      "id": "SignalRConnectionInfoHttpTrigger-Custom",
      "runtime": "2",
      "files": {},
      "function": {
        "disabled": false,
        "bindings": [
          {
            "authLevel": "anonymous",
            "type": "httpTrigger",
            "direction": "in",
            "methods": [
              "post"
            ],
            "name": "req",
            "route": "negotiate"
          },
          {
            "type": "http",
            "direction": "out",
            "name": "res"
          },
          {
            "type": "signalRConnectionInfo",
            "name": "connectionInfo",
            "hubName": "default",
            "connectionStringSetting": "AzureSignalRConnectionString",
            "direction": "in"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "negotiate",
        "description": "$signalRConnectionInfoNegotiate_description",
        "name": "SignalR negotiate HTTP trigger",
        "language": "Custom",
        "category": [
          "$temp_category_core",
          "$temp_category_api"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": [
          "hubName",
          "connectionStringSetting",
          "route"
        ]
      }
    },
    {
      "id": "SignalRConnectionInfoHttpTrigger-JavaScript",
      "runtime": "2",
      "files": {
        "index.js": "module.exports = async function (context, req, connectionInfo) {\n    context.res.body = connectionInfo;\n};",
        "sample.dat": ""
      },
      "function": {
        "disabled": false,
        "bindings": [
          {
            "authLevel": "anonymous",
            "type": "httpTrigger",
            "direction": "in",
            "methods": [
              "post"
            ],
            "name": "req",
            "route": "negotiate"
          },
          {
            "type": "http",
            "direction": "out",
            "name": "res"
          },
          {
            "type": "signalRConnectionInfo",
            "name": "connectionInfo",
            "hubName": "default",
            "connectionStringSetting": "AzureSignalRConnectionString",
            "direction": "in"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "negotiate",
        "description": "$signalRConnectionInfoNegotiate_description",
        "name": "SignalR negotiate HTTP trigger",
        "language": "JavaScript",
        "category": [
          "$temp_category_core",
          "$temp_category_api"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": [
          "hubName",
          "connectionStringSetting",
          "route"
        ]
      }
    },
    {
      "id": "SignalRConnectionInfoHttpTrigger-PowerShell",
      "runtime": "2",
      "files": {
        "run.ps1": "using namespace System.Net\n\nparam($Request, $TriggerMetadata, $ConnectionInfo)\n\nPush-OutputBinding -Name Response -Value ([HttpResponseContext]@{\n    StatusCode = [HttpStatusCode]::OK\n    ContentType = \"application/json\"\n    Body = $ConnectionInfo\n})",
        "sample.dat": ""
      },
      "function": {
        "disabled": false,
        "bindings": [
          {
            "authLevel": "anonymous",
            "type": "httpTrigger",
            "direction": "in",
            "methods": [
              "post"
            ],
            "name": "Request",
            "route": "negotiate"
          },
          {
            "type": "http",
            "direction": "out",
            "name": "Response"
          },
          {
            "type": "signalRConnectionInfo",
            "name": "ConnectionInfo",
            "hubName": "default",
            "connectionStringSetting": "AzureSignalRConnectionString",
            "direction": "in"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "negotiate",
        "description": "$signalRConnectionInfoNegotiate_description",
        "name": "SignalR negotiate HTTP trigger",
        "language": "PowerShell",
        "category": [
          "$temp_category_core",
          "$temp_category_api"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": [
          "hubName",
          "connectionStringSetting",
          "route"
        ]
      }
    },
    {
      "id": "SignalRConnectionInfoHttpTrigger-TypeScript",
      "runtime": "2",
      "files": {
        "index.ts": "import { AzureFunction, Context, HttpRequest } from \"@azure/functions\"\n\nconst httpTrigger: AzureFunction = async function (context: Context, req: HttpRequest, connectionInfo: any): Promise<void> {\n    context.res.body = connectionInfo;\n};\n\nexport default httpTrigger;\n",
        "sample.dat": ""
      },
      "function": {
        "disabled": false,
        "bindings": [
          {
            "authLevel": "anonymous",
            "type": "httpTrigger",
            "direction": "in",
            "methods": [
              "post"
            ],
            "name": "req",
            "route": "negotiate"
          },
          {
            "type": "http",
            "direction": "out",
            "name": "res"
          },
          {
            "type": "signalRConnectionInfo",
            "name": "connectionInfo",
            "hubName": "default",
            "connectionStringSetting": "AzureSignalRConnectionString",
            "direction": "in"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "negotiate",
        "description": "$signalRConnectionInfoNegotiate_description",
        "name": "SignalR negotiate HTTP trigger",
        "language": "TypeScript",
        "category": [
          "$temp_category_core",
          "$temp_category_api"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": [
          "hubName",
          "connectionStringSetting",
          "route"
        ]
      }
    },
    {
      "id": "SqlInputBinding-JavaScript",
      "runtime": "2",
      "files": {
        "index.js": "/**\n * Sample SQL Input Binding\n * See https://aka.ms/sqlbindingsinput for more information about using this binding\n *\n * These tasks should be completed prior to running :\n *      1. Update \"commandText\" in function.json - this should be the query to execute to retrieve the values being returned\n *      2. Add an app setting named \"SqlConnectionString\" containing the connection string\n *          to use for the SQL connection\n *      3. Change the bundle name in host.json to \"Microsoft.Azure.Functions.ExtensionBundle.Preview\" and the version to \"[3.*, 4.0.0)\"\n * @param context The Azure Function runtime context\n * @param req The HttpRequest that triggered this function\n * @param results The array of objects returned by the SQL input binding\n */\nmodule.exports = async function (context, req, results) {\n    context.log('Query results: ', JSON.stringify(results));\n    return {\n        status: 200,\n        body: results\n    };\n}\n",
        "readme.md": "# SQL Input Binding - JavaScript\n\nThe `SQL Input Binding` makes it easy to retrieve data from a database, returning the output of the query or stored procedure to the function.\n\n## How it works\n\nFor a `SQL Input Binding` to work, you can provide the query to retrive data from an existing object in the database. For instance, you can set the query to `Select * From [dbo].[table1]` to query `[dbo].[table1]` in the `commandText` value in your `function.json`.\n\nFor more information, see the official [docs](https://aka.ms/sqlbindingsinput)."
      },
      "function": {
        "bindings": [
          {
            "authLevel": "function",
            "name": "req",
            "type": "httpTrigger",
            "direction": "in",
            "methods": [
              "get"
            ]
          },
          {
            "name": "$return",
            "type": "http",
            "direction": "out"
          },
          {
            "type": "sql",
            "name": "results",
            "direction": "in",
            "commandText": "SELECT * FROM [dbo].[table1]",
            "commandType": "Text",
            "connectionStringSetting": "SqlConnectionString"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "SqlInputBinding",
        "description": "$SqlInputBinding_description",
        "name": "SQL Input Binding",
        "language": "JavaScript",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": []
      }
    },
    {
      "id": "SqlInputBinding-Python",
      "runtime": "2",
      "files": {
        "readme.md": "# SQL Input Binding - Python\n\nThe `SQL Input Binding` makes it easy to retrieve data from a database, returning the output of the query or stored procedure to the function.\n\n## How it works\n\nFor a `SQL Input Binding` to work, you can provide the query to retrieve data from an existing object in the database. For instance, you can set the query to `SELECT * FROM [dbo].[table1]` in the `commandText` value in your `function.json` to return all the values from the `[dbo].[table1]` table in the database.\n\nFor more information, see the official [docs](https://aka.ms/sqlbindingsinput).",
        "__init__.py": "import azure.functions as func\nimport json\n\ndef main(req: func.HttpRequest, items: func.SqlRowList) -> func.HttpResponse:\n    \"\"\"Sample SQL Input Binding\n\n    See https://aka.ms/sqlbindingsinput for more information about using this binding\n\n    *IMPORTANT*\n        Local Development : You must have v4.x of the Azure Function Core Tools installed, support for earlier versions will be added in a later release.\n        Deployed App : The app must be deployed to the EUAP region, support for other regions will be added later.\n\n    See https://github.com/Azure/azure-functions-sql-extension/issues/250 for the current state of Python support for the SQL binding\n\n    These tasks should be completed prior to running :\n    1. Update \"commandText\" in function.json - this should be the query to execute to retrieve the values being returned\n    2. Add an app setting named \"SqlConnectionString\" containing the connection string to use for the SQL connection\n    3. Change the bundle name in host.json to \"Microsoft.Azure.Functions.ExtensionBundle.Preview\" and the version to \"[4.*, 5.0.0)\"\n    4. Update requirements.txt and change the \"azure-functions\" line to \"azure-functions==1.11.3b1\" *IMPORTANT* Support for durable functions is not available in this release. A future release will combine SQL bindings and durable functions capabilities.\n    5. Add an app setting named \"PYTHON_ISOLATE_WORKER_DEPENDENCIES\" and set the value to \"1\" (to ensure that the correct version of the azure-functions library is used)\n\n    Arguments:\n    req: The HttpRequest that triggered this function\n    items: The list of objects returned by the SQL input binding\n    \"\"\"\n\n    rows = list(map(lambda r: json.loads(r.to_json()), items))\n\n    return func.HttpResponse(\n        json.dumps(rows),\n        status_code=200,\n        mimetype=\"application/json\"\n    )\n"
      },
      "function": {
        "scriptFile": "__init__.py",
        "bindings": [
          {
            "authLevel": "function",
            "type": "httpTrigger",
            "direction": "in",
            "name": "req",
            "methods": [
              "get"
            ]
          },
          {
            "type": "sql",
            "name": "items",
            "direction": "in",
            "commandText": "SELECT * FROM [dbo].[table1]",
            "commandType": "Text",
            "connectionStringSetting": "SqlConnectionString"
          },
          {
            "type": "http",
            "direction": "out",
            "name": "$return"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "SqlInputBinding",
        "description": "$SqlInputBinding_description",
        "name": "SQL Input Binding",
        "language": "Python",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "filters": [
          "Python3"
        ]
      }
    },
    {
      "id": "SqlInputBinding-Typescript",
      "runtime": "2",
      "files": {
        "index.ts": "import { AzureFunction, Context, HttpRequest } from \"@azure/functions\"\n\n/**\n * Sample SQL Input Binding\n * See https://aka.ms/sqlbindingsinput for more information about using this binding\n *\n * These tasks should be completed prior to running :\n *      1. Update \"commandText\" in function.json - this should be the query to execute to retrieve the values being returned\n *      2. Add an app setting named \"SqlConnectionString\" containing the connection string\n *          to use for the SQL connection\n *      3. Change the bundle name in host.json to \"Microsoft.Azure.Functions.ExtensionBundle.Preview\" and the version to \"[3.*, 4.0.0)\"\n * @param context The Azure Function runtime context\n * @param req The HttpRequest that triggered this function\n * @param items The array of objects returned by the SQL input binding\n */\nconst sqlInputBinding: AzureFunction = async function (context: Context, req: HttpRequest, items: any[]): Promise<void> {\n    context.log('HTTP trigger with SQL input binding function processed a request.');\n    context.res = {\n        // status: 200, /* Defaults to 200 */\n        body: items\n    };\n};\n\nexport default sqlInputBinding;",
        "readme.md": "# SQL Input Binding - Typescript\n\nThe `SQL Input Binding` makes it easy to retrieve data from a database, returning the output of the query or stored procedure to the function.\n\n## How it works\n\nFor a `SQL Input Binding` to work, you can provide the query to retrieve data from an existing object in the database. For instance, you can set the query to `SELECT * FROM [dbo].[table1]` in the `commandText` value in your `function.json` to return all the values from the `[dbo].[table1]` table in the database.\n\nFor more information, see the official [docs](https://aka.ms/sqlbindingsinput)."
      },
      "function": {
        "bindings": [
          {
            "authLevel": "function",
            "type": "httpTrigger",
            "direction": "in",
            "name": "req",
            "methods": [
              "get"
            ]
          },
          {
            "type": "sql",
            "name": "items",
            "direction": "in",
            "commandText": "SELECT * FROM [dbo].[table1]",
            "commandType": "Text",
            "connectionStringSetting": "SqlConnectionString"
          },
          {
            "type": "http",
            "direction": "out",
            "name": "res"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "SqlInputBinding",
        "description": "$SqlInputBinding_description",
        "name": "SQL Input Binding",
        "language": "Typescript",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": []
      }
    },
    {
      "id": "SqlOutputBinding-JavaScript",
      "runtime": "2",
      "files": {
        "index.js": "/**\n * Sample SQL Output Binding\n * See https://aka.ms/sqlbindingsoutput for more information about using this binding\n *\n * These tasks should be completed prior to running :\n *      1. Update \"commandText\" in function.json - this should be the name of the table that you wish to upsert values to\n *      2. Add an app setting named \"SqlConnectionString\" containing the connection string\n *          to use for the SQL connection\n *      3. Change the bundle name in host.json to \"Microsoft.Azure.Functions.ExtensionBundle.Preview\" and the version to \"[3.*, 4.0.0)\"\n * @param context The Azure Function runtime context\n * @param req The HttpRequest that triggered this function\n */\nmodule.exports = async function (context, req) {\n    context.log('HTTP trigger with SQL output binding function processed a request.');\n\n    // Set results array to context.bindings for upsertion\n    // Note that this expects the body to be a JSON object or array of objects which have a property\n    // matching each of the columns in the table to upsert to.\n    context.bindings.results = JSON.stringify(req.body);\n\n    context.res = {\n        status: 201,\n        body: req.body\n    };\n}",
        "readme.md": "# SQL Output Binding - JavaScript\n\nThe `SQL Output Binding` makes it easy to take an array of rows and upsert them into the user table (i.e. If a row doesn't already exist, it is added. If it does, it is updated).\n\n## How it works\n\nFor a `SQL Output Binding` to work, you provide the existing table in the database to upsert rows into. For instance, you can set the table to `[dbo].[table1]` in the `commandText` value in your `function.json` to upsert into this table.\n\nFor more information, see the official [docs](https://aka.ms/sqlbindingsoutput)"
      },
      "function": {
        "bindings": [
          {
            "authLevel": "function",
            "name": "req",
            "direction": "in",
            "type": "httpTrigger",
            "methods": [
              "post"
            ]
          },
          {
            "name": "$return",
            "type": "http",
            "direction": "out"
          },
          {
            "type": "sql",
            "name": "results",
            "direction": "out",
            "commandText": "[dbo].[table1]",
            "commandType": "Text",
            "connectionStringSetting": "SqlConnectionString"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "SqlOutputBinding",
        "description": "$SqlOutputBinding_description",
        "name": "SQL Output Binding",
        "language": "JavaScript",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": []
      }
    },
    {
      "id": "SqlOutputBinding-Python",
      "runtime": "2",
      "files": {
        "readme.md": "# SQL Output Binding - Python\n\nThe `SQL Output Binding` makes it easy to take a list of rows and upsert them into the user table (i.e. If a row doesn't already exist, it is added. If it does, it is updated).\n\n## How it works\n\nFor a `SQL Output Binding` to work, you provide the existing table in the database to upsert rows into. For instance, you can set the table to `[dbo].[table1]` in the `commandText` value in your `function.json` to upsert into this table.\n\nFor more information, see the official [docs](https://aka.ms/sqlbindingsoutput)",
        "__init__.py": "import json\nimport azure.functions as func\n\ndef main(req: func.HttpRequest, items: func.Out[func.SqlRowList]) -> func.HttpResponse:\n    \"\"\"Sample SQL Output Binding\n\n    See https://aka.ms/sqlbindingsoutput for more information about using this binding\n\n    *IMPORTANT*\n        Local Development : You must have v4.x of the Azure Function Core Tools installed, support for earlier versions will be added in a later release.\n        Deployed App : The app must be deployed to the EUAP region, support for other regions will be added later.\n\n    See https://github.com/Azure/azure-functions-sql-extension/issues/250 for the current state of Python support for the SQL binding\n\n    These tasks should be completed prior to running :\n    1. Update \"commandText\" in function.json - this should be the name of the table that you wish to upsert values to\n    2. Add an app setting named \"SqlConnectionString\" containing the connection string to use for the SQL connection\n    3. Change the bundle name in host.json to \"Microsoft.Azure.Functions.ExtensionBundle.Preview\" and the version to \"[4.*, 5.0.0)\"\n    4. Update requirements.txt and change the \"azure-functions\" line to \"azure-functions==1.11.3b1\" *IMPORTANT* Support for durable functions is not available in this release. A future release will combine SQL bindings and durable functions capabilities.\n    5. Add an app setting named \"PYTHON_ISOLATE_WORKER_DEPENDENCIES\" and set the value to \"1\" (to ensure that the correct version of the azure-functions library is used)\n\n    Arguments:\n    req: The HttpRequest that triggered this function\n    items: The objects to be upserted to the database\n    \"\"\"\n\n    # Note that this expects the body to be an array of JSON objects which\n    # have a property matching each of the columns in the table to upsert to.\n    body = json.loads(req.get_body())\n    rows = func.SqlRowList(map(lambda r: func.SqlRow.from_dict(r), body))\n    items.set(rows)\n\n    return func.HttpResponse(\n        body=req.get_body(),\n        status_code=201, # 201 Created\n        mimetype=\"application/json\"\n    )\n"
      },
      "function": {
        "scriptFile": "__init__.py",
        "bindings": [
          {
            "authLevel": "function",
            "type": "httpTrigger",
            "direction": "in",
            "name": "req",
            "methods": [
              "post"
            ]
          },
          {
            "type": "sql",
            "name": "items",
            "direction": "out",
            "commandText": "[dbo].[table1]",
            "connectionStringSetting": "SqlConnectionString"
          },
          {
            "type": "http",
            "direction": "out",
            "name": "$return"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "SqlOutputBinding",
        "description": "$SqlOutputBinding_description",
        "name": "SQL Output Binding",
        "language": "Python",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "filters": [
          "Python3"
        ]
      }
    },
    {
      "id": "SqlOutputBinding-Typescript",
      "runtime": "2",
      "files": {
        "index.ts": "import { AzureFunction, Context, HttpRequest } from \"@azure/functions\"\n\n/**\n * Sample SQL Output Binding\n * See https://aka.ms/sqlbindingsoutput for more information about using this binding\n *\n * These tasks should be completed prior to running :\n *      1. Update \"commandText\" in function.json - this should be the name of the table that you wish to upsert values to\n *      2. Add an app setting named \"SqlConnectionString\" containing the connection string\n *          to use for the SQL connection\n *      3. Change the bundle name in host.json to \"Microsoft.Azure.Functions.ExtensionBundle.Preview\" and the version to \"[3.*, 4.0.0)\"\n * @param context The Azure Function runtime context\n * @param req The HttpRequest that triggered this function\n */\nconst sqlOutputBinding: AzureFunction = async function (context: Context, req: HttpRequest): Promise<void> {\n    context.log('HTTP trigger with SQL output binding function processed a request.');\n\n    // Set items array to context.bindings for upsertion\n    // Note that this expects the body to be a JSON object or array of objects which have a property\n    // matching each of the columns in the table to upsert to.\n    context.bindings.items = JSON.stringify(req.body);\n\n    context.res = {\n        status: 201, // 201 Created\n        body: req.body\n    };\n};\n\nexport default sqlOutputBinding;\n",
        "readme.md": "# SQL Output Binding - TypeScript\n\nThe `SQL Output Binding` makes it easy to take an array of rows and upsert them into the user table (i.e. If a row doesn't already exist, it is added. If it does, it is updated).\n\n## How it works\n\nFor a `SQL Output Binding` to work, you provide the existing table in the database to upsert rows into. For instance, you can set the table to `[dbo].[table1]` in the `commandText` value in your `function.json` to upsert into this table.\n\nFor more information, see the official [docs](https://aka.ms/sqlbindingsoutput)"
      },
      "function": {
        "bindings": [
          {
            "authLevel": "function",
            "type": "httpTrigger",
            "direction": "in",
            "name": "req",
            "methods": [
              "post"
            ]
          },
          {
            "type": "sql",
            "name": "items",
            "direction": "out",
            "commandText": "[dbo].[table1]",
            "connectionStringSetting": "SqlConnectionString"
          },
          {
            "type": "http",
            "direction": "out",
            "name": "res"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "SqlOutputBinding",
        "description": "$SqlOutputBinding_description",
        "name": "SQL Output Binding",
        "language": "TypeScript",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "other",
        "enabledInTryMode": false,
        "userPrompt": []
      }
    },
    {
      "id": "TimerTrigger-CSharp",
      "runtime": "2",
      "files": {
        "readme.md": "# TimerTrigger - C<span>#</span>\r\n\r\nThe `TimerTrigger` makes it incredibly easy to have your functions executed on a schedule. This sample demonstrates a simple use case of calling your function every 5 minutes.\r\n\r\n## How it works\r\n\r\nFor a `TimerTrigger` to work, you provide a schedule in the form of a [cron expression](https://en.wikipedia.org/wiki/Cron#CRON_expression)(See the link for full details). A cron expression is a string with 6 separate expressions which represent a given schedule via patterns. The pattern we use to represent every 5 minutes is `0 */5 * * * *`. This, in plain text, means: \"When seconds is equal to 0, minutes is divisible by 5, for any hour, day of the month, month, day of the week, or year\".\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
        "run.csx": "using System;\r\n\r\npublic static void Run(TimerInfo myTimer, ILogger log)\r\n{\r\n    log.LogInformation($\"C# Timer trigger function executed at: {DateTime.Now}\");\r\n}\r\n",
        "sample.dat": ""
      },
      "function": {
        "bindings": [
          {
            "name": "myTimer",
            "type": "timerTrigger",
            "direction": "in",
            "schedule": "0 */5 * * * *"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "TimerTrigger",
        "description": "$TimerTrigger_description",
        "name": "Timer trigger",
        "language": "C#",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "timer",
        "enabledInTryMode": true,
        "userPrompt": [
          "schedule"
        ]
      }
    },
    {
      "id": "TimerTrigger-Custom",
      "runtime": "2",
      "files": {},
      "function": {
        "bindings": [
          {
            "name": "myTimer",
            "type": "timerTrigger",
            "direction": "in",
            "schedule": "0 */5 * * * *"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "TimerTrigger",
        "description": "$TimerTrigger_description",
        "name": "Timer trigger",
        "language": "Custom",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "timer",
        "enabledInTryMode": true,
        "userPrompt": [
          "schedule"
        ]
      }
    },
    {
      "id": "TimerTrigger-JavaScript",
      "runtime": "2",
      "files": {
        "index.js": "module.exports = async function (context, myTimer) {\r\n    var timeStamp = new Date().toISOString();\r\n    \r\n    if (myTimer.isPastDue)\r\n    {\r\n        context.log('JavaScript is running late!');\r\n    }\r\n    context.log('JavaScript timer trigger function ran!', timeStamp);   \r\n};",
        "readme.md": "# TimerTrigger - JavaScript\r\n\r\nThe `TimerTrigger` makes it incredibly easy to have your functions executed on a schedule. This sample demonstrates a simple use case of calling your function every 5 minutes.\r\n\r\n## How it works\r\n\r\nFor a `TimerTrigger` to work, you provide a schedule in the form of a [cron expression](https://en.wikipedia.org/wiki/Cron#CRON_expression)(See the link for full details). A cron expression is a string with 6 separate expressions which represent a given schedule via patterns. The pattern we use to represent every 5 minutes is `0 */5 * * * *`. This, in plain text, means: \"When seconds is equal to 0, minutes is divisible by 5, for any hour, day of the month, month, day of the week, or year\".\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
        "sample.dat": ""
      },
      "function": {
        "bindings": [
          {
            "name": "myTimer",
            "type": "timerTrigger",
            "direction": "in",
            "schedule": "0 */5 * * * *"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "TimerTrigger",
        "description": "$TimerTrigger_description",
        "name": "Timer trigger",
        "language": "JavaScript",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "timer",
        "enabledInTryMode": true,
        "userPrompt": [
          "schedule"
        ]
      }
    },
    {
      "id": "TimerTrigger-PowerShell",
      "runtime": "2",
      "files": {
        "readme.md": "# TimerTrigger - PowerShell\r\n\r\nThe `TimerTrigger` makes it incredibly easy to have your functions executed on a schedule. This sample demonstrates a simple use case of calling your function every 5 minutes.\r\n\r\n## How it works\r\n\r\nFor a `TimerTrigger` to work, you provide a schedule in the form of a [cron expression](https://en.wikipedia.org/wiki/Cron#CRON_expression)(See the link for full details). A cron expression is a string with 6 separate expressions which represent a given schedule via patterns. The pattern we use to represent every 5 minutes is `0 */5 * * * *`. This, in plain text, means: \"When seconds is equal to 0, minutes is divisible by 5, for any hour, day of the month, month, and day of the week\".\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation\r\n",
        "run.ps1": "# Input bindings are passed in via param block.\nparam($Timer)\n\n# Get the current universal time in the default string format.\n$currentUTCtime = (Get-Date).ToUniversalTime()\n\n# The 'IsPastDue' property is 'true' when the current function invocation is later than scheduled.\nif ($Timer.IsPastDue) {\n    Write-Host \"PowerShell timer is running late!\"\n}\n\n# Write an information log with the current time.\nWrite-Host \"PowerShell timer trigger function ran! TIME: $currentUTCtime\"\n",
        "sample.dat": ""
      },
      "function": {
        "bindings": [
          {
            "name": "Timer",
            "type": "timerTrigger",
            "direction": "in",
            "schedule": "0 */5 * * * *"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "TimerTrigger",
        "description": "$TimerTrigger_description",
        "name": "Timer trigger",
        "language": "PowerShell",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "timer",
        "enabledInTryMode": true,
        "userPrompt": [
          "schedule"
        ]
      }
    },
    {
      "id": "TimerTrigger-Python",
      "runtime": "2",
      "files": {
        "readme.md": "# TimerTrigger - Python\r\n\r\nThe `TimerTrigger` makes it incredibly easy to have your functions executed on a schedule. This sample demonstrates a simple use case of calling your function every 5 minutes.\r\n\r\n## How it works\r\n\r\nFor a `TimerTrigger` to work, you provide a schedule in the form of a [cron expression](https://en.wikipedia.org/wiki/Cron#CRON_expression)(See the link for full details). A cron expression is a string with 6 separate expressions which represent a given schedule via patterns. The pattern we use to represent every 5 minutes is `0 */5 * * * *`. This, in plain text, means: \"When seconds is equal to 0, minutes is divisible by 5, for any hour, day of the month, month, day of the week, or year\".\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation\r\n",
        "sample.dat": "",
        "__init__.py": "import datetime\r\nimport logging\r\n\r\nimport azure.functions as func\r\n\r\n\r\ndef main(mytimer: func.TimerRequest) -> None:\r\n    utc_timestamp = datetime.datetime.utcnow().replace(\r\n        tzinfo=datetime.timezone.utc).isoformat()\r\n\r\n    if mytimer.past_due:\r\n        logging.info('The timer is past due!')\r\n\r\n    logging.info('Python timer trigger function ran at %s', utc_timestamp)\r\n"
      },
      "function": {
        "scriptFile": "__init__.py",
        "bindings": [
          {
            "name": "mytimer",
            "type": "timerTrigger",
            "direction": "in",
            "schedule": "0 */5 * * * *"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "TimerTrigger",
        "description": "$TimerTrigger_description",
        "name": "Timer trigger",
        "language": "Python",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "timer",
        "enabledInTryMode": true,
        "userPrompt": [
          "schedule"
        ],
        "filters": [
          "Python3"
        ]
      }
    },
    {
      "id": "TimerTrigger-Python-Preview",
      "runtime": "2",
      "files": {
        "function_app.py": "import datetime\n\nimport logging\n\nimport azure.functions as func\n\napp = func.FunctionApp()\n\n@app.function_name(name=\"mytimer\")\n@app.schedule(schedule=\"0 */5 * * * *\", arg_name=\"mytimer\", run_on_startup=True,\n              use_monitor=False) \ndef test_function(mytimer: func.TimerRequest) -> None:\n    utc_timestamp = datetime.datetime.utcnow().replace(\n        tzinfo=datetime.timezone.utc).isoformat()\n\n    if mytimer.past_due:\n        logging.info('The timer is past due!')\n\n    logging.info('Python timer trigger function ran at %s', utc_timestamp)\n",
        "timer_trigger_template.md": "# Azure Functions: Timer Trigger in Python\r\n\r\n## Timer Trigger\r\n\r\nA timer trigger lets you run a function on a schedule.\r\n\r\n## Using the Template\r\n\r\nFollowing is an example code snippet for Timer Trigger using the [Python programming model V2](https://aka.ms/pythonprogrammingmodel) (currently in Preview).\r\n\r\n```python\r\nimport datetime\r\n\r\nimport logging\r\n\r\nimport azure.functions as func\r\n\r\napp = func.FunctionApp()\r\n\r\n@app.function_name(name=\"mytimer\")\r\n@app.schedule(schedule=\"0 */5 * * * *\", arg_name=\"mytimer\", run_on_startup=True,\r\n              use_monitor=False) \r\ndef mytimer(mytimer: func.TimerRequest) -> None:\r\n    utc_timestamp = datetime.datetime.utcnow().replace(\r\n        tzinfo=datetime.timezone.utc).isoformat()\r\n\r\n    if mytimer.past_due:\r\n        logging.info('The timer is past due!')\r\n\r\n    logging.info('Python timer trigger function ran at %s', utc_timestamp)\r\n```\r\n\r\nTo run the code snippet generated through the command palette, note the following:\r\n\r\n- The function application is defined and named `app`.\r\n- Confirm that the parameters within the trigger reflect values that correspond with your storage account.\r\n- The name of the file must be `function_app.py`.\r\n\r\n## Programming Model V2 (Preview)\r\n\r\nThe new programming model in Azure Functions Python delivers an experience that aligns with Python development principles, and subsequently with commonly used Python frameworks. \r\n\r\nThe improved programming model requires fewer files than the default model, and specifically eliminates the need for a configuration file (`function.json`). Instead, triggers and bindings are represented in the `function_app.py` file as decorators. Moreover, functions can be logically organized with support for multiple functions to be stored in the same file. Functions within the same function application can also be stored in different files, and be referenced as blueprints.\r\n\r\nTo learn more about using the new Python programming model for Azure Functions, see the [Azure Functions Python developer guide](https://aka.ms/pythondeveloperguide). Note that in addition to the documentation, [hints](https://aka.ms/functions-python-hints) are available in code editors that support type checking with PYI files.\r\n\r\nTo learn more about the new programming model for Azure Functions in Python, see [Programming Models in Azure Functions](https://aka.ms/functions-programming-models)."
      },
      "metadata": {
        "defaultFunctionName": "TimerTrigger",
        "description": "$TimerTrigger_description",
        "name": "Timer trigger",
        "language": "Python",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "timer",
        "enabledInTryMode": true,
        "userPrompt": [
          "schedule"
        ],
        "filters": [
          "Python3"
        ]
      }
    },
    {
      "id": "TimerTrigger-Python-Preview-Append",
      "runtime": "2",
      "files": {
        "function_app.py": "@app.function_name(name=\"mytimer\")\n@app.schedule(schedule=\"0 */5 * * * *\", arg_name=\"mytimer\", run_on_startup=True,\n              use_monitor=False) \ndef test_function(mytimer: func.TimerRequest) -> None:\n    utc_timestamp = datetime.datetime.utcnow().replace(\n        tzinfo=datetime.timezone.utc).isoformat()\n\n    if mytimer.past_due:\n        logging.info('The timer is past due!')\n\n    logging.info('Python timer trigger function ran at %s', utc_timestamp)\n",
        "timer_trigger_template.md": "# Azure Functions: Timer Trigger in Python\r\n\r\n## Timer Trigger\r\n\r\nA timer trigger lets you run a function on a schedule.\r\n\r\n## Using the Template\r\n\r\nFollowing is an example code snippet for Timer Trigger using the [Python programming model V2](https://aka.ms/pythonprogrammingmodel) (currently in Preview).\r\n\r\n```python\r\nimport datetime\r\n\r\nimport logging\r\n\r\nimport azure.functions as func\r\n\r\napp = func.FunctionApp()\r\n\r\n@app.function_name(name=\"mytimer\")\r\n@app.schedule(schedule=\"0 */5 * * * *\", arg_name=\"mytimer\", run_on_startup=True,\r\n              use_monitor=False) \r\ndef test_function(mytimer: func.TimerRequest) -> None:\r\n    utc_timestamp = datetime.datetime.utcnow().replace(\r\n        tzinfo=datetime.timezone.utc).isoformat()\r\n\r\n    if mytimer.past_due:\r\n        logging.info('The timer is past due!')\r\n\r\n    logging.info('Python timer trigger function ran at %s', utc_timestamp)\r\n```\r\n\r\nTo run the code snippet generated through the command palette, note the following:\r\n\r\n- The function application is defined and named `app`.\r\n- Confirm that the parameters within the trigger reflect values that correspond with your storage account.\r\n- The name of the file must be `function_app.py`.\r\n\r\n## Programming Model V2 (Preview)\r\n\r\nThe new programming model in Azure Functions Python delivers an experience that aligns with Python development principles, and subsequently with commonly used Python frameworks. \r\n\r\nThe improved programming model requires fewer files than the default model, and specifically eliminates the need for a configuration file (`function.json`). Instead, triggers and bindings are represented in the `function_app.py` file as decorators. Moreover, functions can be logically organized with support for multiple functions to be stored in the same file. Functions within the same function application can also be stored in different files, and be referenced as blueprints.\r\n\r\nTo learn more about using the new Python programming model for Azure Functions, see the [Azure Functions Python developer guide](https://aka.ms/pythondeveloperguide). Note that in addition to the documentation, [hints](https://aka.ms/functions-python-hints) are available in code editors that support type checking with PYI files.\r\n\r\nTo learn more about the new programming model for Azure Functions in Python, see [Programming Models in Azure Functions](https://aka.ms/functions-programming-models)."
      },
      "metadata": {
        "defaultFunctionName": "TimerTrigger",
        "description": "$TimerTrigger_description",
        "name": "Timer trigger",
        "language": "Python",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "timer",
        "enabledInTryMode": true,
        "userPrompt": [
          "schedule"
        ],
        "filters": [
          "Python3"
        ]
      }
    },
    {
      "id": "TimerTrigger-TypeScript",
      "runtime": "2",
      "files": {
        "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\r\n\r\nconst timerTrigger: AzureFunction = async function (context: Context, myTimer: any): Promise<void> {\r\n    var timeStamp = new Date().toISOString();\r\n    \r\n    if (myTimer.isPastDue)\r\n    {\r\n        context.log('Timer function is running late!');\r\n    }\r\n    context.log('Timer trigger function ran!', timeStamp);   \r\n};\r\n\r\nexport default timerTrigger;\r\n",
        "readme.md": "# TimerTrigger - TypeScript\r\n\r\nThe `TimerTrigger` makes it incredibly easy to have your functions executed on a schedule. This sample demonstrates a simple use case of calling your function every 5 minutes.\r\n\r\n## How it works\r\n\r\nFor a `TimerTrigger` to work, you provide a schedule in the form of a [cron expression](https://en.wikipedia.org/wiki/Cron#CRON_expression)(See the link for full details). A cron expression is a string with 6 separate expressions which represent a given schedule via patterns. The pattern we use to represent every 5 minutes is `0 */5 * * * *`. This, in plain text, means: \"When seconds is equal to 0, minutes is divisible by 5, for any hour, day of the month, month, day of the week, or year\".\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation"
      },
      "function": {
        "bindings": [
          {
            "name": "myTimer",
            "type": "timerTrigger",
            "direction": "in",
            "schedule": "0 */5 * * * *"
          }
        ]
      },
      "metadata": {
        "defaultFunctionName": "TimerTrigger",
        "description": "$TimerTrigger_description",
        "name": "Timer trigger",
        "language": "TypeScript",
        "category": [
          "$temp_category_core",
          "$temp_category_dataProcessing"
        ],
        "categoryStyle": "timer",
        "enabledInTryMode": true,
        "userPrompt": [
          "schedule"
        ]
      }
    }
  ]
