[
  {
    "id": "BlobTrigger-CSharp",
    "runtime": "2",
    "files": {
      "readme.md": "# BlobTrigger - C<span>#</span>\r\n\r\nThe `BlobTrigger` makes it incredibly easy to react to new Blobs inside of Azure Blob Storage. This sample demonstrates a simple use case of processing data from a given Blob using C#.\r\n\r\n## How it works\r\n\r\nFor a `BlobTrigger` to work, you provide a path which dictates where the blobs are located inside your container, and can also help restrict the types of blobs you wish to return. For instance, you can set the path to `samples/{name}.png` to restrict the trigger to only the samples path and only blobs with \".png\" at the end of their name.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
      "run.csx": "public static void Run(Stream myBlob, string name, ILogger log)\r\n{\r\n    log.LogInformation($\"C# Blob trigger function Processed blob\\n Name:{name} \\n Size: {myBlob.Length} Bytes\");\r\n}\r\n",
      "sample.dat": "samples-workitems/workitem.txt"
    },
    "function": {
      "bindings": [
        {
          "name": "myBlob",
          "type": "blobTrigger",
          "direction": "in",
          "path": "samples-workitems/{name}",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "BlobTrigger",
      "description": "$BlobTrigger_description",
      "name": "Azure Blob Storage trigger",
      "language": "C#",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "blob",
      "enabledInTryMode": true,
      "userPrompt": [
        "connection",
        "path"
      ]
    }
  },
  {
    "id": "BlobTrigger-Custom",
    "runtime": "2",
    "files": {},
    "function": {
      "bindings": [
        {
          "name": "myBlob",
          "type": "blobTrigger",
          "direction": "in",
          "path": "samples-workitems/{name}",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "BlobTrigger",
      "description": "$BlobTrigger_description",
      "name": "Azure Blob Storage trigger",
      "language": "Custom",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "blob",
      "enabledInTryMode": true,
      "userPrompt": [
        "connection",
        "path"
      ]
    }
  },
  {
    "id": "BlobTrigger-JavaScript",
    "runtime": "2",
    "files": {
      "index.js": "module.exports = async function (context, myBlob) {\r\n    context.log(\"JavaScript blob trigger function processed blob \\n Blob:\", context.bindingData.blobTrigger, \"\\n Blob Size:\", myBlob.length, \"Bytes\");\r\n};",
      "readme.md": "# BlobTrigger - JavaScript\r\n\r\nThe `BlobTrigger` makes it incredibly easy to react to new Blobs inside of Azure Blob Storage. This sample demonstrates a simple use case of processing data from a given Blob using JavaScript.\r\n\r\n## How it works\r\n\r\nFor a `BlobTrigger` to work, you provide a path which dictates where the blobs are located inside your container, and can also help restrict the types of blobs you wish to return. For instance, you can set the path to `samples/{name}.png` to restrict the trigger to only the samples path and only blobs with \".png\" at the end of their name.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
      "sample.dat": "samples-workitems/workitem.txt"
    },
    "function": {
      "bindings": [
        {
          "name": "myBlob",
          "type": "blobTrigger",
          "direction": "in",
          "path": "samples-workitems/{name}",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "BlobTrigger",
      "description": "$BlobTrigger_description",
      "name": "Azure Blob Storage trigger",
      "language": "JavaScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "blob",
      "enabledInTryMode": true,
      "userPrompt": [
        "connection",
        "path"
      ]
    }
  },
  {
    "id": "BlobTrigger-PowerShell",
    "runtime": "2",
    "files": {
      "readme.md": "# BlobTrigger - PowerShell\r\n\r\nThe `BlobTrigger` makes it incredibly easy to react to new Blobs inside of [Azure Blob Storage](https://azure.microsoft.com/en-us/services/storage/blobs/).\r\nThis sample demonstrates a simple use case of processing data from a given Blob using PowerShell.\r\n\r\n## How it works\r\n\r\nFor a `BlobTrigger` to work, you provide a path which dictates where the blobs are located inside your container, and can also help restrict the types of blobs you wish to return. For instance, you can set the path to `samples/{name}.png` to restrict the trigger to only the samples path and only blobs with \".png\" at the end of their name.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation\r\n",
      "run.ps1": "# Input bindings are passed in via param block.\r\nparam([byte[]] $InputBlob, $TriggerMetadata)\r\n\r\n# Write out the blob name and size to the information log.\r\nWrite-Host \"PowerShell Blob trigger function Processed blob! Name: $($TriggerMetadata.Name) Size: $($InputBlob.Length) bytes\"\r\n",
      "sample.dat": "samples-workitems/workitem.txt"
    },
    "function": {
      "bindings": [
        {
          "name": "InputBlob",
          "type": "blobTrigger",
          "direction": "in",
          "path": "samples-workitems/{name}",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "BlobTrigger",
      "description": "$BlobTrigger_description",
      "name": "Azure Blob Storage trigger",
      "language": "PowerShell",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "blob",
      "enabledInTryMode": true,
      "userPrompt": [
        "connection",
        "path"
      ]
    }
  },
  {
    "id": "BlobTrigger-Python",
    "runtime": "2",
    "files": {
      "readme.md": "# BlobTrigger - Python\r\n\r\nThe `BlobTrigger` makes it incredibly easy to react to new Blobs inside of Azure Blob Storage. This sample demonstrates a simple use case of processing data from a given Blob using Python.\r\n\r\n## How it works\r\n\r\nFor a `BlobTrigger` to work, you provide a path which dictates where the blobs are located inside your container, and can also help restrict the types of blobs you wish to return. For instance, you can set the path to `samples/{name}.png` to restrict the trigger to only the samples path and only blobs with \".png\" at the end of their name.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
      "sample.dat": "samples-workitems/workitem.txt",
      "__init__.py": "import logging\r\n\r\nfrom azure.functions import InputStream\r\n\r\n\r\ndef main(myblob: InputStream):\r\n    logging.info(f\"Python blob trigger function processed blob \\n\"\r\n                 f\"Name: {myblob.name}\\n\"\r\n                 f\"Blob Size: {myblob.length} bytes\")\r\n"
    },
    "function": {
      "scriptFile": "__init__.py",
      "bindings": [
        {
          "name": "myblob",
          "type": "blobTrigger",
          "direction": "in",
          "path": "samples-workitems/{name}",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "BlobTrigger",
      "description": "$BlobTrigger_description",
      "name": "Azure Blob Storage trigger",
      "language": "Python",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "blob",
      "enabledInTryMode": true,
      "userPrompt": [
        "connection",
        "path"
      ],
      "filters": [
        "Python3"
      ]
    }
  },
  {
    "id": "BlobTrigger-TypeScript",
    "runtime": "2",
    "files": {
      "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\r\n\r\nconst blobTrigger: AzureFunction = async function (context: Context, myBlob: any): Promise<void> {\r\n    context.log(\"Blob trigger function processed blob \\n Name:\", context.bindingData.name, \"\\n Blob Size:\", myBlob.length, \"Bytes\");\r\n};\r\n\r\nexport default blobTrigger;\r\n",
      "readme.md": "# BlobTrigger - TypeScript\r\n\r\nThe `BlobTrigger` makes it incredibly easy to react to new Blobs inside of Azure Blob Storage. This sample demonstrates a simple use case of processing data from a given Blob using TypeScript.\r\n\r\n## How it works\r\n\r\nFor a `BlobTrigger` to work, you provide a path which dictates where the blobs are located inside your container, and can also help restrict the types of blobs you wish to return. For instance, you can set the path to `samples/{name}.png` to restrict the trigger to only the samples path and only blobs with \".png\" at the end of their name.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
      "sample.dat": "samples-workitems/workitem.txt"
    },
    "function": {
      "bindings": [
        {
          "name": "myBlob",
          "type": "blobTrigger",
          "direction": "in",
          "path": "samples-workitems/{name}",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "BlobTrigger",
      "description": "$BlobTrigger_description",
      "name": "Azure Blob Storage trigger",
      "language": "TypeScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "blob",
      "enabledInTryMode": true,
      "userPrompt": [
        "connection",
        "path"
      ]
    }
  },
  {
    "id": "CosmosDBTrigger-CSharp",
    "runtime": "2",
    "files": {
      "run.csx": "using System;\r\nusing System.Collections.Generic;\r\n\r\npublic static void Run(IReadOnlyList<ToDoItem> input, ILogger log)\r\n{\r\n    if (input != null && input.Count > 0)\r\n    {\r\n        log.LogInformation(\"Documents modified \" + input.Count);\r\n        log.LogInformation(\"First document Id \" + input[0].id);\r\n    }\r\n}\r\n\r\n// Customize the model with your own desired properties\r\npublic class ToDoItem\r\n{\r\n    public string id { get; set; }\r\n    public string Description { get; set; }\r\n}\r\n"
    },
    "function": {
      "bindings": [
        {
          "type": "cosmosDBTrigger",
          "name": "input",
          "direction": "in",
          "leaseContainerName": "leases",
          "connection": "",
          "databaseName": "",
          "containerName": "",
          "createLeaseContainerIfNotExists": true,
          "startFromBeginning": false
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "CosmosTrigger",
      "description": "$CosmosDBTrigger_description",
      "name": "Azure Cosmos DB trigger",
      "language": "C#",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "cosmosDB",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "databaseName",
        "containerName",
        "leaseContainerName",
        "createLeaseContainerIfNotExists"
      ]
    }
  },
  {
    "id": "CosmosDBTrigger-Custom",
    "runtime": "2",
    "files": {},
    "function": {
      "bindings": [
        {
          "type": "cosmosDBTrigger",
          "name": "documents",
          "direction": "in",
          "leaseContainerName": "leases",
          "connection": "",
          "databaseName": "",
          "containerName": "",
          "createLeaseContainerIfNotExists": true
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "CosmosTrigger",
      "description": "$CosmosDBTrigger_description",
      "name": "Azure Cosmos DB trigger",
      "language": "Custom",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "cosmosDB",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "databaseName",
        "containerName",
        "leaseContainerName",
        "createLeaseContainerIfNotExists"
      ]
    }
  },
  {
    "id": "CosmosDBTrigger-JavaScript",
    "runtime": "2",
    "files": {
      "index.js": "module.exports = async function (context, documents) {\r\n    if (!!documents && documents.length > 0) {\r\n        context.log('Document Id: ', documents[0].id);\r\n    }\r\n}\r\n",
      "sample.dat": "[\r\n\t{\r\n\t\t\"id\": \"sample\"\r\n\t}\r\n]"
    },
    "function": {
      "bindings": [
        {
          "type": "cosmosDBTrigger",
          "name": "documents",
          "direction": "in",
          "leaseContainerName": "leases",
          "connection": "",
          "databaseName": "",
          "containerName": "",
          "createLeaseContainerIfNotExists": true,
          "startFromBeginning": false
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "CosmosTrigger",
      "description": "$CosmosDBTrigger_description",
      "name": "Azure Cosmos DB trigger",
      "language": "JavaScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "cosmosDB",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "databaseName",
        "containerName",
        "leaseContainerName",
        "createLeaseContainerIfNotExists"
      ]
    }
  },
  {
    "id": "CosmosDBTrigger-PowerShell",
    "runtime": "2",
    "files": {
      "run.ps1": "# Input bindings are passed in via param block.\r\nparam($Documents, $TriggerMetadata)\r\n\r\nif ($Documents.Count -gt 0) {\r\n    Write-Host \"Document Id: $($Documents[0].id)\"\r\n}\r\n",
      "sample.dat": "[\r\n\t{\r\n\t\t\"id\": \"sample\"\r\n\t}\r\n]\r\n"
    },
    "function": {
      "bindings": [
        {
          "type": "cosmosDBTrigger",
          "name": "documents",
          "direction": "in",
          "leaseContainerName": "leases",
          "connection": "",
          "databaseName": "",
          "containerName": "",
          "createLeaseContainerIfNotExists": true,
          "startFromBeginning": false
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "CosmosTrigger",
      "description": "$CosmosDBTrigger_description",
      "name": "Azure Cosmos DB trigger",
      "language": "PowerShell",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "cosmosDB",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "databaseName",
        "containerName",
        "leaseContainerName",
        "createLeaseContainerIfNotExists"
      ]
    }
  },
  {
    "id": "CosmosDBTrigger-Python",
    "runtime": "2",
    "files": {
      "sample.dat": "[\r\n\t{\r\n\t\t\"id\": \"sample\"\r\n\t}\r\n]",
      "__init__.py": "import logging\r\n\r\nfrom azure.functions import DocumentList\r\n\r\n\r\ndef main(documents: DocumentList) -> str:\r\n    if documents:\r\n        logging.info('Document id: %s', documents[0]['id'])\r\n"
    },
    "function": {
      "scriptFile": "__init__.py",
      "bindings": [
        {
          "type": "cosmosDBTrigger",
          "name": "documents",
          "direction": "in",
          "leaseContainerName": "leases",
          "connection": "",
          "databaseName": "",
          "containerName": "",
          "createLeaseContainerIfNotExists": true,
          "startFromBeginning": false
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "CosmosTrigger",
      "description": "$CosmosDBTrigger_description",
      "name": "Azure Cosmos DB trigger",
      "language": "Python",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "cosmosDB",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "databaseName",
        "containerName",
        "leaseContainerName",
        "createLeaseContainerIfNotExists"
      ],
      "filters": [
        "Python3"
      ]
    }
  },
  {
    "id": "CosmosDBTrigger-TypeScript",
    "runtime": "2",
    "files": {
      "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\r\n\r\nconst cosmosDBTrigger: AzureFunction = async function (context: Context, documents: any[]): Promise<void> {\r\n    if (!!documents && documents.length > 0) {\r\n        context.log('Document Id: ', documents[0].id);\r\n    }\r\n}\r\n\r\nexport default cosmosDBTrigger;\r\n",
      "sample.dat": "[\r\n\t{\r\n\t\t\"id\": \"sample\"\r\n\t}\r\n]"
    },
    "function": {
      "bindings": [
        {
          "type": "cosmosDBTrigger",
          "name": "documents",
          "direction": "in",
          "leaseContainerName": "leases",
          "connection": "",
          "databaseName": "",
          "containerName": "",
          "createLeaseContainerIfNotExists": true
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "CosmosTrigger",
      "description": "$CosmosDBTrigger_description",
      "name": "Azure Cosmos DB trigger",
      "language": "TypeScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "cosmosDB",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "databaseName",
        "containerName",
        "leaseContainerName",
        "createLeaseContainerIfNotExists"
      ]
    }
  },
  {
    "id": "DaprPublishOutputBinding-JavaScript",
    "runtime": "2",
    "files": {
      "index.js": "/**\r\n * Sample Dapr Publish Output Binding\r\n * See https://aka.ms/azure-function-dapr-publish-output-binding for more information about using this binding\r\n *\r\n * These tasks should be completed prior to running :\r\n *      1. Install Dapr\r\n * Run the app with below steps\r\n *      1. Start function app with Dapr: dapr run --app-id functionapp --app-port 3001 --dapr-http-port 3501 -- func host start\r\n *      2. Function will be invoked by Timer trigger and publish messages to message bus.\r\n * @param context The Azure Function runtime context\r\n */\r\nmodule.exports = async function (context) {\r\n    context.log(\"JavaScript DaprPublish output binding function processed a request.\");\r\n\r\n    const message = \"Invoked by Timer trigger: \" + `Hello, World! The time is ${new Date().toISOString()}`;\r\n    \r\n    context.bindings.pubEvent = {\r\n        payload: message\r\n    };\r\n};",
      "readme.md": "# DaprPublishOutputBinding - JavaScript\r\n\r\n`Dapr Publish Output Binding` - Dapr's output binding feature enables you to publish messages to external messaging systems (such as message queues, event hubs, or other event-driven systems) as part of your application's workflow. It's a way to send data from your Dapr application to external services.\r\n\r\n## How it works\r\n\r\nIn Dapr's pub-sub building block, the \"publish\" operation allows a Dapr-enabled application to send messages or events to a specific topic. When the application wishes to notify other components or services about an event or data update, it calls Dapr's publish API with the event data and the target topic. Dapr's sidecar takes care of delivering the message to all subscribed components, which can then react to the event as needed. This approach decouples the publisher from the subscribers, enabling a flexible, event-driven architecture where different parts of the application can independently react to and process events without direct dependencies on each other, fostering loose coupling and scalability.\r\n\r\nFor more information, see the official [docs](https://aka.ms/azure-function-dapr-publish-output-binding)."
    },
    "function": {
      "bindings": [
        {
          "schedule": "*/10 * * * * *",
          "name": "myTimer",
          "type": "timerTrigger",
          "direction": "in"
        },
        {
          "type": "daprPublish",
          "direction": "out",
          "name": "pubEvent",
          "pubsubname": "pubsub",
          "topic": "A"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "DaprPublishOutputBinding",
      "description": "$DaprPublishOutputBinding_description",
      "name": "Dapr Publish Output Binding",
      "language": "JavaScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "DaprPublishOutputBinding-PowerShell",
    "runtime": "2",
    "files": {
      "readme.md": "# DaprPublishOutputBinding - PowerShell\r\n\r\n`Dapr Publish Output Binding` - Dapr's output binding feature enables you to publish messages to external messaging systems (such as message queues, event hubs, or other event-driven systems) as part of your application's workflow. It's a way to send data from your Dapr application to external services.\r\n\r\n## How it works\r\n\r\nIn Dapr's pub-sub building block, the \"publish\" operation allows a Dapr-enabled application to send messages or events to a specific topic. When the application wishes to notify other components or services about an event or data update, it calls Dapr's publish API with the event data and the target topic. Dapr's sidecar takes care of delivering the message to all subscribed components, which can then react to the event as needed. This approach decouples the publisher from the subscribers, enabling a flexible, event-driven architecture where different parts of the application can independently react to and process events without direct dependencies on each other, fostering loose coupling and scalability.\r\n\r\nFor more information, see the official [docs](https://aka.ms/azure-function-dapr-publish-output-binding).",
      "run.ps1": "\r\nusing namespace System\r\nusing namespace Microsoft.Azure.WebJobs\r\nusing namespace Microsoft.Extensions.Logging\r\nusing namespace Microsoft.Azure.WebJobs.Extensions.Dapr\r\nusing namespace Newtonsoft.Json.Linq\r\n\r\n# Sample Dapr Publish Output Binding\r\n# See https://aka.ms/azure-function-dapr-publish-output-binding for more information about using this binding\r\n\r\n# These tasks should be completed prior to running :\r\n#      1. Install Dapr\r\n# Run the app with below steps\r\n#      1. Start function app with Dapr: dapr run --app-id functionapp --app-port 3001 --dapr-http-port 3501 -- func host start\r\n#      2. Function will be invoked by Timer trigger and publish messages to message bus.\r\n\r\nparam (\r\n    $myTimer\r\n)\r\n\r\nWrite-Host \"PowerShell DaprPublish output binding function processed a request.\"\r\n\r\n$currentTime = Get-Date\r\n\r\n$publishOutputBindingReqBody = @{\r\n    \"payload\" = \"Invoked by Timer trigger: Hello, World! The time is $currentTime\"\r\n}\r\n\r\nPush-OutputBinding -Name pubEvent -Value $publishOutputBindingReqBody"
    },
    "function": {
      "bindings": [
        {
          "schedule": "*/10 * * * * *",
          "name": "myTimer",
          "type": "timerTrigger",
          "direction": "in"
        },
        {
          "type": "daprPublish",
          "direction": "out",
          "name": "pubEvent",
          "pubsubname": "pubsub",
          "topic": "A"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "DaprPublishOutputBinding",
      "description": "$DaprPublishOutputBinding_description",
      "name": "Dapr Publish Output Binding",
      "language": "PowerShell",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "DaprPublishOutputBinding-Python",
    "runtime": "2",
    "files": {
      "readme.md": "# DaprPublishOutputBinding - Python\r\n\r\n`Dapr Publish Output Binding` - Dapr's output binding feature enables you to publish messages to external messaging systems (such as message queues, event hubs, or other event-driven systems) as part of your application's workflow. It's a way to send data from your Dapr application to external services.\r\n\r\n## How it works\r\n\r\nIn Dapr's pub-sub building block, the \"publish\" operation allows a Dapr-enabled application to send messages or events to a specific topic. When the application wishes to notify other components or services about an event or data update, it calls Dapr's publish API with the event data and the target topic. Dapr's sidecar takes care of delivering the message to all subscribed components, which can then react to the event as needed. This approach decouples the publisher from the subscribers, enabling a flexible, event-driven architecture where different parts of the application can independently react to and process events without direct dependencies on each other, fostering loose coupling and scalability.\r\n\r\nFor more information, see the official [docs](https://aka.ms/azure-function-dapr-publish-output-binding).",
      "__init__.py": "import datetime\r\nimport logging\r\nimport json\r\nimport azure.functions as func\r\n\r\ndef main(myTimer: func.TimerRequest,\r\n         pubEvent: func.Out[bytes]) -> None:\r\n    \"\"\"\r\n    Sample Dapr Publish Output Binding\r\n    See https://aka.ms/azure-function-dapr-publish-output-binding for more information about using this binding\r\n    \r\n    These tasks should be completed prior to running :\r\n         1. Install Dapr\r\n    Run the app with below steps\r\n         1. Start function app with Dapr: dapr run --app-id functionapp --app-port 3001 --dapr-http-port 3501 -- func host start\r\n         2. Function will be invoked by Timer trigger and publish messages to message bus.\r\n    \"\"\"\r\n    logging.info('Python  DaprPublish output binding function processed a request.')\r\n    payload = f\"Invoked by Timer trigger: Hello, World! The time is {datetime.datetime.now()}\"\r\n    pubEvent.set(json.dumps({\"payload\": payload}).encode('utf-8'))"
    },
    "function": {
      "bindings": [
        {
          "schedule": "*/10 * * * * *",
          "name": "myTimer",
          "type": "timerTrigger",
          "direction": "in"
        },
        {
          "type": "daprPublish",
          "direction": "out",
          "name": "pubEvent",
          "pubsubname": "pubsub",
          "topic": "A"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "DaprPublishOutputBinding",
      "description": "$DaprPublishOutputBinding_description",
      "name": "Dapr Publish Output Binding",
      "language": "Python",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "DaprServiceInvocationTrigger-JavaScript",
    "runtime": "2",
    "files": {
      "index.js": "/**\r\n * Sample Dapr Service Invocation Trigger\r\n * See https://aka.ms/azure-functions-dapr for more information about using this binding\r\n *\r\n * These tasks should be completed prior to running :\r\n *      1. Install Dapr\r\n * Run the app with below steps\r\n *      1. Start function app with Dapr: dapr run --app-id functionapp --app-port 3001 --dapr-http-port 3501 -- func host start\r\n *      2. Invoke function app by dapr cli: dapr invoke --app-id functionapp --method {yourFunctionName}  --data '{ \\\"data\\\": {\\\"value\\\": { \\\"orderId\\\": \\\"41\\\" } } }'\r\n * @param context The Azure Function runtime context\r\n */\r\nmodule.exports = async function (context) {\r\n    context.log(\"Azure function triggered by Dapr Service Invocation Trigger.\");\r\n    context.log(`Dapr service invocation trigger payload: ${JSON.stringify(context.bindings.payload)}`);\r\n};",
      "readme.md": "# DaprServiceInvocationTrigger - JavaScript\r\n\r\nUsing `Dapr Service Invocation Trigger`, your azure functions can reliably and securely communicate with other applications using the standard HTTP protocol.\r\n\r\n## How it works\r\n\r\n`Dapr Service Invocation Trigger` uses Dapr's API to invoke other services, and Dapr's sidecar handles routing, protocol translation, and retries, streamlining cross-service interaction.\r\n\r\nFor more information, see the official [docs](https://aka.ms/azure-function-dapr-trigger-service-invocation)."
    },
    "function": {
      "bindings": [
        {
          "type": "daprServiceInvocationTrigger",
          "name": "payload",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "DaprServiceInvocationTrigger",
      "description": "$DaprServiceInvocationTrigger_description",
      "name": "Dapr Service Invocation Trigger",
      "language": "JavaScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "DaprServiceInvocationTrigger-PowerShell",
    "runtime": "2",
    "files": {
      "readme.md": "# DaprServiceInvocationTrigger - PowerShell\r\n\r\nUsing `Dapr Service Invocation Trigger`, your azure functions can reliably and securely communicate with other applications using the standard HTTP protocol.\r\n\r\n## How it works\r\n\r\n`Dapr Service Invocation Trigger` uses Dapr's API to invoke other services, and Dapr's sidecar handles routing, protocol translation, and retries, streamlining cross-service interaction.\r\n\r\nFor more information, see the official [docs](https://aka.ms/azure-function-dapr-trigger-service-invocation).",
      "run.ps1": "using namespace System\r\nusing namespace Microsoft.Azure.WebJobs\r\nusing namespace Microsoft.Extensions.Logging\r\nusing namespace Microsoft.Azure.WebJobs.Extensions.Dapr\r\nusing namespace Newtonsoft.Json.Linq\r\n\r\n# Sample Dapr Binding Trigger\r\n# See https://aka.ms/azure-functions-dapr for more information about using this binding\r\n\r\n# These tasks should be completed prior to running :\r\n#      1. Install Dapr\r\n# Run the app with below steps\r\n#      1. Start function app with Dapr: dapr run --app-id functionapp --app-port 3001 --dapr-http-port 3501 -- func host start\r\n#      2. Invoke function app by dapr cli: dapr invoke --app-id functionapp --method {yourFunctionName}  --data '{ \\\"data\\\": {\\\"value\\\": { \\\"orderId\\\": \\\"41\\\" } } }'\r\n\r\nparam (\r\n    $payload\r\n)\r\n\r\nWrite-Host \"Azure function triggered by Dapr Service Invocation Trigger.\"\r\n\r\n$jsonString = $payload | ConvertTo-Json\r\nWrite-Host \"Dapr service invocation trigger payload: $jsonString\""
    },
    "function": {
      "bindings": [
        {
          "type": "daprServiceInvocationTrigger",
          "name": "payload",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "DaprServiceInvocationTrigger",
      "description": "$DaprServiceInvocationTrigger_description",
      "name": "Dapr Service Invocation Trigger",
      "language": "PowerShell",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "DaprServiceInvocationTrigger-Python",
    "runtime": "2",
    "files": {
      "readme.md": "# DaprServiceInvocationTrigger - Python\r\n\r\nUsing `Dapr Service Invocation Trigger`, your azure functions can reliably and securely communicate with other applications using the standard HTTP protocol.\r\n\r\n## How it works\r\n\r\n`Dapr Service Invocation Trigger` uses Dapr's API to invoke other services, and Dapr's sidecar handles routing, protocol translation, and retries, streamlining cross-service interaction.\r\n\r\nFor more information, see the official [docs](https://aka.ms/azure-function-dapr-trigger-service-invocation).",
      "__init__.py": "import logging\r\nimport json\r\n\r\n\r\ndef main(payload) -> None:\r\n    \"\"\"\r\n    Sample Dapr Binding Trigger\r\n    See https://aka.ms/azure-functions-dapr for more information about using this binding\r\n    \r\n    These tasks should be completed prior to running :\r\n         1. Install Dapr\r\n    Run the app with below steps\r\n         1. Start function app with Dapr: dapr run --app-id functionapp --app-port 3001 --dapr-http-port 3501 -- func host start\r\n         2. Invoke function app by dapr cli: dapr invoke --app-id functionapp --method {yourFunctionName}  --data '{ \\\"data\\\": {\\\"value\\\": { \\\"orderId\\\": \\\"41\\\" } } }'\r\n    \"\"\"\r\n\r\n    logging.info('Azure function triggered by Dapr Service Invocation Trigger.')\r\n    logging.info(f\"Dapr service invocation trigger payload: {payload}\")"
    },
    "function": {
      "bindings": [
        {
          "type": "daprServiceInvocationTrigger",
          "name": "payload",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "DaprServiceInvocationTrigger",
      "description": "$DaprServiceInvocationTrigger_description",
      "name": "Dapr Service Invocation Trigger",
      "language": "Python",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "DaprTopicTrigger-JavaScript",
    "runtime": "2",
    "files": {
      "index.js": "/**\r\n * Sample Dapr Service Invocation Trigger\r\n * See https://aka.ms/azure-functions-dapr for more information about using this binding\r\n *\r\n * These tasks should be completed prior to running :\r\n *      1. Install Dapr\r\n * Run the app with below steps\r\n *      1. Start function app with Dapr: dapr run --app-id functionapp --app-port 3001 --dapr-http-port 3501 -- func host start\r\n *      2. Invoke function app: dapr publish --pubsub pubsub --publish-app-id functionapp --topic A --data '{\\\"value\\\": { \\\"orderId\\\": \\\"42\\\" } }'\r\n * @param context The Azure Function runtime context\r\n */\r\nmodule.exports = async function (context) {\r\n    context.log(\"JavaScript DaprTopic trigger with DaprState output binding function processed a request from the Dapr Runtime.\");\r\n    context.log(`Data received on topic A: ${JSON.stringify(context.bindings.subEvent.data)}`);\r\n\r\n    context.bindings.value = context.bindings.subEvent.data;\r\n};",
      "readme.md": "# DaprServiceInvocationTrigger - Javascript\r\n\r\nUsing `Dapr Topic Trigger`, your azure functions can react to a message published on a Topic mentioned in your function.\r\n\r\n## How it works\r\n\r\n`Dapr Topic Trigger` uses Dapr's pub/sub API to receive messages published on a topic.\r\n\r\nPublish and subscribe (pub/sub) enables microservices to communicate with each other using messages for event-driven architectures.\r\n\r\nThe producer, or publisher, writes messages to an input channel and sends them to a topic, unaware which application will receive them.\r\nThe consumer, or subscriber, subscribes to the topic and receives messages from an output channel, unaware which service produced these messages.\r\n\r\nWhen using pub/sub in Dapr:\r\n\r\nYour service makes a network call to a Dapr pub/sub building block API.\r\nThe pub/sub building block makes calls into a Dapr pub/sub component that encapsulates a specific message broker.\r\nTo receive messages on a topic, Dapr subscribes to the pub/sub component on behalf of your service with a topic and delivers the messages to an endpoint on your service when they arrive.\r\n\r\nFor more information, see the official [docs](https://aka.ms/azure-function-dapr-trigger-topic)."
    },
    "function": {
      "bindings": [
        {
          "type": "daprTopicTrigger",
          "pubsubname": "pubsub",
          "topic": "A",
          "name": "subEvent",
          "direction": "in",
          "dataType": "string"
        },
        {
          "type": "daprState",
          "stateStore": "statestore",
          "direction": "out",
          "name": "value",
          "key": "product"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "DaprTopicTrigger",
      "description": "$DaprTopicTrigger_description",
      "name": "Dapr Topic Trigger",
      "language": "JavaScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "DaprTopicTrigger-PowerShell",
    "runtime": "2",
    "files": {
      "readme.md": "# DaprServiceInvocationTrigger - PowerShell\r\n\r\nUsing `Dapr Topic Trigger`, your azure functions can react to a message published on a Topic mentioned in your function.\r\n\r\n## How it works\r\n\r\n`Dapr Topic Trigger` uses Dapr's pub/sub API to receive messages published on a topic.\r\n\r\nPublish and subscribe (pub/sub) enables microservices to communicate with each other using messages for event-driven architectures.\r\n\r\nThe producer, or publisher, writes messages to an input channel and sends them to a topic, unaware which application will receive them.\r\nThe consumer, or subscriber, subscribes to the topic and receives messages from an output channel, unaware which service produced these messages.\r\n\r\nWhen using pub/sub in Dapr:\r\n\r\nYour service makes a network call to a Dapr pub/sub building block API.\r\nThe pub/sub building block makes calls into a Dapr pub/sub component that encapsulates a specific message broker.\r\nTo receive messages on a topic, Dapr subscribes to the pub/sub component on behalf of your service with a topic and delivers the messages to an endpoint on your service when they arrive.\r\n\r\nFor more information, see the official [docs](https://aka.ms/azure-function-dapr-trigger-topic).",
      "run.ps1": "\r\nusing namespace System\r\nusing namespace Microsoft.Azure.WebJobs\r\nusing namespace Microsoft.Extensions.Logging\r\nusing namespace Microsoft.Azure.WebJobs.Extensions.Dapr\r\nusing namespace Newtonsoft.Json.Linq\r\n\r\n# Sample Dapr Service Invocation Trigger\r\n# See https://aka.ms/azure-functions-dapr for more information about using this binding\r\n# \r\n# These tasks should be completed prior to running :\r\n#      1. Install Dapr\r\n# Run the app with below steps\r\n#      1. Start function app with Dapr: dapr run --app-id functionapp --app-port 3001 --dapr-http-port 3501 -- func host start\r\n#      2. Invoke function app: dapr publish --pubsub pubsub --publish-app-id functionapp --topic A --data '{\\\"value\\\": { \\\"orderId\\\": \\\"42\\\" } }'\r\n\r\nparam (\r\n    $subEvent\r\n)\r\n\r\nWrite-Host \"PowerShell DaprTopic trigger with DaprState output binding function processed a request from the Dapr Runtime.\"\r\n\r\nPush-OutputBinding -Name value -Value $subEvent[\"data\"]\r\n"
    },
    "function": {
      "bindings": [
        {
          "type": "daprTopicTrigger",
          "pubsubname": "pubsub",
          "topic": "A",
          "name": "subEvent",
          "direction": "in",
          "dataType": "string"
        },
        {
          "type": "daprState",
          "stateStore": "statestore",
          "direction": "out",
          "name": "value",
          "key": "product"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "DaprTopicTrigger",
      "description": "$DaprTopicTrigger_description",
      "name": "Dapr Topic Trigger",
      "language": "PowerShell",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "DaprTopicTrigger-Python",
    "runtime": "2",
    "files": {
      "readme.md": "# DaprServiceInvocationTrigger - Python\r\n\r\nUsing `Dapr Topic Trigger`, your azure functions can react to a message published on a Topic mentioned in your function.\r\n\r\n## How it works\r\n\r\n`Dapr Topic Trigger` uses Dapr's pub/sub API to receive messages published on a topic.\r\n\r\nPublish and subscribe (pub/sub) enables microservices to communicate with each other using messages for event-driven architectures.\r\n\r\nThe producer, or publisher, writes messages to an input channel and sends them to a topic, unaware which application will receive them.\r\nThe consumer, or subscriber, subscribes to the topic and receives messages from an output channel, unaware which service produced these messages.\r\n\r\nWhen using pub/sub in Dapr:\r\n\r\nYour service makes a network call to a Dapr pub/sub building block API.\r\nThe pub/sub building block makes calls into a Dapr pub/sub component that encapsulates a specific message broker.\r\nTo receive messages on a topic, Dapr subscribes to the pub/sub component on behalf of your service with a topic and delivers the messages to an endpoint on your service when they arrive.\r\n\r\nFor more information, see the official [docs](https://aka.ms/azure-function-dapr-trigger-topic).",
      "__init__.py": "import azure.functions as func\r\nimport logging\r\nimport json\r\n\r\n\r\ndef main(subEvent,\r\n         value: func.Out[bytes]) -> None:\r\n    \"\"\"\r\n    Sample Dapr Service Invocation Trigger\r\n    See https://aka.ms/azure-functions-dapr for more information about using this binding\r\n    \r\n    These tasks should be completed prior to running :\r\n         1. Install Dapr\r\n    Run the app with below steps\r\n         1. Start function app with Dapr: dapr run --app-id functionapp --app-port 3001 --dapr-http-port 3501 -- func host start\r\n         2. Invoke function app: dapr publish --pubsub pubsub --publish-app-id functionapp --topic A --data '{\\\"value\\\": { \\\"orderId\\\": \\\"42\\\" } }'\r\n    \"\"\"\r\n    logging.info('Python DaprTopic trigger with DaprState output binding function processed a request from the Dapr Runtime.')\r\n    payload_json = json.loads(subEvent)\r\n    value.set(json.dumps(payload_json[\"data\"]))\r\n"
    },
    "function": {
      "bindings": [
        {
          "type": "daprTopicTrigger",
          "pubsubname": "pubsub",
          "topic": "A",
          "name": "subEvent",
          "direction": "in",
          "dataType": "string"
        },
        {
          "type": "daprState",
          "stateStore": "statestore",
          "direction": "out",
          "name": "value",
          "key": "product"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "DaprTopicTrigger",
      "description": "$DaprTopicTrigger_description",
      "name": "Dapr Topic Trigger",
      "language": "Python",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "DurableFunctionsActivity-CSharp",
    "runtime": "2",
    "files": {
      "run.csx": "/*\r\n * This function is not intended to be invoked directly. Instead it will be\r\n * triggered by an orchestrator function.\r\n * \r\n * Before running this sample, please:\r\n * - create a Durable orchestration function\r\n * - create a Durable HTTP starter function\r\n */\r\n\r\n#r \"Microsoft.Azure.WebJobs.Extensions.DurableTask\"\r\n\r\nusing Microsoft.Azure.WebJobs.Extensions.DurableTask;\r\n\r\npublic static string Run(string name)\r\n{\r\n    return $\"Hello {name}!\";\r\n}"
    },
    "function": {
      "bindings": [
        {
          "name": "name",
          "type": "activityTrigger",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "Hello",
      "description": "$DurableFunctionsActivity_description",
      "name": "Durable Functions activity",
      "language": "C#",
      "category": [
        "$temp_category_core",
        "$temp_category_durableFunctions"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "DurableFunctionsActivity-JavaScript",
    "runtime": "2",
    "files": {
      "index.js": "﻿/*\r\n * This function is not intended to be invoked directly. Instead it will be\r\n * triggered by an orchestrator function.\r\n * \r\n * Before running this sample, please:\r\n * - create a Durable orchestration function\r\n * - create a Durable HTTP starter function\r\n * - run 'npm install durable-functions' from the wwwroot folder of your\r\n *   function app in Kudu\r\n */\r\n\r\nmodule.exports = async function (context) {\r\n    return `Hello ${context.bindings.name}!`;\r\n};"
    },
    "function": {
      "bindings": [
        {
          "name": "name",
          "type": "activityTrigger",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "Hello",
      "description": "$DurableFunctionsActivity_description",
      "name": "Durable Functions activity",
      "language": "JavaScript",
      "category": [
        "$temp_category_core",
        "$temp_category_durableFunctions"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "DurableFunctionsActivity-PowerShell",
    "runtime": "2",
    "files": {
      "run.ps1": "param($name)\r\n\r\n\"Hello $name!\"\r\n"
    },
    "function": {
      "bindings": [
        {
          "name": "name",
          "type": "activityTrigger",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "Hello",
      "description": "$DurableFunctionsActivity_description",
      "name": "Durable Functions activity",
      "language": "PowerShell",
      "category": [
        "$temp_category_core",
        "$temp_category_durableFunctions"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "DurableFunctionsActivity-Python",
    "runtime": "2",
    "files": {
      "__init__.py": "# This function is not intended to be invoked directly. Instead it will be\r\n# triggered by an orchestrator function.\r\n# Before running this sample, please:\r\n# - create a Durable orchestration function\r\n# - create a Durable HTTP starter function\r\n# - add azure-functions-durable to requirements.txt\r\n# - run pip install -r requirements.txt\r\n\r\nimport logging\r\n\r\n\r\ndef main(name: str) -> str:\r\n    return f\"Hello {name}!\"\r\n"
    },
    "function": {
      "scriptFile": "__init__.py",
      "bindings": [
        {
          "name": "name",
          "type": "activityTrigger",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "Hello",
      "description": "$DurableFunctionsActivity_description",
      "name": "Durable Functions activity",
      "language": "Python",
      "category": [
        "$temp_category_core",
        "$temp_category_durableFunctions"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "DurableFunctionsActivity-TypeScript",
    "runtime": "2",
    "files": {
      "index.ts": "﻿/*\r\n * This function is not intended to be invoked directly. Instead it will be\r\n * triggered by an orchestrator function.\r\n * \r\n * Before running this sample, please:\r\n * - create a Durable orchestration function\r\n * - create a Durable HTTP starter function\r\n * - run 'npm install durable-functions' from the wwwroot folder of your\r\n *   function app in Kudu\r\n */\r\n\r\nimport { AzureFunction, Context } from \"@azure/functions\"\r\n\r\nconst activityFunction: AzureFunction = async function (context: Context): Promise<string> {\r\n    return `Hello ${context.bindings.name}!`;\r\n};\r\n\r\nexport default activityFunction;\r\n"
    },
    "function": {
      "bindings": [
        {
          "name": "name",
          "type": "activityTrigger",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "Hello",
      "description": "$DurableFunctionsActivity_description",
      "name": "Durable Functions activity",
      "language": "TypeScript",
      "category": [
        "$temp_category_core",
        "$temp_category_durableFunctions"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "DurableFunctionsEntity-JavaScript",
    "runtime": "2",
    "files": {
      "index.js": "﻿/*\r\n* This function is not intended to be invoked directly. Instead it will be\r\n* triggered by a client function.\r\n* \r\n* Before running this sample, please:\r\n* - create a Durable entity HTTP function\r\n* - run 'npm install durable-functions' from the root of your app\r\n*/\r\n\r\nconst df = require(\"durable-functions\");\r\n\r\nmodule.exports = df.entity(function (context) {\r\n    const currentValue = context.df.getState(() => 0);\r\n    switch (context.df.operationName) {\r\n        case \"add\":\r\n            const amount = context.df.getInput();\r\n            context.df.setState(currentValue + amount);\r\n            break;\r\n        case \"reset\":\r\n            context.df.setState(0);\r\n            break;\r\n        case \"get\":\r\n            context.df.return(currentValue);\r\n            break;\r\n    }\r\n});"
    },
    "function": {
      "bindings": [
        {
          "name": "context",
          "type": "entityTrigger",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "Counter",
      "description": "$DurableFunctionsEntity_description",
      "name": "Durable Functions entity",
      "language": "JavaScript",
      "category": [
        "$temp_category_core",
        "$temp_category_durableFunctions"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "DurableFunctionsEntity-Python",
    "runtime": "2",
    "files": {
      "__init__.py": "import logging\r\nimport json\r\n\r\nfrom azure.durable_functions import DurableOrchestrationContext, Entity\r\n\r\n\r\ndef entity_function(context: DurableOrchestrationContext):\r\n\r\n    current_value = context.get_state(lambda: 0)\r\n    operation = context.operation_name\r\n    if operation == \"add\":\r\n        amount = context.get_input()\r\n        current_value += amount\r\n        context.set_result(current_value)\r\n    elif operation == \"reset\":\r\n        current_value = 0\r\n    elif operation == \"get\":\r\n        context.set_result(current_value)\r\n    \r\n    context.set_state(current_value)\r\n\r\nmain = Entity.create(entity_function)"
    },
    "function": {
      "scriptFile": "__init__.py",
      "bindings": [
        {
          "name": "context",
          "type": "entityTrigger",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "DurableFunctionsEntityPy",
      "description": "$DurableFunctionsEntity_description",
      "name": "Durable Functions entity",
      "language": "Python",
      "category": [
        "$temp_category_core",
        "$temp_category_durableFunctions"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "DurableFunctionsEntity-TypeScript",
    "runtime": "2",
    "files": {
      "index.ts": "﻿/*\r\n* This function is not intended to be invoked directly. Instead it will be\r\n* triggered by a client function.\r\n* \r\n* Before running this sample, please:\r\n* - create a Durable entity HTTP function\r\n* - run 'npm install durable-functions' from the root of your app\r\n*/\r\n\r\nimport * as df from \"durable-functions\"\r\n\r\nconst entity = df.entity(function (context) {\r\n    const currentValue = context.df.getState(() => 0) as number;\r\n    switch (context.df.operationName) {\r\n        case \"add\":\r\n            const amount = context.df.getInput() as number;\r\n            context.df.setState(currentValue + amount);\r\n            break;\r\n        case \"reset\":\r\n            context.df.setState(0);\r\n            break;\r\n    }\r\n});\r\n\r\nexport default entity;"
    },
    "function": {
      "bindings": [
        {
          "name": "context",
          "type": "entityTrigger",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "Counter",
      "description": "$DurableFunctionsEntity_description",
      "name": "Durable Functions entity",
      "language": "TypeScript",
      "category": [
        "$temp_category_core",
        "$temp_category_durableFunctions"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "DurableFunctionsEntityClass-CSharp",
    "runtime": "2",
    "files": {
      "run.csx": "/*\r\n* This function is not intended to be invoked directly. Instead it will be\r\n* triggered by a client function.\r\n* \r\n* Before running this sample, please:\r\n* - create a Durable entity HTTP function\r\n*/\r\n\r\n#r \"Microsoft.Azure.WebJobs.Extensions.DurableTask\"\r\n#r \"Newtonsoft.Json\"\r\n\r\nusing Newtonsoft.Json;\r\nusing Microsoft.Azure.WebJobs.Extensions.DurableTask;\r\n\r\npublic class Counter\r\n{\r\n\r\n    [JsonProperty(\"value\")]\r\n    public int CurrentValue { get; set; }\r\n\r\n    public void Add(int amount) => this.CurrentValue += amount;\r\n\r\n    public void Reset() => this.CurrentValue = 0;\r\n\r\n    public int Get() => this.CurrentValue;\r\n}\r\n\r\npublic static void Run(IDurableEntityContext context)\r\n    => context.DispatchAsync<Counter>();"
    },
    "function": {
      "bindings": [
        {
          "name": "context",
          "type": "entityTrigger",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "Counter",
      "description": "$DurableFunctionsEntityClass_description",
      "name": "Durable Functions entity (class)",
      "language": "C#",
      "category": [
        "$temp_category_durableFunctions"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "DurableFunctionsEntityFunction-CSharp",
    "runtime": "2",
    "files": {
      "run.csx": "/*\r\n* This function is not intended to be invoked directly. Instead it will be\r\n* triggered by a client function.\r\n* \r\n* Before running this sample, please:\r\n* - create a Durable entity HTTP function\r\n*/\r\n\r\n#r \"Microsoft.Azure.WebJobs.Extensions.DurableTask\"\r\n\r\nusing Microsoft.Azure.WebJobs.Extensions.DurableTask;\r\n\r\npublic static void Run(IDurableEntityContext context)\r\n{\r\n    switch (context.OperationName.ToLowerInvariant())\r\n    {\r\n        case \"add\":\r\n            context.SetState(context.GetState<int>() + context.GetInput<int>());\r\n            break;\r\n        case \"reset\":\r\n            context.SetState(0);\r\n            break;\r\n        case \"get\":\r\n            context.Return(context.GetState<int>());\r\n            break;\r\n    }\r\n}"
    },
    "function": {
      "bindings": [
        {
          "name": "context",
          "type": "entityTrigger",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "Counter",
      "description": "$DurableFunctionsEntityFunction_description",
      "name": "Durable Functions entity (function)",
      "language": "C#",
      "category": [
        "$temp_category_durableFunctions"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "DurableFunctionsEntityHttpStart-CSharp",
    "runtime": "2",
    "files": {
      "run.csx": "#r \"Microsoft.Azure.WebJobs.Extensions.DurableTask\"\r\n#r \"Newtonsoft.Json\"\r\n\r\nusing System.Net;\r\nusing Newtonsoft.Json.Linq;\r\nusing Microsoft.Azure.WebJobs.Extensions.DurableTask;\r\nusing Microsoft.AspNetCore.Mvc;\r\n\r\npublic static async Task<IActionResult> Run(\r\n    HttpRequest req,\r\n    IDurableEntityClient client,\r\n    string entityKey)\r\n{\r\n    var entityId = new EntityId(\"Counter\", entityKey);\r\n\r\n    if (req.Method.Equals(\"POST\"))\r\n    {\r\n        await client.SignalEntityAsync(entityId, \"add\", 1);\r\n        return new OkObjectResult(\"Added to the entity\");\r\n    }\r\n\r\n    EntityStateResponse<JToken> stateResponse = await client.ReadEntityStateAsync<JToken>(entityId);\r\n    return new OkObjectResult(stateResponse);\r\n}"
    },
    "function": {
      "bindings": [
        {
          "authLevel": "function",
          "name": "req",
          "type": "httpTrigger",
          "direction": "in",
          "route": "{entityKey}",
          "methods": [
            "post",
            "get"
          ]
        },
        {
          "name": "$return",
          "type": "http",
          "direction": "out"
        },
        {
          "name": "client",
          "type": "durableClient",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "DurableFunctionsEntityHttpStart",
      "description": "$DurableFunctionsHttpStart_description",
      "name": "Durable Functions Entity HTTP starter",
      "language": "C#",
      "category": [
        "$temp_category_core",
        "$temp_category_durableFunctions"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "DurableFunctionsEntityHttpStart-JavaScript",
    "runtime": "2",
    "files": {
      "index.js": "﻿const df = require(\"durable-functions\");\r\n\r\nmodule.exports = async function (context, req) {\r\n    const client = df.getClient(context);\r\n    const id = context.bindingData.id;\r\n    const entityId = new df.EntityId(\"Counter\", id);\r\n\r\n    if (req.method === \"POST\") {\r\n        // increment value\r\n        await client.signalEntity(entityId, \"add\", 1);\r\n    } else {\r\n        // reads current state of entity\r\n        const stateResponse = await client.readEntityState(entityId);\r\n        return { body: stateResponse.entityState };\r\n    }\r\n};"
    },
    "function": {
      "bindings": [
        {
          "authLevel": "function",
          "name": "req",
          "type": "httpTrigger",
          "direction": "in",
          "route": "counters/{id}",
          "methods": [
            "post",
            "get"
          ]
        },
        {
          "name": "$return",
          "type": "http",
          "direction": "out"
        },
        {
          "name": "starter",
          "type": "orchestrationClient",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "DurableFunctionsEntityHttpStart",
      "description": "$DurableFunctionsHttpStart_description",
      "name": "Durable Functions Entity HTTP starter",
      "language": "JavaScript",
      "category": [
        "$temp_category_core",
        "$temp_category_durableFunctions"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "DurableFunctionsEntityHttpStart-TypeScript",
    "runtime": "2",
    "files": {
      "index.ts": "﻿import { AzureFunction, Context, HttpRequest } from \"@azure/functions\"\r\nimport * as df from \"durable-functions\"\r\n\r\nconst httpStart: AzureFunction = async function (context: Context, req: HttpRequest) {\r\n    const client = df.getClient(context);\r\n    const id: string = req.params.id;\r\n    const entityId = new df.EntityId(\"Counter\", id);\r\n\r\n    if (req.method === \"POST\") {\r\n        // increment value\r\n        await client.signalEntity(entityId, \"add\", 1);\r\n    } else {\r\n        // reads current state of entity\r\n        const stateResponse = await client.readEntityState<number>(entityId);\r\n        return { body: stateResponse.entityState };\r\n    }\r\n};\r\n\r\nexport default httpStart;"
    },
    "function": {
      "bindings": [
        {
          "authLevel": "anonymous",
          "name": "req",
          "type": "httpTrigger",
          "direction": "in",
          "route": "counters/{id}",
          "methods": [
            "post",
            "get"
          ]
        },
        {
          "name": "$return",
          "type": "http",
          "direction": "out"
        },
        {
          "name": "client",
          "type": "durableClient",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "DurableFunctionsEntityHttpStart",
      "description": "$DurableFunctionsHttpStart_description",
      "name": "Durable Functions Entity HTTP starter",
      "language": "TypeScript",
      "category": [
        "$temp_category_core",
        "$temp_category_durableFunctions"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": [
        "authLevel"
      ]
    }
  },
  {
    "id": "DurableFunctionsHttpStart-CSharp",
    "runtime": "2",
    "files": {
      "run.csx": "#r \"Microsoft.Azure.WebJobs.Extensions.DurableTask\"\r\n#r \"Newtonsoft.Json\"\r\n\r\nusing System.Net;\r\nusing Microsoft.Azure.WebJobs.Extensions.DurableTask;\r\n\r\npublic static async Task<HttpResponseMessage> Run(\r\n    HttpRequestMessage req,\r\n    IDurableOrchestrationClient starter,\r\n    string functionName,\r\n    ILogger log)\r\n{\r\n    // Function input comes from the request content.\r\n    dynamic eventData = await req.Content.ReadAsAsync<object>();\r\n\r\n    // Pass the function name as part of the route \r\n    string instanceId = await starter.StartNewAsync(functionName, eventData);\r\n\r\n    log.LogInformation($\"Started orchestration with ID = '{instanceId}'.\");\r\n\r\n    return starter.CreateCheckStatusResponse(req, instanceId);\r\n}"
    },
    "function": {
      "bindings": [
        {
          "authLevel": "function",
          "name": "req",
          "type": "httpTrigger",
          "direction": "in",
          "route": "orchestrators/{functionName}",
          "methods": [
            "post",
            "get"
          ]
        },
        {
          "name": "$return",
          "type": "http",
          "direction": "out"
        },
        {
          "name": "starter",
          "type": "durableClient",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "DurableFunctionsHttpStart",
      "description": "$DurableFunctionsHttpStart_description",
      "name": "Durable Functions HTTP starter",
      "language": "C#",
      "category": [
        "$temp_category_core",
        "$temp_category_durableFunctions"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "DurableFunctionsHttpStart-JavaScript",
    "runtime": "2",
    "files": {
      "index.js": "﻿const df = require(\"durable-functions\");\r\n\r\nmodule.exports = async function (context, req) {\r\n    const client = df.getClient(context);\r\n    const instanceId = await client.startNew(req.params.functionName, undefined, req.body);\r\n\r\n    context.log(`Started orchestration with ID = '${instanceId}'.`);\r\n\r\n    return client.createCheckStatusResponse(context.bindingData.req, instanceId);\r\n};"
    },
    "function": {
      "bindings": [
        {
          "authLevel": "function",
          "name": "req",
          "type": "httpTrigger",
          "direction": "in",
          "route": "orchestrators/{functionName}",
          "methods": [
            "post",
            "get"
          ]
        },
        {
          "name": "$return",
          "type": "http",
          "direction": "out"
        },
        {
          "name": "starter",
          "type": "orchestrationClient",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "DurableFunctionsHttpStart",
      "description": "$DurableFunctionsHttpStart_description",
      "name": "Durable Functions HTTP starter",
      "language": "JavaScript",
      "category": [
        "$temp_category_core",
        "$temp_category_durableFunctions"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": [
        "authLevel"
      ]
    }
  },
  {
    "id": "DurableFunctionsHttpStart-PowerShell",
    "runtime": "2",
    "files": {
      "run.ps1": "using namespace System.Net\r\n\r\nparam($Request, $TriggerMetadata)\r\n\r\n$FunctionName = $Request.Params.FunctionName\r\n$InstanceId = Start-DurableOrchestration -FunctionName $FunctionName\r\nWrite-Host \"Started orchestration with ID = '$InstanceId'\"\r\n\r\n$Response = New-DurableOrchestrationCheckStatusResponse -Request $Request -InstanceId $InstanceId\r\nPush-OutputBinding -Name Response -Value $Response\r\n"
    },
    "function": {
      "bindings": [
        {
          "authLevel": "function",
          "name": "Request",
          "type": "httpTrigger",
          "direction": "in",
          "route": "orchestrators/{FunctionName}",
          "methods": [
            "post",
            "get"
          ]
        },
        {
          "type": "http",
          "direction": "out",
          "name": "Response"
        },
        {
          "name": "starter",
          "type": "durableClient",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "DurableFunctionsHttpStart",
      "description": "$DurableFunctionsHttpStart_description",
      "name": "Durable Functions HTTP starter",
      "language": "PowerShell",
      "category": [
        "$temp_category_core",
        "$temp_category_durableFunctions"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": [
        "authLevel"
      ]
    }
  },
  {
    "id": "DurableFunctionsHttpStart-Python",
    "runtime": "2",
    "files": {
      "__init__.py": "# This function an HTTP starter function for Durable Functions.\r\n# Before running this sample, please:\r\n# - create a Durable orchestration function\r\n# - create a Durable activity function (default name is \"Hello\")\r\n# - add azure-functions-durable to requirements.txt\r\n# - run pip install -r requirements.txt\r\n \r\nimport logging\r\n\r\nfrom azure.functions import HttpRequest, HttpResponse\r\nfrom azure.durable_functions import DurableOrchestrationClient\r\n\r\n\r\nasync def main(req: HttpRequest, starter: str) -> HttpResponse:\r\n    client = DurableOrchestrationClient(starter)\r\n    instance_id = await client.start_new(req.route_params[\"functionName\"], None, None)\r\n\r\n    logging.info(f\"Started orchestration with ID = '{instance_id}'.\")\r\n\r\n    return client.create_check_status_response(req, instance_id)"
    },
    "function": {
      "scriptFile": "__init__.py",
      "bindings": [
        {
          "authLevel": "function",
          "name": "req",
          "type": "httpTrigger",
          "direction": "in",
          "route": "orchestrators/{functionName}",
          "methods": [
            "post",
            "get"
          ]
        },
        {
          "name": "$return",
          "type": "http",
          "direction": "out"
        },
        {
          "name": "starter",
          "type": "durableClient",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "DurableFunctionsHttpStart",
      "description": "$DurableFunctionsHttpStart_description",
      "name": "Durable Functions HTTP starter",
      "language": "Python",
      "category": [
        "$temp_category_core",
        "$temp_category_durableFunctions"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": [
        "authLevel"
      ]
    }
  },
  {
    "id": "DurableFunctionsHttpStart-TypeScript",
    "runtime": "2",
    "files": {
      "index.ts": "﻿import * as df from \"durable-functions\"\r\nimport { AzureFunction, Context, HttpRequest } from \"@azure/functions\"\r\n\r\nconst httpStart: AzureFunction = async function (context: Context, req: HttpRequest): Promise<any> {\r\n    const client = df.getClient(context);\r\n    const instanceId = await client.startNew(req.params.functionName, undefined, req.body);\r\n\r\n    context.log(`Started orchestration with ID = '${instanceId}'.`);\r\n\r\n    return client.createCheckStatusResponse(context.bindingData.req, instanceId);\r\n};\r\n\r\nexport default httpStart;\r\n"
    },
    "function": {
      "bindings": [
        {
          "authLevel": "function",
          "name": "req",
          "type": "httpTrigger",
          "direction": "in",
          "route": "orchestrators/{functionName}",
          "methods": [
            "post",
            "get"
          ]
        },
        {
          "name": "$return",
          "type": "http",
          "direction": "out"
        },
        {
          "name": "starter",
          "type": "orchestrationClient",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "DurableFunctionsHttpStart",
      "description": "$DurableFunctionsHttpStart_description",
      "name": "Durable Functions HTTP starter",
      "language": "TypeScript",
      "category": [
        "$temp_category_core",
        "$temp_category_durableFunctions"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": [
        "authLevel"
      ]
    }
  },
  {
    "id": "DurableFunctionsOrchestrator-CSharp",
    "runtime": "2",
    "files": {
      "run.csx": "/*\r\n * This function is not intended to be invoked directly. Instead it will be\r\n * triggered by an HTTP starter function.\r\n * \r\n * Before running this sample, please:\r\n * - create a Durable activity function (default name is \"Hello\")\r\n * - create a Durable HTTP starter function\r\n */\r\n\r\n#r \"Microsoft.Azure.WebJobs.Extensions.DurableTask\"\r\n\r\nusing Microsoft.Azure.WebJobs.Extensions.DurableTask;\r\n\r\npublic static async Task<List<string>> Run(IDurableOrchestrationContext context)\r\n{\r\n    var outputs = new List<string>();\r\n\r\n    // Replace \"Hello\" with the name of your Durable Activity Function.\r\n    outputs.Add(await context.CallActivityAsync<string>(\"Hello\", \"Tokyo\"));\r\n    outputs.Add(await context.CallActivityAsync<string>(\"Hello\", \"Seattle\"));\r\n    outputs.Add(await context.CallActivityAsync<string>(\"Hello\", \"London\"));\r\n\r\n    // returns [\"Hello Tokyo!\", \"Hello Seattle!\", \"Hello London!\"]\r\n    return outputs;\r\n}"
    },
    "function": {
      "bindings": [
        {
          "name": "context",
          "type": "orchestrationTrigger",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "DurableFunctionsOrchestrator",
      "description": "$DurableFunctionsOrchestrator_description",
      "name": "Durable Functions orchestrator",
      "language": "C#",
      "category": [
        "$temp_category_core",
        "$temp_category_durableFunctions"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "DurableFunctionsOrchestrator-JavaScript",
    "runtime": "2",
    "files": {
      "index.js": "﻿/*\r\n * This function is not intended to be invoked directly. Instead it will be\r\n * triggered by an HTTP starter function.\r\n * \r\n * Before running this sample, please:\r\n * - create a Durable activity function (default name is \"Hello\")\r\n * - create a Durable HTTP starter function\r\n * - run 'npm install durable-functions' from the wwwroot folder of your \r\n *    function app in Kudu\r\n */\r\n\r\nconst df = require(\"durable-functions\");\r\n\r\nmodule.exports = df.orchestrator(function* (context) {\r\n    const outputs = [];\r\n\r\n    // Replace \"Hello\" with the name of your Durable Activity Function.\r\n    outputs.push(yield context.df.callActivity(\"Hello\", \"Tokyo\"));\r\n    outputs.push(yield context.df.callActivity(\"Hello\", \"Seattle\"));\r\n    outputs.push(yield context.df.callActivity(\"Hello\", \"London\"));\r\n\r\n    // returns [\"Hello Tokyo!\", \"Hello Seattle!\", \"Hello London!\"]\r\n    return outputs;\r\n});"
    },
    "function": {
      "bindings": [
        {
          "name": "context",
          "type": "orchestrationTrigger",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "DurableFunctionsOrchestratorJS",
      "description": "$DurableFunctionsOrchestrator_description",
      "name": "Durable Functions orchestrator",
      "language": "JavaScript",
      "category": [
        "$temp_category_core",
        "$temp_category_durableFunctions"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "DurableFunctionsOrchestrator-PowerShell",
    "runtime": "2",
    "files": {
      "run.ps1": "param($Context)\r\n\r\n$output = @()\r\n\r\n$output += Invoke-DurableActivity -FunctionName 'Hello' -Input 'Tokyo'\r\n$output += Invoke-DurableActivity -FunctionName 'Hello' -Input 'Seattle'\r\n$output += Invoke-DurableActivity -FunctionName 'Hello' -Input 'London'\r\n\r\n$output\r\n"
    },
    "function": {
      "bindings": [
        {
          "name": "Context",
          "type": "orchestrationTrigger",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "DurableFunctionsOrchestrator",
      "description": "$DurableFunctionsOrchestrator_description",
      "name": "Durable Functions orchestrator",
      "language": "PowerShell",
      "category": [
        "$temp_category_core",
        "$temp_category_durableFunctions"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "DurableFunctionsOrchestrator-Python",
    "runtime": "2",
    "files": {
      "__init__.py": "# This function is not intended to be invoked directly. Instead it will be\r\n# triggered by an HTTP starter function.\r\n# Before running this sample, please:\r\n# - create a Durable activity function (default name is \"Hello\")\r\n# - create a Durable HTTP starter function\r\n# - add azure-functions-durable to requirements.txt\r\n# - run pip install -r requirements.txt\r\n\r\nimport logging\r\nimport json\r\n\r\nfrom azure.durable_functions import DurableOrchestrationContext, Orchestrator\r\n\r\n\r\ndef orchestrator_function(context: DurableOrchestrationContext):\r\n    result1 = yield context.call_activity('Hello', \"Tokyo\")\r\n    result2 = yield context.call_activity('Hello', \"Seattle\")\r\n    result3 = yield context.call_activity('Hello', \"London\")\r\n    return [result1, result2, result3]\r\n\r\nmain = Orchestrator.create(orchestrator_function)"
    },
    "function": {
      "scriptFile": "__init__.py",
      "bindings": [
        {
          "name": "context",
          "type": "orchestrationTrigger",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "DurableFunctionsOrchestrator",
      "description": "$DurableFunctionsOrchestrator_description",
      "name": "Durable Functions orchestrator",
      "language": "Python",
      "category": [
        "$temp_category_core",
        "$temp_category_durableFunctions"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "DurableFunctionsOrchestrator-TypeScript",
    "runtime": "2",
    "files": {
      "index.ts": "﻿/*\r\n * This function is not intended to be invoked directly. Instead it will be\r\n * triggered by an HTTP starter function.\r\n * \r\n * Before running this sample, please:\r\n * - create a Durable activity function (default name is \"Hello\")\r\n * - create a Durable HTTP starter function\r\n * - run 'npm install durable-functions' from the wwwroot folder of your \r\n *    function app in Kudu\r\n */\r\n\r\nimport * as df from \"durable-functions\"\r\n\r\nconst orchestrator = df.orchestrator(function* (context) {\r\n    const outputs = [];\r\n\r\n    // Replace \"Hello\" with the name of your Durable Activity Function.\r\n    outputs.push(yield context.df.callActivity(\"Hello\", \"Tokyo\"));\r\n    outputs.push(yield context.df.callActivity(\"Hello\", \"Seattle\"));\r\n    outputs.push(yield context.df.callActivity(\"Hello\", \"London\"));\r\n\r\n    // returns [\"Hello Tokyo!\", \"Hello Seattle!\", \"Hello London!\"]\r\n    return outputs;\r\n});\r\n\r\nexport default orchestrator;\r\n"
    },
    "function": {
      "bindings": [
        {
          "name": "context",
          "type": "orchestrationTrigger",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "DurableFunctionsOrchestratorTS",
      "description": "$DurableFunctionsOrchestrator_description",
      "name": "Durable Functions orchestrator",
      "language": "TypeScript",
      "category": [
        "$temp_category_core",
        "$temp_category_durableFunctions"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "EventGridBlobTrigger-JavaScript",
    "runtime": "2",
    "files": {
      "index.js": "module.exports = async function (context, myEventGridBlob) {\r\n    context.log(\"JavaScript blob storage trigger (using Event Grid) function processed blob \\n Blob:\", context.bindingData.blobTrigger, \"\\n Blob Size:\", myEventGridBlob.length, \"Bytes\");\r\n};"
    },
    "function": {
      "bindings": [
        {
          "name": "myEventGridBlob",
          "type": "blobTrigger",
          "direction": "in",
          "path": "samples-workitems/{name}",
          "source": "EventGrid",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "EventGridBlobTrigger",
      "description": "$BlobTrigger_description",
      "name": "Azure Blob Storage Trigger (using Event Grid)",
      "language": "JavaScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "blob",
      "enabledInTryMode": true,
      "userPrompt": [
        "connection",
        "path"
      ]
    }
  },
  {
    "id": "EventGridBlobTrigger-PowerShell",
    "runtime": "2",
    "files": {
      "readme.md": "# EventGridBlobTrigger - PowerShell\r\n\r\nThe `EventGridBlobTrigger` makes it incredibly easy to react to new Blobs using [Event Grid](https://learn.microsoft.com/en-us/azure/event-grid/overview).\r\nThis sample demonstrates a simple use case of processing data from a given Blob using PowerShell.\r\n\r\n## How it works\r\n\r\nFor a `EventGridBlobTrigger` to work, you provide a path which dictates where the blobs are located inside your container, and can also help restrict the types of blobs you wish to return. For instance, you can set the path to `samples/{name}.png` to restrict the trigger to only the samples path and only blobs with \".png\" at the end of their name.\r\n\r\n## Learn more\r\n\r\nFor more information, please check out [this tutorial](https://learn.microsoft.com/en-us/azure/azure-functions/functions-event-grid-blob-trigger?tabs=isolated-process%2Cnodejs-v4&pivots=programming-language-powershell) on this new version of the Blob Storage trigger.\r\n",
      "run.ps1": "# Input bindings are passed in via param block.\r\nparam([byte[]] $InputBlob, $TriggerMetadata)\r\n\r\n# Write out the blob name and size to the information log.\r\nWrite-Host \"PowerShell Blob trigger function Processed blob! Name: $($TriggerMetadata.Name) Size: $($InputBlob.Length) bytes\"\r\n",
      "sample.dat": "samples-workitems/workitem.txt"
    },
    "function": {
      "bindings": [
        {
          "name": "InputBlob",
          "type": "blobTrigger",
          "direction": "in",
          "path": "samples-workitems/{name}",
          "source": "EventGrid",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "EventGridBlobTrigger",
      "description": "$BlobTrigger_description",
      "name": "Azure Blob Storage Trigger (using Event Grid)",
      "language": "PowerShell",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "blob",
      "enabledInTryMode": true,
      "userPrompt": [
        "connection",
        "path"
      ]
    }
  },
  {
    "id": "EventGridBlobTrigger-Python",
    "runtime": "2",
    "files": {
      "readme.md": "# EventGridBlobTrigger - Python\r\n\r\nThe `EventGridBlobTrigger` makes it incredibly easy to react to new Blobs using [Event Grid](https://learn.microsoft.com/en-us/azure/event-grid/overview).\r\nThis sample demonstrates a simple use case of processing data from a given Blob using PowerShell.\r\n\r\n## How it works\r\n\r\nFor a `EventGridBlobTrigger` to work, you provide a path which dictates where the blobs are located inside your container, and can also help restrict the types of blobs you wish to return. For instance, you can set the path to `samples/{name}.png` to restrict the trigger to only the samples path and only blobs with \".png\" at the end of their name.\r\n\r\n## Learn more\r\n\r\nFor more information, please check out [this tutorial](https://learn.microsoft.com/en-us/azure/azure-functions/functions-event-grid-blob-trigger?tabs=isolated-process%2Cnodejs-v4&pivots=programming-language-python) on this new version of the Blob Storage trigger.\r\n",
      "sample.dat": "samples-workitems/workitem.txt",
      "__init__.py": "import logging\r\n\r\nfrom azure.functions import InputStream\r\n\r\n\r\ndef main(myblob: InputStream):\r\n    logging.info(f\"Python blob trigger function processed blob \\n\"\r\n                 f\"Name: {myblob.name}\\n\"\r\n                 f\"Blob Size: {myblob.length} bytes\")\r\n"
    },
    "function": {
      "scriptFile": "__init__.py",
      "bindings": [
        {
          "name": "myblob",
          "type": "blobTrigger",
          "direction": "in",
          "path": "samples-workitems/{name}",
          "source": "EventGrid",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "EventGridBlobTrigger",
      "description": "$BlobTrigger_description",
      "name": "Azure Blob Storage Trigger (using Event Grid)",
      "language": "Python",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "blob",
      "enabledInTryMode": true,
      "userPrompt": [
        "connection",
        "path"
      ],
      "filters": [
        "Python3"
      ]
    }
  },
  {
    "id": "EventGridBlobTrigger-TypeScript",
    "runtime": "2",
    "files": {
      "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\r\n\r\nconst blobTrigger: AzureFunction = async function (context: Context, myBlob: any): Promise<void> {\r\n    context.log(\"Blob trigger function processed blob \\n Name:\", context.bindingData.name, \"\\n Blob Size:\", myBlob.length, \"Bytes\");\r\n};\r\n\r\nexport default blobTrigger;\r\n",
      "readme.md": "# EventGridBlobTrigger - TypeScript\r\n\r\nThe `EventGridBlobTrigger` makes it incredibly easy to react to new Blobs using [Event Grid](https://learn.microsoft.com/en-us/azure/event-grid/overview).\r\nThis sample demonstrates a simple use case of processing data from a given Blob using PowerShell.\r\n\r\n## How it works\r\n\r\nFor a `EventGridBlobTrigger` to work, you provide a path which dictates where the blobs are located inside your container, and can also help restrict the types of blobs you wish to return. For instance, you can set the path to `samples/{name}.png` to restrict the trigger to only the samples path and only blobs with \".png\" at the end of their name.\r\n\r\n## Learn more\r\n\r\nFor more information, please check out [this tutorial](https://learn.microsoft.com/en-us/azure/azure-functions/functions-event-grid-blob-trigger?tabs=isolated-process%2Cnodejs-v4&pivots=programming-language-typescript) on this new version of the Blob Storage trigger.\r\n",
      "sample.dat": "samples-workitems/workitem.txt"
    },
    "function": {
      "bindings": [
        {
          "name": "myBlob",
          "type": "blobTrigger",
          "direction": "in",
          "path": "samples-workitems/{name}",
          "source": "EventGrid",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "EventGridBlobTrigger",
      "description": "$BlobTrigger_description",
      "name": "Azure Blob Storage Trigger (using Event Grid)",
      "language": "TypeScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "blob",
      "enabledInTryMode": true,
      "userPrompt": [
        "connection",
        "path"
      ]
    }
  },
  {
    "id": "EventGridCloudEventTrigger-CSharp",
    "runtime": "2",
    "files": {
      "run.csx": "#r \"Azure.Messaging\"\r\n\r\nusing Azure.Messaging;\r\n\r\npublic static void Run(CloudEvent cloudEvent, ILogger log)\r\n{\r\n    log.LogInformation(\"Event received {type} {subject}: {data}\", cloudEvent.Type, cloudEvent.Subject, cloudEvent.Data.ToString());\r\n}\r\n",
      "sample.dat": "{\r\n    \"specversion\": \"1.0\",\r\n    \"type\": \"Microsoft.Storage.BlobCreated\",  \r\n    \"source\": \"/subscriptions/{subscription-id}/resourceGroups/{resource-group}/providers/Microsoft.Storage/storageAccounts/{storage-account}\",\r\n    \"id\": \"9aeb0fdf-c01e-0131-0922-9eb54906e209\",\r\n    \"time\": \"2019-11-18T15:13:39.4589254Z\",\r\n    \"subject\": \"blobServices/default/containers/{storage-container}/blobs/{new-file}\",\r\n    \"dataschema\": \"#\",\r\n    \"data\": {\r\n        \"api\": \"PutBlockList\",\r\n        \"clientRequestId\": \"4c5dd7fb-2c48-4a27-bb30-5361b5de920a\",\r\n        \"requestId\": \"9aeb0fdf-c01e-0131-0922-9eb549000000\",\r\n        \"eTag\": \"0x8D76C39E4407333\",\r\n        \"contentType\": \"image/png\",\r\n        \"contentLength\": 30699,\r\n        \"blobType\": \"BlockBlob\",\r\n        \"url\": \"https://gridtesting.blob.core.windows.net/testcontainer/{new-file}\",\r\n        \"sequencer\": \"000000000000000000000000000099240000000000c41c18\",\r\n        \"storageDiagnostics\": {\r\n            \"batchId\": \"681fe319-3006-00a8-0022-9e7cde000000\"\r\n        }\r\n    }\r\n}"
    },
    "function": {
      "bindings": [
        {
          "type": "eventGridTrigger",
          "name": "cloudEvent",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "EventGridCloudEventTrigger",
      "description": "$EventGridCloudEventTrigger_description",
      "name": "Azure Event Grid Cloud Event trigger",
      "language": "C#",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "eventGrid",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "EventGridTrigger-CSharp",
    "runtime": "2",
    "files": {
      "run.csx": "#r \"Azure.Messaging.EventGrid\"\r\n\r\nusing Azure.Messaging.EventGrid;\r\n\r\npublic static void Run(EventGridEvent eventGridEvent, ILogger log)\r\n{\r\n    log.LogInformation(eventGridEvent.EventType.ToString());\r\n}\r\n",
      "sample.dat": "{\r\n  \"topic\": \"/subscriptions/5b4b650e-28b9-4790-b3ab-ddbd88d727c4/resourcegroups/test/providers/Microsoft.EventHub/namespaces/test\",\r\n  \"subject\": \"eventhubs/test\",\r\n  \"eventType\": \"captureFileCreated\",\r\n  \"eventTime\": \"2017-07-14T23:10:27.7689666Z\",\r\n  \"id\": \"7b11c4ce-1c34-4416-848b-1730e766f126\",\r\n  \"data\": {\r\n    \"fileUrl\": \"https://test.blob.core.windows.net/debugging/testblob.txt\",\r\n    \"fileType\": \"AzureBlockBlob\",\r\n    \"partitionId\": \"1\",\r\n    \"sizeInBytes\": 0,\r\n    \"eventCount\": 0,\r\n    \"firstSequenceNumber\": -1,\r\n    \"lastSequenceNumber\": -1,\r\n    \"firstEnqueueTime\": \"0001-01-01T00:00:00\",\r\n    \"lastEnqueueTime\": \"0001-01-01T00:00:00\"\r\n  },\r\n  \"dataVersion\": \"\",\r\n  \"metadataVersion\": \"1\" \r\n}\r\n"
    },
    "function": {
      "bindings": [
        {
          "type": "eventGridTrigger",
          "name": "eventGridEvent",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "EventGridTrigger",
      "description": "$EventGridTrigger_description",
      "name": "Azure Event Grid trigger",
      "language": "C#",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "eventGrid",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "EventGridTrigger-Custom",
    "runtime": "2",
    "files": {},
    "function": {
      "bindings": [
        {
          "type": "eventGridTrigger",
          "name": "eventGridEvent",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "EventGridTrigger",
      "description": "$EventGridTrigger_description",
      "name": "Azure Event Grid trigger",
      "language": "Custom",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "eventGrid",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "EventGridTrigger-JavaScript",
    "runtime": "2",
    "files": {
      "index.js": "module.exports = async function (context, eventGridEvent) {\r\n    context.log(typeof eventGridEvent);\r\n    context.log(eventGridEvent);\r\n};",
      "sample.dat": "{\r\n  \"topic\": \"/subscriptions/5b4b650e-28b9-4790-b3ab-ddbd88d727c4/resourcegroups/test/providers/Microsoft.EventHub/namespaces/test\",\r\n  \"subject\": \"eventhubs/test\",\r\n  \"eventType\": \"captureFileCreated\",\r\n  \"eventTime\": \"2017-07-14T23:10:27.7689666Z\",\r\n  \"id\": \"7b11c4ce-1c34-4416-848b-1730e766f126\",\r\n  \"data\": {\r\n    \"fileUrl\": \"https://test.blob.core.windows.net/debugging/testblob.txt\",\r\n    \"fileType\": \"AzureBlockBlob\",\r\n    \"partitionId\": \"1\",\r\n    \"sizeInBytes\": 0,\r\n    \"eventCount\": 0,\r\n    \"firstSequenceNumber\": -1,\r\n    \"lastSequenceNumber\": -1,\r\n    \"firstEnqueueTime\": \"0001-01-01T00:00:00\",\r\n    \"lastEnqueueTime\": \"0001-01-01T00:00:00\"\r\n  },\r\n  \"dataVersion\": \"\", \r\n  \"metadataVersion\": \"1\" \r\n}\r\n"
    },
    "function": {
      "bindings": [
        {
          "type": "eventGridTrigger",
          "name": "eventGridEvent",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "EventGridTrigger",
      "description": "$EventGridTrigger_description",
      "name": "Azure Event Grid trigger",
      "language": "JavaScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "eventGrid",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "EventGridTrigger-PowerShell",
    "runtime": "2",
    "files": {
      "run.ps1": "param($eventGridEvent, $TriggerMetadata)\r\n\r\n# Make sure to pass hashtables to Out-String so they're logged correctly\r\n$eventGridEvent | Out-String | Write-Host\r\n",
      "sample.dat": "{\r\n  \"topic\": \"/subscriptions/5b4b650e-28b9-4790-b3ab-ddbd88d727c4/resourcegroups/test/providers/Microsoft.EventHub/namespaces/test\",\r\n  \"subject\": \"eventhubs/test\",\r\n  \"eventType\": \"captureFileCreated\",\r\n  \"eventTime\": \"2017-07-14T23:10:27.7689666Z\",\r\n  \"id\": \"7b11c4ce-1c34-4416-848b-1730e766f126\",\r\n  \"data\": {\r\n    \"fileUrl\": \"https://test.blob.core.windows.net/debugging/testblob.txt\",\r\n    \"fileType\": \"AzureBlockBlob\",\r\n    \"partitionId\": \"1\",\r\n    \"sizeInBytes\": 0,\r\n    \"eventCount\": 0,\r\n    \"firstSequenceNumber\": -1,\r\n    \"lastSequenceNumber\": -1,\r\n    \"firstEnqueueTime\": \"0001-01-01T00:00:00\",\r\n    \"lastEnqueueTime\": \"0001-01-01T00:00:00\"\r\n  },\r\n  \"dataVersion\": \"\", \r\n  \"metadataVersion\": \"1\" \r\n}\r\n"
    },
    "function": {
      "bindings": [
        {
          "type": "eventGridTrigger",
          "name": "eventGridEvent",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "EventGridTrigger",
      "description": "$EventGridTrigger_description",
      "name": "Azure Event Grid trigger",
      "language": "PowerShell",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "eventGrid",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "EventGridTrigger-Python",
    "runtime": "2",
    "files": {
      "sample.dat": "{\r\n  'topic': '/subscriptions/5b4b650e-28b9-4790-b3ab-ddbd88d727c4/resourcegroups/test/providers/Microsoft.EventHub/namespaces/test',\r\n  'subject': 'eventhubs/test',\r\n  'eventType': 'captureFileCreated',\r\n  'eventTime': '2017-07-14T23:10:27.7689666Z',\r\n  'id': '7b11c4ce-1c34-4416-848b-1730e766f126',\r\n  'data': {\r\n    'fileUrl': 'https://test.blob.core.windows.net/debugging/testblob.txt',\r\n    'fileType': 'AzureBlockBlob',\r\n    'partitionId': '1',\r\n    'sizeInBytes': 0,\r\n    'eventCount': 0,\r\n    'firstSequenceNumber': -1,\r\n    'lastSequenceNumber': -1,\r\n    'firstEnqueueTime': '0001-01-01T00:00:00',\r\n    'lastEnqueueTime': '0001-01-01T00:00:00'\r\n  },\r\n  \"dataVersion\": \"\", \r\n  \"metadataVersion\": \"1\" \r\n}\r\n",
      "__init__.py": "import json\r\nimport logging\r\n\r\nfrom azure.functions import EventGridEvent\r\n\r\n\r\ndef main(event: EventGridEvent):\r\n    result = json.dumps({\r\n        'id': event.id,\r\n        'data': event.get_json(),\r\n        'topic': event.topic,\r\n        'subject': event.subject,\r\n        'event_type': event.event_type,\r\n    })\r\n\r\n    logging.info('Python EventGrid trigger processed an event: %s', result)\r\n"
    },
    "function": {
      "scriptFile": "__init__.py",
      "bindings": [
        {
          "type": "eventGridTrigger",
          "name": "event",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "EventGridTrigger",
      "description": "$EventGridTrigger_description",
      "name": "Azure Event Grid trigger",
      "language": "Python",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "eventGrid",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "EventGridTrigger-TypeScript",
    "runtime": "2",
    "files": {
      "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\r\n\r\nconst eventGridTrigger: AzureFunction = async function (context: Context, eventGridEvent: any): Promise<void> {\r\n    context.log(typeof eventGridEvent);\r\n    context.log(eventGridEvent);\r\n};\r\n\r\nexport default eventGridTrigger;\r\n",
      "sample.dat": "{\r\n  \"topic\": \"/subscriptions/5b4b650e-28b9-4790-b3ab-ddbd88d727c4/resourcegroups/test/providers/Microsoft.EventHub/namespaces/test\",\r\n  \"subject\": \"eventhubs/test\",\r\n  \"eventType\": \"captureFileCreated\",\r\n  \"eventTime\": \"2017-07-14T23:10:27.7689666Z\",\r\n  \"id\": \"7b11c4ce-1c34-4416-848b-1730e766f126\",\r\n  \"data\": {\r\n    \"fileUrl\": \"https://test.blob.core.windows.net/debugging/testblob.txt\",\r\n    \"fileType\": \"AzureBlockBlob\",\r\n    \"partitionId\": \"1\",\r\n    \"sizeInBytes\": 0,\r\n    \"eventCount\": 0,\r\n    \"firstSequenceNumber\": -1,\r\n    \"lastSequenceNumber\": -1,\r\n    \"firstEnqueueTime\": \"0001-01-01T00:00:00\",\r\n    \"lastEnqueueTime\": \"0001-01-01T00:00:00\"\r\n  },\r\n  \"dataVersion\": \"\", \r\n  \"metadataVersion\": \"1\" \r\n}\r\n"
    },
    "function": {
      "bindings": [
        {
          "type": "eventGridTrigger",
          "name": "eventGridEvent",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "EventGridTrigger",
      "description": "$EventGridTrigger_description",
      "name": "Azure Event Grid trigger",
      "language": "TypeScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "eventGrid",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "EventHubTrigger-CSharp",
    "runtime": "2",
    "files": {
      "run.csx": "#r \"Azure.Messaging.EventHubs\"\r\n#r \"System.Memory.Data\"\r\n\r\nusing System;\r\nusing System.Text;\r\nusing Azure.Messaging.EventHubs;\r\n\r\npublic static async Task Run(EventData[] events, ILogger log)\r\n{\r\n    var exceptions = new List<Exception>();\r\n\r\n    foreach (EventData eventData in events)\r\n    {\r\n        try\r\n        {\r\n            // Replace these two lines with your processing logic.\r\n            log.LogInformation($\"C# Event Hub trigger function processed a message: {eventData.EventBody}\");\r\n            await Task.Yield();\r\n        }\r\n        catch (Exception e)\r\n        {\r\n            // We need to keep processing the rest of the batch - capture this exception and continue.\r\n            // Also, consider capturing details of the message that failed processing so it can be processed again later.\r\n            exceptions.Add(e);\r\n        }\r\n    }\r\n\r\n    // Once processing of the batch is complete, if any messages in the batch failed processing throw an exception so that there is a record of the failure.\r\n\r\n    if (exceptions.Count > 1)\r\n        throw new AggregateException(exceptions);\r\n\r\n    if (exceptions.Count == 1)\r\n        throw exceptions.Single();\r\n}\r\n",
      "sample.dat": "Test Message"
    },
    "function": {
      "bindings": [
        {
          "type": "eventHubTrigger",
          "name": "events",
          "direction": "in",
          "eventHubName": "samples-workitems",
          "cardinality": "many",
          "connection": "",
          "consumerGroup": "$Default"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "EventHubTrigger",
      "description": "$EventHubTrigger_description",
      "name": "Azure Event Hub trigger",
      "language": "C#",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "eventHub",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "eventHubName",
        "consumerGroup"
      ]
    }
  },
  {
    "id": "EventHubTrigger-Custom",
    "runtime": "2",
    "files": {},
    "function": {
      "bindings": [
        {
          "type": "eventHubTrigger",
          "name": "eventHubMessages",
          "direction": "in",
          "eventHubName": "samples-workitems",
          "connection": "",
          "cardinality": "many",
          "consumerGroup": "$Default"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "EventHubTrigger",
      "description": "$EventHubTrigger_description",
      "name": "Azure Event Hub trigger",
      "language": "Custom",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "eventHub",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "eventHubName",
        "consumerGroup"
      ]
    }
  },
  {
    "id": "EventHubTrigger-JavaScript",
    "runtime": "2",
    "files": {
      "index.js": "module.exports = async function (context, eventHubMessages) {\r\n    context.log(`JavaScript eventhub trigger function called for message array ${eventHubMessages}`);\r\n    \r\n    eventHubMessages.forEach((message, index) => {\r\n        context.log(`Processed message ${message}`);\r\n    });\r\n};",
      "sample.dat": "\"Test Message\""
    },
    "function": {
      "bindings": [
        {
          "type": "eventHubTrigger",
          "name": "eventHubMessages",
          "direction": "in",
          "eventHubName": "samples-workitems",
          "connection": "",
          "cardinality": "many",
          "consumerGroup": "$Default",
          "dataType": "string"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "EventHubTrigger",
      "description": "$EventHubTrigger_description",
      "name": "Azure Event Hub trigger",
      "language": "JavaScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "eventHub",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "eventHubName",
        "consumerGroup"
      ]
    }
  },
  {
    "id": "EventHubTrigger-PowerShell",
    "runtime": "2",
    "files": {
      "run.ps1": "param($eventHubMessages, $TriggerMetadata)\r\n\r\nWrite-Host \"PowerShell eventhub trigger function called for message array: $eventHubMessages\"\r\n\r\n$eventHubMessages | ForEach-Object { Write-Host \"Processed message: $_\" }\r\n",
      "sample.dat": "\"Test Message\""
    },
    "function": {
      "bindings": [
        {
          "type": "eventHubTrigger",
          "name": "eventHubMessages",
          "direction": "in",
          "eventHubName": "samples-workitems",
          "connection": "",
          "cardinality": "many",
          "consumerGroup": "$Default"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "EventHubTrigger",
      "description": "$EventHubTrigger_description",
      "name": "Azure Event Hub trigger",
      "language": "PowerShell",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "eventHub",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "eventHubName",
        "consumerGroup"
      ]
    }
  },
  {
    "id": "EventHubTrigger-Python",
    "runtime": "2",
    "files": {
      "sample.dat": "Test Message",
      "__init__.py": "import logging\r\n\r\nfrom azure.functions import EventHubEvent\r\nfrom typing import List\r\n\r\n\r\ndef main(events: List[EventHubEvent]):\r\n    for event in events:\r\n        logging.info('Python EventHub trigger processed an event: %s',\r\n                      event.get_body().decode('utf-8'))\r\n"
    },
    "function": {
      "scriptFile": "__init__.py",
      "bindings": [
        {
          "type": "eventHubTrigger",
          "name": "events",
          "direction": "in",
          "eventHubName": "samples-workitems",
          "connection": "",
          "cardinality": "many",
          "consumerGroup": "$Default"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "EventHubTrigger",
      "description": "$EventHubTrigger_description",
      "name": "Azure Event Hub trigger",
      "language": "Python",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "eventHub",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "eventHubName",
        "consumerGroup"
      ]
    }
  },
  {
    "id": "EventHubTrigger-TypeScript",
    "runtime": "2",
    "files": {
      "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\r\n\r\nconst eventHubTrigger: AzureFunction = async function (context: Context, eventHubMessages: any[]): Promise<void> {\r\n    context.log(`Eventhub trigger function called for message array ${eventHubMessages}`);\r\n    \r\n    eventHubMessages.forEach((message, index) => {\r\n        context.log(`Processed message ${message}`);\r\n    });\r\n};\r\n\r\nexport default eventHubTrigger;\r\n",
      "sample.dat": "\"Test Message\""
    },
    "function": {
      "bindings": [
        {
          "type": "eventHubTrigger",
          "name": "eventHubMessages",
          "direction": "in",
          "eventHubName": "samples-workitems",
          "connection": "",
          "cardinality": "many",
          "consumerGroup": "$Default",
          "dataType": "string"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "EventHubTrigger",
      "description": "$EventHubTrigger_description",
      "name": "Azure Event Hub trigger",
      "language": "TypeScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "eventHub",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "eventHubName",
        "consumerGroup"
      ]
    }
  },
  {
    "id": "HttpTrigger-CSharp",
    "runtime": "2",
    "files": {
      "readme.md": "# HttpTrigger - C<span>#</span>\r\n\r\nThe `HttpTrigger` makes it incredibly easy to have your functions executed via an HTTP call to your function.\r\n\r\n## How it works\r\n\r\nWhen you call the function, be sure you checkout which security rules you apply. If you're using an apikey, you'll need to include that in your request.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
      "run.csx": "#r \"Newtonsoft.Json\"\r\n\r\nusing System.Net;\r\nusing Microsoft.AspNetCore.Mvc;\r\nusing Microsoft.Extensions.Primitives;\r\nusing Newtonsoft.Json;\r\n\r\npublic static async Task<IActionResult> Run(HttpRequest req, ILogger log)\r\n{\r\n    log.LogInformation(\"C# HTTP trigger function processed a request.\");\r\n\r\n    string name = req.Query[\"name\"];\r\n\r\n    string requestBody = await new StreamReader(req.Body).ReadToEndAsync();\r\n    dynamic data = JsonConvert.DeserializeObject(requestBody);\r\n    name = name ?? data?.name;\r\n\r\n    string responseMessage = string.IsNullOrEmpty(name)\r\n        ? \"This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response.\"\r\n                : $\"Hello, {name}. This HTTP triggered function executed successfully.\";\r\n\r\n            return new OkObjectResult(responseMessage);\r\n}",
      "sample.dat": "{\r\n    \"name\": \"Azure\"\r\n}"
    },
    "function": {
      "bindings": [
        {
          "authLevel": "function",
          "name": "req",
          "type": "httpTrigger",
          "direction": "in",
          "methods": [
            "get",
            "post"
          ]
        },
        {
          "name": "$return",
          "type": "http",
          "direction": "out"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "HttpTrigger",
      "description": "$HttpTrigger_description",
      "name": "HTTP trigger",
      "language": "C#",
      "category": [
        "$temp_category_core",
        "$temp_category_api"
      ],
      "categoryStyle": "http",
      "enabledInTryMode": true,
      "userPrompt": [
        "authLevel"
      ]
    }
  },
  {
    "id": "HttpTrigger-Custom",
    "runtime": "2",
    "files": {},
    "function": {
      "bindings": [
        {
          "authLevel": "function",
          "type": "httpTrigger",
          "direction": "in",
          "name": "req",
          "methods": [
            "get",
            "post"
          ]
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "HttpTrigger",
      "description": "$HttpTrigger_description",
      "name": "HTTP trigger",
      "trigger": "HttpTrigger",
      "language": "Custom",
      "category": [
        "$temp_category_core",
        "$temp_category_api"
      ],
      "categoryStyle": "http",
      "enabledInTryMode": false,
      "userPrompt": [
        "authLevel"
      ]
    }
  },
  {
    "id": "HttpTrigger-JavaScript",
    "runtime": "2",
    "files": {
      "index.js": "module.exports = async function (context, req) {\r\n    context.log('JavaScript HTTP trigger function processed a request.');\r\n\r\n    const name = (req.query.name || (req.body && req.body.name));\r\n    const responseMessage = name\r\n        ? \"Hello, \" + name + \". This HTTP triggered function executed successfully.\"\r\n        : \"This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response.\";\r\n\r\n    context.res = {\r\n        // status: 200, /* Defaults to 200 */\r\n        body: responseMessage\r\n    };\r\n}",
      "sample.dat": "{\r\n    \"name\": \"Azure\"\r\n}"
    },
    "function": {
      "bindings": [
        {
          "authLevel": "function",
          "type": "httpTrigger",
          "direction": "in",
          "name": "req",
          "methods": [
            "get",
            "post"
          ]
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "HttpTrigger",
      "description": "$HttpTrigger_description",
      "name": "HTTP trigger",
      "language": "JavaScript",
      "trigger": "HttpTrigger",
      "category": [
        "$temp_category_core",
        "$temp_category_api"
      ],
      "categoryStyle": "http",
      "enabledInTryMode": true,
      "userPrompt": [
        "authLevel"
      ]
    }
  },
  {
    "id": "HttpTrigger-PowerShell",
    "runtime": "2",
    "files": {
      "run.ps1": "using namespace System.Net\r\n\r\n# Input bindings are passed in via param block.\r\nparam($Request, $TriggerMetadata)\r\n\r\n# Write to the Azure Functions log stream.\r\nWrite-Host \"PowerShell HTTP trigger function processed a request.\"\r\n\r\n# Interact with query parameters or the body of the request.\r\n$name = $Request.Query.Name\r\nif (-not $name) {\r\n    $name = $Request.Body.Name\r\n}\r\n\r\n$body = \"This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response.\"\r\n\r\nif ($name) {\r\n    $body = \"Hello, $name. This HTTP triggered function executed successfully.\"\r\n}\r\n\r\n# Associate values to output bindings by calling 'Push-OutputBinding'.\r\nPush-OutputBinding -Name Response -Value ([HttpResponseContext]@{\r\n    StatusCode = [HttpStatusCode]::OK\r\n    Body = $body\r\n})\r\n",
      "sample.dat": "{\r\n    \"name\": \"Azure\"\r\n}\r\n"
    },
    "function": {
      "bindings": [
        {
          "authLevel": "function",
          "type": "httpTrigger",
          "direction": "in",
          "name": "Request",
          "methods": [
            "get",
            "post"
          ]
        },
        {
          "type": "http",
          "direction": "out",
          "name": "Response"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "HttpTrigger",
      "description": "$HttpTrigger_description",
      "name": "HTTP trigger",
      "language": "PowerShell",
      "trigger": "HttpTrigger",
      "category": [
        "$temp_category_core",
        "$temp_category_api"
      ],
      "categoryStyle": "http",
      "enabledInTryMode": true,
      "userPrompt": [
        "authLevel"
      ]
    }
  },
  {
    "id": "HttpTrigger-Python",
    "runtime": "2",
    "files": {
      "sample.dat": "{\r\n    \"name\": \"Azure\"\r\n}",
      "__init__.py": "import logging\r\n\r\nfrom azure.functions import HttpRequest, HttpResponse\r\n\r\n\r\ndef main(req: HttpRequest) -> HttpResponse:\r\n    logging.info('Python HTTP trigger function processed a request.')\r\n\r\n    name = req.params.get('name')\r\n    if not name:\r\n        try:\r\n            req_body = req.get_json()\r\n        except ValueError:\r\n            pass\r\n        else:\r\n            name = req_body.get('name')\r\n\r\n    if name:\r\n        return HttpResponse(f\"Hello, {name}. This HTTP triggered function executed successfully.\")\r\n    else:\r\n        return HttpResponse(\r\n            \"This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response.\",\r\n            status_code=200\r\n        )\r\n"
    },
    "function": {
      "scriptFile": "__init__.py",
      "bindings": [
        {
          "authLevel": "function",
          "type": "httpTrigger",
          "direction": "in",
          "name": "req",
          "methods": [
            "get",
            "post"
          ]
        },
        {
          "type": "http",
          "direction": "out",
          "name": "$return"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "HttpTrigger",
      "description": "$HttpTrigger_description",
      "name": "HTTP trigger",
      "language": "Python",
      "trigger": "HttpTrigger",
      "category": [
        "$temp_category_core",
        "$temp_category_api"
      ],
      "categoryStyle": "http",
      "enabledInTryMode": true,
      "userPrompt": [
        "authLevel"
      ],
      "filters": [
        "Python3"
      ]
    }
  },
  {
    "id": "HttpTrigger-TypeScript",
    "runtime": "2",
    "files": {
      "index.ts": "import { AzureFunction, Context, HttpRequest } from \"@azure/functions\"\r\n\r\nconst httpTrigger: AzureFunction = async function (context: Context, req: HttpRequest): Promise<void> {\r\n    context.log('HTTP trigger function processed a request.');\r\n    const name = (req.query.name || (req.body && req.body.name));\r\n    const responseMessage = name\r\n        ? \"Hello, \" + name + \". This HTTP triggered function executed successfully.\"\r\n        : \"This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response.\";\r\n\r\n    context.res = {\r\n        // status: 200, /* Defaults to 200 */\r\n        body: responseMessage\r\n    };\r\n\r\n};\r\n\r\nexport default httpTrigger;",
      "sample.dat": "{\r\n    \"name\": \"Azure\"\r\n}"
    },
    "function": {
      "bindings": [
        {
          "authLevel": "function",
          "type": "httpTrigger",
          "direction": "in",
          "name": "req",
          "methods": [
            "get",
            "post"
          ]
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "HttpTrigger",
      "description": "$HttpTrigger_description",
      "name": "HTTP trigger",
      "language": "TypeScript",
      "trigger": "HttpTrigger",
      "category": [
        "$temp_category_core",
        "$temp_category_api"
      ],
      "categoryStyle": "http",
      "enabledInTryMode": true,
      "userPrompt": [
        "authLevel"
      ]
    }
  },
  {
    "id": "IoTHubTrigger-CSharp",
    "runtime": "2",
    "files": {
      "run.csx": "using System;\r\n\r\npublic static void Run(string myIoTHubMessage, ILogger log)\r\n{\r\n    log.LogInformation($\"C# IoT Hub trigger function processed a message: {myIoTHubMessage}\");\r\n}",
      "sample.dat": "Test Message"
    },
    "function": {
      "bindings": [
        {
          "type": "eventHubTrigger",
          "name": "myIoTHubMessage",
          "direction": "in",
          "eventHubName": "samples-workitems",
          "connection": "",
          "consumerGroup": "$Default"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "IoTHub_EventHub",
      "description": "$IoTHubTrigger_description",
      "name": "IoT Hub (Event Hub)",
      "language": "C#",
      "category": [
        "$temp_category_IoTHub"
      ],
      "categoryStyle": "iot",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "path",
        "consumerGroup"
      ]
    }
  },
  {
    "id": "IoTHubTrigger-Custom",
    "runtime": "2",
    "files": {},
    "function": {
      "bindings": [
        {
          "type": "eventHubTrigger",
          "name": "IoTHubMessages",
          "direction": "in",
          "eventHubName": "samples-workitems",
          "connection": "",
          "cardinality": "many",
          "consumerGroup": "$Default"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "IoTHub_EventHub",
      "description": "$IoTHubTrigger_description",
      "name": "IoT Hub (Event Hub)",
      "language": "Custom",
      "category": [
        "$temp_category_IoTHub"
      ],
      "categoryStyle": "iot",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "path",
        "consumerGroup"
      ]
    }
  },
  {
    "id": "IoTHubTrigger-JavaScript",
    "runtime": "2",
    "files": {
      "index.js": "module.exports = function (context, IoTHubMessages) {\r\n    context.log(`JavaScript eventhub trigger function called for message array: ${IoTHubMessages}`);\r\n    \r\n    IoTHubMessages.forEach(message => {\r\n        context.log(`Processed message: ${message}`);\r\n    });\r\n\r\n    context.done();\r\n};",
      "sample.dat": "Test Message"
    },
    "function": {
      "bindings": [
        {
          "type": "eventHubTrigger",
          "name": "IoTHubMessages",
          "direction": "in",
          "eventHubName": "samples-workitems",
          "connection": "",
          "cardinality": "many",
          "consumerGroup": "$Default",
          "dataType": "string"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "IoTHub_EventHub",
      "description": "$IoTHubTrigger_description",
      "name": "IoT Hub (Event Hub)",
      "language": "JavaScript",
      "category": [
        "$temp_category_IoTHub"
      ],
      "categoryStyle": "iot",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "path",
        "consumerGroup"
      ]
    }
  },
  {
    "id": "IoTHubTrigger-PowerShell",
    "runtime": "2",
    "files": {
      "run.ps1": "param($IoTHubMessages, $TriggerMetadata)\r\n\r\nWrite-Host \"PowerShell eventhub trigger function called for message array: $IoTHubMessages\"\r\n\r\n$IoTHubMessages | ForEach-Object { Write-Host \"Processed message: $_\" }\r\n",
      "sample.dat": "Test Message"
    },
    "function": {
      "bindings": [
        {
          "type": "eventHubTrigger",
          "name": "IoTHubMessages",
          "direction": "in",
          "eventHubName": "samples-workitems",
          "connection": "",
          "cardinality": "many",
          "consumerGroup": "$Default"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "IoTHub_EventHub",
      "description": "$IoTHubTrigger_description",
      "name": "IoT Hub (Event Hub)",
      "language": "PowerShell",
      "category": [
        "$temp_category_IoTHub"
      ],
      "categoryStyle": "iot",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "path",
        "consumerGroup"
      ]
    }
  },
  {
    "id": "IoTHubTrigger-TypeScript",
    "runtime": "2",
    "files": {
      "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\r\n\r\nconst IoTHubTrigger: AzureFunction = async function (context: Context, IoTHubMessages: any[]): Promise<void> {\r\n    context.log(`Eventhub trigger function called for message array: ${IoTHubMessages}`);\r\n    \r\n    IoTHubMessages.forEach(message => {\r\n        context.log(`Processed message: ${message}`);\r\n    });\r\n};\r\n\r\nexport default IoTHubTrigger;\r\n",
      "sample.dat": "Test Message"
    },
    "function": {
      "bindings": [
        {
          "type": "eventHubTrigger",
          "name": "IoTHubMessages",
          "direction": "in",
          "eventHubName": "samples-workitems",
          "connection": "",
          "cardinality": "many",
          "consumerGroup": "$Default",
          "dataType": "string"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "IoTHub_EventHub",
      "description": "$IoTHubTrigger_description",
      "name": "IoT Hub (Event Hub)",
      "language": "TypeScript",
      "category": [
        "$temp_category_IoTHub"
      ],
      "categoryStyle": "iot",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "path",
        "consumerGroup"
      ]
    }
  },
  {
    "id": "KafkaOutput-CSharp",
    "runtime": "2",
    "files": {
      "readme.md": "# KafkaOutput - C<span>#</span>\r\n\r\nThe `KafkaOutput` makes it incredibly easy to sent a new events to a Kafka Broker. This sample demonstrates a simple use case of sending data to a given Kafka Broker using C#.\r\n\r\n## How it works\r\n\r\nFor a `KafkaOutput` to work, you must provide a topic name which dictates where the messages should be sent to with authentication.\r\n\r\n## Configuration\r\n\r\n### EventHubs for Kafka\r\n\r\nAdd `BrokerList` and `KafkaPassword` to your `local.settings.json`\r\n\r\n_local.settings.json_\r\n\r\n```json\r\n{\r\n  \"IsEncrypted\": false,\r\n  \"Values\": {\r\n    \"AzureWebJobsStorage\": \"UseDevelopmentStorage=true\",\r\n    \"FUNCTIONS_WORKER_RUNTIME\": \"dotnet\",\r\n    \"BrokerList\": \"{YOUR_EVENT_HUBS_NAMESPACE}.servicebus.windows.net:9093\",\r\n    \"KafkaPassword\": \"{EVENT_HUBS_CONNECTION_STRING}\"\r\n  }\r\n}\r\n```\r\n\r\n### Others\r\n\r\nModify `function.json` or `KafkaOutput` attribute according to your broker.",
      "run.csx": "#r \"Microsoft.Azure.WebJobs.Extensions.Kafka\"\r\n#r \"Newtonsoft.Json\"\r\n\r\nusing Microsoft.AspNetCore.Http;\r\nusing Microsoft.AspNetCore.Mvc;\r\nusing Microsoft.Azure.WebJobs;\r\nusing Microsoft.Azure.WebJobs.Extensions.Http;\r\nusing Microsoft.Azure.WebJobs.Extensions.Kafka;\r\nusing Microsoft.Extensions.Logging;\r\nusing Newtonsoft.Json;\r\n\r\npublic static IActionResult Run(\r\n    HttpRequest req,\r\n    out string eventData,\r\n    ILogger log)\r\n{\r\n    log.LogInformation(\"C# HTTP trigger function processed a request.\");\r\n\r\n    string message = req.Query[\"message\"];\r\n\r\n    string requestBody = await new StreamReader(req.Body).ReadToEndAsync();\r\n    dynamic data = JsonConvert.DeserializeObject(requestBody);\r\n    message = message ?? data?.message;\r\n\r\n    string responseMessage = string.IsNullOrEmpty(message)\r\n        ? \"This HTTP triggered function executed successfully. Pass a message in the query string\"\r\n        : $\"Message {message} sent to the broker. This HTTP triggered function executed successfully.\";\r\n    eventData = $\"Received message: {message}\";\r\n\r\n    return new OkObjectResult(responseMessage);\r\n}\r\n",
      "sample.dat": "{\r\n    \"message\": \"hello\"\r\n}"
    },
    "function": {
      "bindings": [
        {
          "authLevel": "function",
          "name": "req",
          "type": "httpTrigger",
          "direction": "in",
          "methods": [
            "get"
          ]
        },
        {
          "name": "$return",
          "type": "http",
          "direction": "out"
        },
        {
          "name": "eventData",
          "type": "kafka",
          "direction": "out",
          "brokerList": "BrokerList",
          "topic": "topic",
          "username": "$ConnectionString",
          "password": "%KafkaPassword%",
          "protocol": "saslSsl",
          "authenticationMode": "plain"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "KafkaOutput",
      "description": "$KafkaOutput_description",
      "name": "Kafka output",
      "language": "C#",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": [
        "brokerList",
        "topic",
        "username",
        "password",
        "protocol",
        "authenticationMode"
      ]
    }
  },
  {
    "id": "KafkaOutput-JavaScript",
    "runtime": "2",
    "files": {
      "index.js": "// This sample will create topic \"topic\" and send message to it. \r\n// KafkaTrigger will be trigged.\r\nmodule.exports = async function (context, req) {\r\n    context.log('JavaScript HTTP trigger function processed a request.');\r\n\r\n    const message = (req.query.message || (req.body && req.body.message));\r\n    const responseMessage = message\r\n        ? \"Message received: \" + message + \". The message transfered to the kafka broker.\"\r\n        : \"This HTTP triggered function executed successfully. Pass a message in the query string or in the request body for a personalized response.\";\r\n    context.bindings.outputKafkaMessage = \"Message : \" + message;\r\n    context.res = {\r\n        // status: 200, /* Defaults to 200 */\r\n        body: responseMessage\r\n    };\r\n}",
      "readme.md": "# KafkaOutput - JavaScript\r\n\r\nThe `KafkaOutput` makes it incredibly easy to send a new events to a Kafka Broker. This sample demonstrates a simple use case of sending data to a given Kafka Broker using JavaScript.\r\n\r\n## How it works\r\n\r\nFor a `KafkaOutput` to work, you must provide a topic name which dictates where the messages should be sent to with authentication.\r\n\r\n## Configuration\r\n\r\n### EventHubs for Kafka\r\n\r\nAdd `BrokerList` and `KafkaPassword` to your `local.settings.json`\r\n\r\n_local.settings.json_\r\n\r\n```json\r\n{\r\n  \"IsEncrypted\": false,\r\n  \"Values\": {\r\n    \"AzureWebJobsStorage\": \"UseDevelopmentStorage=true\",\r\n    \"FUNCTIONS_WORKER_RUNTIME\": \"node\",\r\n    \"BrokerList\": \"{YOUR_EVENT_HUBS_NAMESPACE}.servicebus.windows.net:9093\",\r\n    \"KafkaPassword\": \"{EVENT_HUBS_CONNECTION_STRING}\"\r\n  }\r\n}\r\n```\r\n\r\n### Others\r\n\r\nModify `function.json` or `KafkaOutput` attribute according to your broker.",
      "sample.dat": "{\r\n    \"message\": \"hello\"\r\n}"
    },
    "function": {
      "bindings": [
        {
          "authLevel": "function",
          "type": "httpTrigger",
          "direction": "in",
          "name": "req",
          "methods": [
            "get",
            "post"
          ]
        },
        {
          "type": "kafka",
          "name": "outputKafkaMessage",
          "brokerList": "BrokerList",
          "topic": "topic",
          "username": "$ConnectionString",
          "password": "%KafkaPassword%",
          "protocol": "SASLSSL",
          "authenticationMode": "PLAIN",
          "direction": "out"
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "KafkaOutput",
      "description": "$KafkaOutput_description",
      "name": "Kafka output",
      "language": "JavaScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": [
        "brokerList",
        "topic",
        "username",
        "password",
        "protocol",
        "authenticationMode"
      ]
    }
  },
  {
    "id": "KafkaOutput-PowerShell",
    "runtime": "2",
    "files": {
      "readme.md": "# KafkaOutput - PowerShell\r\n\r\nThe `KafkaOutput` makes it incredibly easy to send a new events to a Kafka Broker. This sample demonstrates a simple use case of sending data to a given Kafka Broker using PowerShell.\r\n\r\n## How it works\r\n\r\nFor a `KafkaOutput` to work, you must provide a topic name which dictates where the messages should be sent to with authentication.\r\n\r\n## Configuration\r\n\r\n### EventHubs for Kafka\r\n\r\nAdd `BrokerList` and `KafkaPassword` to your `local.settings.json`\r\n\r\n_local.settings.json_\r\n\r\n```json\r\n{\r\n  \"IsEncrypted\": false,\r\n  \"Values\": {\r\n    \"AzureWebJobsStorage\": \"UseDevelopmentStorage=true\",\r\n    \"FUNCTIONS_WORKER_RUNTIME\": \"node\",\r\n    \"BrokerList\": \"{YOUR_EVENT_HUBS_NAMESPACE}.servicebus.windows.net:9093\",\r\n    \"KafkaPassword\": \"{EVENT_HUBS_CONNECTION_STRING}\"\r\n  }\r\n}\r\n```\r\n\r\n### Others\r\n\r\nModify `function.json` or `KafkaOutput` attribute according to your broker.",
      "run.ps1": "using namespace System.Net\r\n\r\n# Input bindings are passed in via param block.\r\nparam($Request, $TriggerMetadata)\r\n\r\n# Write to the Azure Functions log stream.\r\nWrite-Host \"PowerShell HTTP trigger function processed a request.\"\r\n\r\n# Interact with query parameters or the body of the request.\r\n$message = $Request.Query.Message\r\nif (-not $message) {\r\n    $message = $Request.Body.Message\r\n}\r\n\r\n$body = \"This HTTP triggered function executed successfully. Pass a message in the query string or in the request body for a personalized response.\"\r\n\r\nif ($message) {\r\n    $body = \"Message received:  $message. The message transfered to the kafka broker.\"\r\n}\r\n\r\nPush-OutputBinding -Name Message -Value (\"Message: \" + $message)\r\n\r\n# Associate values to output bindings by calling 'Push-OutputBinding'.\r\nPush-OutputBinding -Name Response -Value ([HttpResponseContext]@{\r\n    StatusCode = [HttpStatusCode]::OK\r\n    Body = $body\r\n})\r\n",
      "sample.dat": "{\r\n    \"message\": \"hello\"\r\n}"
    },
    "function": {
      "bindings": [
        {
          "authLevel": "function",
          "type": "httpTrigger",
          "direction": "in",
          "name": "Request",
          "methods": [
            "get",
            "post"
          ]
        },
        {
          "type": "kafka",
          "name": "Message",
          "brokerList": "BrokerList",
          "topic": "topic",
          "username": "$ConnectionString",
          "password": "%KafkaPassword%",
          "protocol": "SASLSSL",
          "authenticationMode": "PLAIN",
          "direction": "out"
        },
        {
          "type": "http",
          "direction": "out",
          "name": "Response"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "KafkaOutput",
      "description": "$KafkaOutput_description",
      "name": "Kafka output",
      "language": "PowerShell",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": [
        "brokerList",
        "topic",
        "username",
        "password",
        "protocol",
        "authenticationMode"
      ]
    }
  },
  {
    "id": "KafkaOutput-Python",
    "runtime": "2",
    "files": {
      "readme.md": "# KafkaOutput - Python\r\n\r\nThe `KafkaOutput` makes it incredibly easy to send a new events to a Kafka Broker. This sample demonstrates a simple use case of sending data to a given Kafka Broker using Python.\r\n\r\n## How it works\r\n\r\nFor a `KafkaOutput` to work, you must provide a topic name which dictates where the messages should be sent to with authentication.\r\n\r\n## Configuration\r\n\r\n### EventHubs for Kafka\r\n\r\nAdd `BrokerList` and `KafkaPassword` to your `local.settings.json`\r\n\r\n_local.settings.json_\r\n\r\n```json\r\n{\r\n  \"IsEncrypted\": false,\r\n  \"Values\": {\r\n    \"AzureWebJobsStorage\": \"UseDevelopmentStorage=true\",\r\n    \"FUNCTIONS_WORKER_RUNTIME\": \"node\",\r\n    \"BrokerList\": \"{YOUR_EVENT_HUBS_NAMESPACE}.servicebus.windows.net:9093\",\r\n    \"KafkaPassword\": \"{EVENT_HUBS_CONNECTION_STRING}\"\r\n  }\r\n}\r\n```\r\n\r\n### Others\r\n\r\nModify `function.json` or `KafkaOutput` attribute according to your broker.",
      "sample.dat": "{\r\n    \"message\": \"hello\"\r\n}",
      "__init__.py": "import logging\r\n\r\nfrom azure.functions import HttpRequest, HttpResponse, Out\r\n\r\n\r\ndef main(req: HttpRequest, out: Out[str]) -> HttpResponse:\r\n    logging.info('Python HTTP trigger function processed a request.')\r\n\r\n    message = req.params.get('message')\r\n    if not message:\r\n        try:\r\n            req_body = req.get_json()\r\n        except ValueError:\r\n            pass\r\n        else:\r\n            message = req_body.get('message')\r\n\r\n    if message:\r\n        out.set(message)\r\n        return HttpResponse(f\"Message received: {message}. The message transfered to the kafka broker.\")\r\n    else:\r\n        return HttpResponse(\r\n            \"This HTTP triggered function executed successfully but no message was passed. Please pass message as request parameter or in body for sending data to Kafka\",\r\n            status_code=200\r\n        )\r\n"
    },
    "function": {
      "scriptFile": "__init__.py",
      "bindings": [
        {
          "authLevel": "function",
          "type": "httpTrigger",
          "direction": "in",
          "name": "req",
          "methods": [
            "get",
            "post"
          ]
        },
        {
          "type": "kafka",
          "direction": "out",
          "name": "out",
          "brokerList": "BrokerList",
          "topic": "topic",
          "username": "$ConnectionString",
          "password": "%KafkaPassword%",
          "protocol": "SASLSSL",
          "authenticationMode": "PLAIN"
        },
        {
          "type": "http",
          "direction": "out",
          "name": "$return"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "KafkaOutput",
      "description": "$KafkaOutput_description",
      "name": "Kafka output",
      "language": "Python",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": [
        "brokerList",
        "topic",
        "username",
        "password",
        "protocol",
        "authenticationMode"
      ]
    }
  },
  {
    "id": "KafkaOutput-TypeScript",
    "runtime": "2",
    "files": {
      "index.ts": "import { AzureFunction, Context, HttpRequest } from \"@azure/functions\"\r\n\r\nconst httpTrigger: AzureFunction = async function (context: Context, req: HttpRequest): Promise<void> {\r\n    context.log('HTTP trigger function processed a request.');\r\n    const message = (req.query.message || (req.body && req.body.message));\r\n    const responseMessage = message\r\n        ? \"Message received: \" + message + \". The message transfered to the kafka broker.\"\r\n        : \"This HTTP triggered function executed successfully. Pass a message in the query string or in the request body for a personalized response.\";\r\n    context.bindings.outputKafkaMessage = \"Message : \" + message;\r\n    context.res = {\r\n        // status: 200, /* Defaults to 200 */\r\n        body: responseMessage\r\n    };\r\n\r\n};\r\n\r\nexport default httpTrigger;",
      "readme.md": "# KafkaOutput - TypeScript\r\n\r\nThe `KafkaOutput` makes it incredibly easy to send a new events to a Kafka Broker. This sample demonstrates a simple use case of sending data to a given Kafka Broker using TypeScript.\r\n\r\n## How it works\r\n\r\nFor a `KafkaOutput` to work, you must provide a topic name which dictates where the messages should be sent to with authentication.\r\n\r\n## Configuration\r\n\r\n### EventHubs for Kafka\r\n\r\nAdd `BrokerList` and `KafkaPassword` to your `local.settings.json`\r\n\r\n_local.settings.json_\r\n\r\n```json\r\n{\r\n  \"IsEncrypted\": false,\r\n  \"Values\": {\r\n    \"AzureWebJobsStorage\": \"UseDevelopmentStorage=true\",\r\n    \"FUNCTIONS_WORKER_RUNTIME\": \"node\",\r\n    \"BrokerList\": \"{YOUR_EVENT_HUBS_NAMESPACE}.servicebus.windows.net:9093\",\r\n    \"KafkaPassword\": \"{EVENT_HUBS_CONNECTION_STRING}\"\r\n  }\r\n}\r\n```\r\n\r\n### Others\r\n\r\nModify `function.json` or `KafkaOutput` attribute according to your broker.",
      "sample.dat": "{\r\n    \"message\": \"hello\"\r\n}"
    },
    "function": {
      "bindings": [
        {
          "authLevel": "function",
          "type": "httpTrigger",
          "direction": "in",
          "name": "req",
          "methods": [
            "get",
            "post"
          ]
        },
        {
          "type": "kafka",
          "name": "outputKafkaMessage",
          "brokerList": "BrokerList",
          "topic": "topic",
          "username": "$ConnectionString",
          "password": "%KafkaPassword%",
          "protocol": "SASLSSL",
          "authenticationMode": "PLAIN",
          "direction": "out"
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "KafkaOutput",
      "description": "$KafkaOutput_description",
      "name": "Kafka output",
      "language": "TypeScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": [
        "brokerList",
        "topic",
        "username",
        "password",
        "protocol",
        "authenticationMode"
      ]
    }
  },
  {
    "id": "KafkaTrigger-CSharp",
    "runtime": "2",
    "files": {
      "readme.md": "# KafkaTrigger - C<span>#</span>\r\n\r\nThe `KafkaTrigger` makes it incredibly easy to react to new events from a Kafka Broker. This sample demonstrates a simple use case of processing data from a given Kafka Broker using C#.\r\n\r\n## How it works\r\n\r\nFor a `KafkaTrigger` to work, you must provide a topic name which dictates where the messages should be read from with authentication.\r\n\r\n## Configuration\r\n\r\n### EventHubs for Kafka\r\n\r\nAdd `BrokerList` and `KafkaPassword` to your `local.settings.json`\r\n\r\n_local.settings.json_\r\n\r\n```json\r\n{\r\n  \"IsEncrypted\": false,\r\n  \"Values\": {\r\n    \"AzureWebJobsStorage\": \"UseDevelopmentStorage=true\",\r\n    \"FUNCTIONS_WORKER_RUNTIME\": \"dotnet\",\r\n    \"BrokerList\": \"{YOUR_EVENT_HUBS_NAMESPACE}.servicebus.windows.net:9093\",\r\n    \"KafkaPassword\": \"{EVENT_HUBS_CONNECTION_STRING}\"\r\n  }\r\n}\r\n```\r\n\r\n### Others\r\n\r\nModify `function.json` or `KafkaTrigger` attribute according to your broker.",
      "run.csx": "#r \"Microsoft.Azure.WebJobs.Extensions.Kafka\"\r\n\r\nusing System;\r\nusing System.Text;\r\nusing Microsoft.Azure.WebJobs.Extensions.Kafka;\r\n\r\npublic static void Run(KafkaEventData<string> eventData, ILogger log)\r\n{\r\n    log.LogInformation($\"C# Queue trigger function processed: {eventData.Value}\");\r\n}\r\n",
      "sample.dat": "sample queue data"
    },
    "function": {
      "bindings": [
        {
          "name": "eventData",
          "type": "kafkaTrigger",
          "direction": "in",
          "brokerList": "BrokerList",
          "topic": "topic",
          "username": "$ConnectionString",
          "password": "%KafkaPassword%",
          "protocol": "saslSsl",
          "authenticationMode": "plain",
          "consumerGroup": "$Default"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "KafkaTrigger",
      "description": "$KafkaTrigger_description",
      "name": "Kafka trigger",
      "language": "C#",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": [
        "brokerList",
        "topic",
        "username",
        "password",
        "protocol",
        "authenticationMode",
        "consumerGroup"
      ]
    }
  },
  {
    "id": "KafkaTrigger-Custom",
    "runtime": "2",
    "files": {},
    "function": {
      "bindings": [
        {
          "name": "eventData",
          "type": "kafkaTrigger",
          "direction": "in",
          "brokerList": "BrokerList",
          "topic": "topic",
          "username": "$ConnectionString",
          "password": "%KafkaPassword%",
          "protocol": "saslSsl",
          "authenticationMode": "plain",
          "consumerGroup": "$Default"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "KafkaTrigger",
      "description": "$KafkaTrigger_description",
      "name": "Kafka trigger",
      "language": "Custom",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": [
        "brokerList",
        "topic",
        "username",
        "password",
        "protocol",
        "authenticationMode",
        "consumerGroup"
      ]
    }
  },
  {
    "id": "KafkaTrigger-JavaScript",
    "runtime": "2",
    "files": {
      "index.js": "var string_decode = require('string_decoder').StringDecoder;\r\n\r\nmodule.exports = async function (context, event) {\r\n    const dec = new string_decode('utf-8');\r\n    let event_str = dec.write(event);\r\n\r\n    context.log.info(`JavaScript Kafka trigger function called for message ${event_str}`);\r\n};",
      "readme.md": "# KafkaTrigger - JavaScript\r\n\r\nThe `KafkaTrigger` makes it incredibly easy to react to new events from a Kafka Broker. This sample demonstrates a simple use case of processing data from a given Kafka Broker using JavaScript.\r\n\r\n## How it works\r\n\r\nFor a `KafkaTrigger` to work, you must provide a topic name which dictates where the messages should be read from with authentication.\r\n\r\n## Configuration\r\n\r\n### EventHubs for Kafka\r\n\r\nAdd `BrokerList` and `KafkaPassword` to your `local.settings.json`\r\n\r\n_local.settings.json_\r\n\r\n```json\r\n{\r\n  \"IsEncrypted\": false,\r\n  \"Values\": {\r\n    \"AzureWebJobsStorage\": \"UseDevelopmentStorage=true\",\r\n    \"FUNCTIONS_WORKER_RUNTIME\": \"node\",\r\n    \"BrokerList\": \"{YOUR_EVENT_HUBS_NAMESPACE}.servicebus.windows.net:9093\",\r\n    \"KafkaPassword\": \"{EVENT_HUBS_CONNECTION_STRING}\"\r\n  }\r\n}\r\n```\r\n\r\n### Others\r\n\r\nModify `function.json` or `KafkaTrigger` attribute according to your broker.",
      "sample.dat": "sample queue data"
    },
    "function": {
      "bindings": [
        {
          "type": "kafkaTrigger",
          "name": "event",
          "direction": "in",
          "brokerList": "BrokerList",
          "topic": "topic",
          "username": "$ConnectionString",
          "password": "%KafkaPassword%",
          "protocol": "saslSsl",
          "authenticationMode": "plain",
          "consumerGroup": "$Default",
          "dataType": "binary"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "KafkaTrigger",
      "description": "$KafkaTrigger_description",
      "name": "Kafka trigger",
      "language": "JavaScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": [
        "brokerList",
        "topic",
        "username",
        "password",
        "protocol",
        "authenticationMode",
        "consumerGroup"
      ]
    }
  },
  {
    "id": "KafkaTrigger-PowerShell",
    "runtime": "2",
    "files": {
      "readme.md": "# KafkaTrigger - PowerShell\r\n\r\nThe `KafkaTrigger` makes it incredibly easy to react to new events from a Kafka Broker. This sample demonstrates a simple use case of processing data from a given Kafka Broker using PowerShell.\r\n\r\n## How it works\r\n\r\nFor a `KafkaTrigger` to work, you must provide a topic name which dictates where the messages should be read from with authentication.\r\n\r\n## Configuration\r\n\r\n### EventHubs for Kafka\r\n\r\nAdd `BrokerList` and `KafkaPassword` to your `local.settings.json`\r\n\r\n_local.settings.json_\r\n\r\n```json\r\n{\r\n  \"IsEncrypted\": false,\r\n  \"Values\": {\r\n    \"AzureWebJobsStorage\": \"UseDevelopmentStorage=true\",\r\n    \"FUNCTIONS_WORKER_RUNTIME\": \"powershell\",\r\n    \"FUNCTIONS_WORKER_RUNTIME_VERSION\": \"~7\",\r\n    \"BrokerList\": \"{YOUR_EVENT_HUBS_NAMESPACE}.servicebus.windows.net:9093\",\r\n    \"KafkaPassword\": \"{EVENT_HUBS_CONNECTION_STRING}\"\r\n  }\r\n}\r\n```\r\n\r\n### Others\r\n\r\nModify `function.json` or `KafkaTrigger` attribute according to your broker.",
      "run.ps1": "using namespace System.Net\r\n\r\nparam($kafkaEvent, $TriggerMetadata)\r\n\r\n$kafkaEvent \r\n\r\n$TriggerMetadata",
      "sample.dat": "sample queue data"
    },
    "function": {
      "bindings": [
        {
          "type": "kafkaTrigger",
          "name": "kafkaEvent",
          "direction": "in",
          "brokerList": "BrokerList",
          "topic": "topic",
          "username": "$ConnectionString",
          "password": "%KafkaPassword%",
          "protocol": "saslSsl",
          "authenticationMode": "plain",
          "consumerGroup": "$Default"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "KafkaTrigger",
      "description": "$KafkaTrigger_description",
      "name": "Kafka trigger",
      "language": "PowerShell",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": [
        "brokerList",
        "topic",
        "username",
        "password",
        "protocol",
        "authenticationMode",
        "consumerGroup"
      ]
    }
  },
  {
    "id": "KafkaTrigger-Python",
    "runtime": "2",
    "files": {
      "readme.md": "# KafkaTrigger - Python\r\n\r\nThe `KafkaTrigger` makes it incredibly easy to react to new events from a Kafka Broker. This sample demonstrates a simple use case of processing data from a given Kafka Broker using Python.\r\n\r\n## How it works\r\n\r\nFor a `KafkaTrigger` to work, you must provide a topic name which dictates where the messages should be read from with authentication.\r\n\r\n## Configuration\r\n\r\n### EventHubs for Kafka\r\n\r\nAdd `BrokerList` and `KafkaPassword` to your `local.settings.json`\r\n\r\n_local.settings.json_\r\n\r\n```json\r\n{\r\n  \"IsEncrypted\": false,\r\n  \"Values\": {\r\n    \"AzureWebJobsStorage\": \"UseDevelopmentStorage=true\",\r\n    \"FUNCTIONS_WORKER_RUNTIME\": \"python\",\r\n    \"BrokerList\": \"{YOUR_EVENT_HUBS_NAMESPACE}.servicebus.windows.net:9093\",\r\n    \"KafkaPassword\": \"{EVENT_HUBS_CONNECTION_STRING}\"\r\n  }\r\n}\r\n```\r\n\r\n### Others\r\n\r\nModify `function.json` or `KafkaTrigger` attribute according to your broker.",
      "sample.dat": "sample queue data",
      "__init__.py": "import logging\r\n\r\nfrom azure.functions import KafkaEvent\r\n\r\n\r\ndef main(kevent : KafkaEvent):\r\n    logging.info(kevent.get_body().decode('utf-8'))\r\n    logging.info(kevent.metadata)\r\n"
    },
    "function": {
      "scriptFile": "__init__.py",
      "bindings": [
        {
          "type": "kafkaTrigger",
          "name": "kevent",
          "direction": "in",
          "brokerList": "BrokerList",
          "topic": "topic",
          "username": "$ConnectionString",
          "password": "%KafkaPassword%",
          "protocol": "saslSsl",
          "authenticationMode": "plain",
          "consumerGroup": "$Default"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "KafkaTrigger",
      "description": "$KafkaTrigger_description",
      "name": "Kafka trigger",
      "language": "Python",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": [
        "brokerList",
        "topic",
        "username",
        "password",
        "protocol",
        "authenticationMode",
        "consumerGroup"
      ]
    }
  },
  {
    "id": "KafkaTrigger-TypeScript",
    "runtime": "2",
    "files": {
      "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\r\n\r\n// This is to describe the metadata of a Kafka event\r\nclass KafkaEvent {\r\n    Offset : number;\r\n    Partition : number;\r\n    Topic : string;\r\n    Timestamp : string;\r\n    Value : string;\r\n    \r\n    constructor(metadata:any) {\r\n        this.Offset = metadata.Offset;\r\n        this.Partition = metadata.Partition;\r\n        this.Topic = metadata.Topic;\r\n        this.Timestamp = metadata.Timestamp;\r\n        this.Value = metadata.Value;\r\n    }\r\n\r\n    public getValue<T>() : T {\r\n        return JSON.parse(this.Value).payload;\r\n    }\r\n}\r\n\r\nconst kafkaTrigger: AzureFunction = async function (context: Context, event_str: string): Promise<void> {\r\n\r\n    let event_obj = new KafkaEvent(eval(event_str));\r\n\r\n    context.log(\"Event Offset: \" + event_obj.Offset);\r\n    context.log(\"Event Partition: \" + event_obj.Partition);\r\n    context.log(\"Event Topic: \" + event_obj.Topic);\r\n    context.log(\"Event Timestamp: \" + event_obj.Timestamp);\r\n    context.log(\"Event Value (as string): \" + event_obj.Value);\r\n};\r\n\r\nexport default kafkaTrigger;",
      "readme.md": "# KafkaTrigger - TypeScript\r\n\r\nThe `KafkaTrigger` makes it incredibly easy to react to new events from a Kafka Broker. This sample demonstrates a simple use case of processing data from a given Kafka Broker using TypeScript.\r\n\r\n## How it works\r\n\r\nFor a `KafkaTrigger` to work, you must provide a topic name which dictates where the messages should be read from with authentication.\r\n\r\n## Configuration\r\n\r\n### EventHubs for Kafka\r\n\r\nAdd `BrokerList` and `KafkaPassword` to your `local.settings.json`\r\n\r\n_local.settings.json_\r\n\r\n```json\r\n{\r\n  \"IsEncrypted\": false,\r\n  \"Values\": {\r\n    \"AzureWebJobsStorage\": \"UseDevelopmentStorage=true\",\r\n    \"FUNCTIONS_WORKER_RUNTIME\": \"node\",\r\n    \"BrokerList\": \"{YOUR_EVENT_HUBS_NAMESPACE}.servicebus.windows.net:9093\",\r\n    \"KafkaPassword\": \"{EVENT_HUBS_CONNECTION_STRING}\"\r\n  }\r\n}\r\n```\r\n\r\n### Others\r\n\r\nModify `function.json` or `KafkaTrigger` attribute according to your broker.",
      "sample.dat": "sample queue data"
    },
    "function": {
      "bindings": [
        {
          "type": "kafkaTrigger",
          "direction": "in",
          "name": "event",
          "brokerList": "BrokerList",
          "topic": "topic",
          "username": "$ConnectionString",
          "password": "%KafkaPassword%",
          "protocol": "saslSsl",
          "authenticationMode": "plain",
          "consumerGroup": "$Default"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "KafkaTrigger",
      "description": "$KafkaTrigger_description",
      "name": "Kafka trigger",
      "language": "TypeScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": [
        "brokerList",
        "topic",
        "username",
        "password",
        "protocol",
        "authenticationMode",
        "consumerGroup"
      ]
    }
  },
  {
    "id": "QueueTrigger-CSharp",
    "runtime": "2",
    "files": {
      "readme.md": "# QueueTrigger - C<span>#</span>\r\n\r\nThe `QueueTrigger` makes it incredibly easy to react to new Queues inside of Azure Queue Storage. This sample demonstrates a simple use case of processing data from a given Queue using C#.\r\n\r\n## How it works\r\n\r\nFor a `QueueTrigger` to work, you must provide a queue name that defines the queue messages will be read from.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
      "run.csx": "using System;\r\n\r\npublic static void Run(string myQueueItem, ILogger log)\r\n{\r\n    log.LogInformation($\"C# Queue trigger function processed: {myQueueItem}\");\r\n}\r\n",
      "sample.dat": "sample queue data"
    },
    "function": {
      "bindings": [
        {
          "name": "myQueueItem",
          "type": "queueTrigger",
          "direction": "in",
          "queueName": "myqueue-items",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "QueueTrigger",
      "description": "$QueueTrigger_description",
      "name": "Azure Queue Storage trigger",
      "language": "C#",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "queue",
      "enabledInTryMode": true,
      "userPrompt": [
        "connection",
        "queueName"
      ]
    }
  },
  {
    "id": "QueueTrigger-Custom",
    "runtime": "2",
    "files": {},
    "function": {
      "bindings": [
        {
          "name": "myQueueItem",
          "type": "queueTrigger",
          "direction": "in",
          "queueName": "js-queue-items",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "QueueTrigger",
      "description": "$QueueTrigger_description",
      "name": "Azure Queue Storage trigger",
      "language": "Custom",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "queue",
      "enabledInTryMode": true,
      "userPrompt": [
        "connection",
        "queueName"
      ]
    }
  },
  {
    "id": "QueueTrigger-JavaScript",
    "runtime": "2",
    "files": {
      "index.js": "module.exports = async function (context, myQueueItem) {\r\n    context.log('JavaScript queue trigger function processed work item', myQueueItem);\r\n};",
      "readme.md": "# QueueTrigger - JavaScript\r\n\r\nThe `QueueTrigger` makes it incredibly easy to react to new Queues inside of Azure Queue Storage. This sample demonstrates a simple use case of processing data from a given Queue using C#.\r\n\r\n## How it works\r\n\r\nFor a `QueueTrigger` to work, you provide a path which dictates where the queue messages are located inside your container.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
      "sample.dat": "sample queue data"
    },
    "function": {
      "bindings": [
        {
          "name": "myQueueItem",
          "type": "queueTrigger",
          "direction": "in",
          "queueName": "js-queue-items",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "QueueTrigger",
      "description": "$QueueTrigger_description",
      "name": "Azure Queue Storage trigger",
      "language": "JavaScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "queue",
      "enabledInTryMode": true,
      "userPrompt": [
        "connection",
        "queueName"
      ]
    }
  },
  {
    "id": "QueueTrigger-PowerShell",
    "runtime": "2",
    "files": {
      "readme.md": "# QueueTrigger - PowerShell\r\n\r\nThe `QueueTrigger` makes it incredibly easy to react to new Queues inside of [Azure Queue Storage](https://azure.microsoft.com/en-us/services/storage/queues/).\r\nThis sample demonstrates a simple use case of processing data from a given Queue using PowerShell.\r\n\r\n## How it works\r\n\r\nFor a `QueueTrigger` to work, you provide a path which dictates where the queue messages are located inside your container.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation\r\n",
      "run.ps1": "# Input bindings are passed in via param block.\r\nparam($QueueItem, $TriggerMetadata)\r\n\r\n# Write out the queue message and insertion time to the information log.\r\nWrite-Host \"PowerShell queue trigger function processed work item: $QueueItem\"\r\nWrite-Host \"Queue item insertion time: $($TriggerMetadata.InsertionTime)\"\r\n",
      "sample.dat": "sample queue data"
    },
    "function": {
      "bindings": [
        {
          "name": "QueueItem",
          "type": "queueTrigger",
          "direction": "in",
          "queueName": "ps-queue-items",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "QueueTrigger",
      "description": "$QueueTrigger_description",
      "name": "Azure Queue Storage trigger",
      "language": "PowerShell",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "queue",
      "enabledInTryMode": true,
      "userPrompt": [
        "connection",
        "queueName"
      ]
    }
  },
  {
    "id": "QueueTrigger-Python",
    "runtime": "2",
    "files": {
      "readme.md": "# QueueTrigger - Python\r\n\r\nThe `QueueTrigger` makes it incredibly easy to react to new Queues inside of Azure Queue Storage. This sample demonstrates a simple use case of processing data from a given Queue.\r\n\r\n## How it works\r\n\r\nFor a `QueueTrigger` to work, you provide a path which dictates where the queue messages are located inside your container.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation\r\n",
      "sample.dat": "sample queue data",
      "__init__.py": "import logging\r\n\r\nfrom azure.functions import QueueMessage\r\n\r\n\r\ndef main(msg: QueueMessage) -> None:\r\n    logging.info('Python queue trigger function processed a queue item: %s',\r\n                 msg.get_body().decode('utf-8'))\r\n"
    },
    "function": {
      "scriptFile": "__init__.py",
      "bindings": [
        {
          "name": "msg",
          "type": "queueTrigger",
          "direction": "in",
          "queueName": "python-queue-items",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "QueueTrigger",
      "description": "$QueueTrigger_description",
      "name": "Azure Queue Storage trigger",
      "language": "Python",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "queue",
      "enabledInTryMode": true,
      "userPrompt": [
        "connection",
        "queueName"
      ],
      "filters": [
        "Python3"
      ]
    }
  },
  {
    "id": "QueueTrigger-TypeScript",
    "runtime": "2",
    "files": {
      "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\r\n\r\nconst queueTrigger: AzureFunction = async function (context: Context, myQueueItem: any): Promise<void> {\r\n    context.log('Queue trigger function processed work item', myQueueItem);\r\n};\r\n\r\nexport default queueTrigger;\r\n",
      "readme.md": "# QueueTrigger - TypeScript\r\n\r\nThe `QueueTrigger` makes it incredibly easy to react to new Queues inside of Azure Queue Storage. This sample demonstrates a simple use case of processing data from a given Queue using C#.\r\n\r\n## How it works\r\n\r\nFor a `QueueTrigger` to work, you provide a path which dictates where the queue messages are located inside your container.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
      "sample.dat": "sample queue data"
    },
    "function": {
      "bindings": [
        {
          "name": "myQueueItem",
          "type": "queueTrigger",
          "direction": "in",
          "queueName": "js-queue-items",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "QueueTrigger",
      "description": "$QueueTrigger_description",
      "name": "Azure Queue Storage trigger",
      "language": "TypeScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "queue",
      "enabledInTryMode": true,
      "userPrompt": [
        "connection",
        "queueName"
      ]
    }
  },
  {
    "id": "RabbitMQTrigger-CSharp",
    "runtime": "2",
    "files": {
      "readme.md": "# RabbitMQTrigger - C<span>#</span>\r\n\r\nThe `RabbitMQTrigger` makes it incredibly easy to react to new events from a RabbitMQ queue. This sample demonstrates a simple use case of processing data from a given RabbitMQ Queue using C#.\r\n\r\n## How it works\r\n\r\nFor a `RabbitMQTrigger` to work, you must provide a queue name which dictates where the queue messages should be read from.",
      "run.csx": "using System;\r\n\r\npublic static void Run(string myQueueItem, ILogger log)\r\n{\r\n    log.LogInformation($\"C# Queue trigger function processed: {myQueueItem}\");\r\n}\r\n",
      "sample.dat": "sample queue data"
    },
    "function": {
      "bindings": [
        {
          "name": "myQueueItem",
          "type": "rabbitMQTrigger",
          "direction": "in",
          "queueName": "",
          "connectionStringSetting": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "RabbitMQTrigger",
      "description": "$RabbitMQTrigger_description",
      "name": "RabbitMQ trigger",
      "language": "C#",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "RabbitMQ",
      "enabledInTryMode": true,
      "userPrompt": [
        "connectionStringSetting",
        "queueName"
      ]
    }
  },
  {
    "id": "RabbitMQTrigger-Custom",
    "runtime": "2",
    "files": {},
    "function": {
      "bindings": [
        {
          "name": "myQueueItem",
          "type": "rabbitMqTrigger",
          "direction": "in",
          "queueName": "",
          "connectionStringSetting": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "RabbitMQTrigger",
      "description": "$RabbitMQTrigger_description",
      "name": "RabbitMQ trigger",
      "language": "Custom",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "RabbitMQ",
      "enabledInTryMode": true,
      "userPrompt": [
        "connectionStringSetting",
        "queueName"
      ]
    }
  },
  {
    "id": "RabbitMQTrigger-JavaScript",
    "runtime": "2",
    "files": {
      "index.js": "module.exports = async function (context, myQueueItem) {\r\n    context.log('JavaScript rabbitmq trigger function processed work item', myQueueItem);\r\n};",
      "readme.md": "# RabbitMQTrigger - C<span>#</span>\r\n\r\nThe `RabbitMQTrigger` makes it incredibly easy to react to new events from a RabbitMQ queue. This sample demonstrates a simple use case of processing data from a given RabbitMQ Queue using C#.\r\n\r\n## How it works\r\n\r\nFor a `RabbitMQTrigger` to work, you must provide a queue name which dictates where the queue messages should be read from.",
      "sample.dat": "sample queue data"
    },
    "function": {
      "bindings": [
        {
          "name": "myQueueItem",
          "type": "rabbitMqTrigger",
          "direction": "in",
          "queueName": "",
          "connectionStringSetting": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "RabbitMQTrigger",
      "description": "$RabbitMQTrigger_description",
      "name": "RabbitMQ trigger",
      "language": "JavaScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "RabbitMQ",
      "enabledInTryMode": true,
      "userPrompt": [
        "connectionStringSetting",
        "queueName"
      ]
    }
  },
  {
    "id": "RabbitMQTrigger-PowerShell",
    "runtime": "2",
    "files": {
      "readme.md": "# RabbitMQTrigger - C<span>#</span>\r\n\r\nThe `RabbitMQTrigger` makes it incredibly easy to react to new events from a RabbitMQ queue. This sample demonstrates a simple use case of processing data from a given RabbitMQ Queue using C#.\r\n\r\n## How it works\r\n\r\nFor a `RabbitMQTrigger` to work, you must provide a queue name which dictates where the queue messages should be read from.",
      "run.ps1": "# Input bindings are passed in via param block.\r\nparam([string] $MyQueueItem, $TriggerMetadata)\r\n\r\n# Write out the queue message and insertion time to the information log.\r\nWrite-Host \"PowerShell rabbitmq trigger function processed work item: $MyQueueItem\"\r\nWrite-Host \"Queue item insertion time: $($TriggerMetadata.InsertionTime)\"\r\n",
      "sample.dat": "sample queue data"
    },
    "function": {
      "bindings": [
        {
          "name": "myQueueItem",
          "type": "rabbitMqTrigger",
          "direction": "in",
          "queueName": "",
          "connectionStringSetting": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "RabbitMQTrigger",
      "description": "$RabbitMQTrigger_description",
      "name": "RabbitMQ trigger",
      "language": "Powershell",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "RabbitMQ",
      "enabledInTryMode": true,
      "userPrompt": [
        "connectionStringSetting",
        "queueName"
      ]
    }
  },
  {
    "id": "RabbitMQTrigger-Python",
    "runtime": "2",
    "files": {
      "readme.md": "# RabbitMQTrigger - C<span>#</span>\r\n\r\nThe `RabbitMQTrigger` makes it incredibly easy to react to new events from a RabbitMQ queue. This sample demonstrates a simple use case of processing data from a given RabbitMQ Queue using C#.\r\n\r\n## How it works\r\n\r\nFor a `RabbitMQTrigger` to work, you must provide a queue name which dictates where the queue messages should be read from.",
      "sample.dat": "sample queue data",
      "__init__.py": "import logging\r\n\r\ndef main(myQueueItem) -> None:\r\n    logging.info('Python rabbitmq trigger function processed a queue item: %s', myQueueItem)\r\n"
    },
    "function": {
      "scriptFile": "__init__.py",
      "bindings": [
        {
          "name": "myQueueItem",
          "type": "rabbitMqTrigger",
          "direction": "in",
          "queueName": "",
          "connectionStringSetting": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "RabbitMQTrigger",
      "description": "$RabbitMQTrigger_description",
      "name": "RabbitMQ trigger",
      "language": "Python",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "RabbitMQ",
      "enabledInTryMode": true,
      "userPrompt": [
        "connectionStringSetting",
        "queueName"
      ]
    }
  },
  {
    "id": "RabbitMQTrigger-TypeScript",
    "runtime": "2",
    "files": {
      "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\r\n\r\nconst rabbitmqTrigger: AzureFunction = async function (context: Context, myQueueItem: string): Promise<void> {\r\n    context.log('RabbitMQ trigger function processed work item', myQueueItem);\r\n};\r\n\r\nexport default rabbitmqTrigger;\r\n",
      "readme.md": "# RabbitMQTrigger - C<span>#</span>\r\n\r\nThe `RabbitMQTrigger` makes it incredibly easy to react to new events from a RabbitMQ queue. This sample demonstrates a simple use case of processing data from a given RabbitMQ Queue using C#.\r\n\r\n## How it works\r\n\r\nFor a `RabbitMQTrigger` to work, you must provide a queue name which dictates where the queue messages should be read from.",
      "sample.dat": "sample queue data"
    },
    "function": {
      "bindings": [
        {
          "name": "myQueueItem",
          "type": "rabbitMqTrigger",
          "direction": "in",
          "queueName": "",
          "connectionStringSetting": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "RabbitMQTrigger",
      "description": "$RabbitMQTrigger_description",
      "name": "RabbitMQ trigger",
      "language": "TypeScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "RabbitMQ",
      "enabledInTryMode": true,
      "userPrompt": [
        "connectionStringSetting",
        "queueName"
      ]
    }
  },
  {
    "id": "SendGrid-CSharp",
    "runtime": "2",
    "files": {
      "run.csx": "// The 'From' and 'To' fields are automatically populated with the values specified by the binding settings.\r\n//\r\n// You can also optionally configure the default From/To addresses globally via host.config, e.g.:\r\n//\r\n// {\r\n//   \"sendGrid\": {\r\n//      \"to\": \"user@host.com\",\r\n//      \"from\": \"Azure Functions <samples@functions.com>\"\r\n//   }\r\n// }\r\n#r \"SendGrid\"\r\n\r\nusing System;\r\nusing SendGrid.Helpers.Mail;\r\nusing Microsoft.Azure.WebJobs.Host;\r\n\r\npublic static SendGridMessage Run(Order order, ILogger log)\r\n{\r\n    log.LogInformation($\"C# Queue trigger function processed order: {order.OrderId}\");\r\n\r\n    SendGridMessage message = new SendGridMessage()\r\n    {\r\n        Subject = $\"Thanks for your order (#{order.OrderId})!\"\r\n    };\r\n\r\n    message.AddContent(\"text/plain\", $\"{order.CustomerName}, your order ({order.OrderId}) is being processed!\");\r\n    return message;\r\n}\r\npublic class Order\r\n{\r\n    public string OrderId { get; set; }\r\n    public string CustomerName { get; set; }\r\n    public string CustomerEmail { get; set; }\r\n}\r\n",
      "sample.dat": "{ \"OrderId\": 12345, \"CustomerName\": \"Joe Schmoe\", \"CustomerEmail\": \"joeschmoe@foo.com\" }"
    },
    "function": {
      "bindings": [
        {
          "type": "queueTrigger",
          "name": "order",
          "direction": "in",
          "queueName": "samples-orders"
        },
        {
          "type": "sendGrid",
          "name": "$return",
          "direction": "out",
          "apiKey": "SendGridApiKey",
          "from": "Azure Functions <samples@functions.com>",
          "to": "{CustomerEmail}"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "SendGrid",
      "description": "$SendGrid_description",
      "name": "SendGrid",
      "language": "C#",
      "category": [
        "$temp_category_samples",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": [
        "to",
        "from",
        "apiKey"
      ]
    }
  },
  {
    "id": "SendGrid-Custom",
    "runtime": "2",
    "files": {},
    "function": {
      "bindings": [
        {
          "type": "queueTrigger",
          "name": "order",
          "direction": "in",
          "queueName": "samples-orders"
        },
        {
          "type": "sendGrid",
          "name": "message",
          "direction": "out",
          "apiKey": "SendGridApiKey",
          "from": "Azure Functions <samples@functions.com>",
          "to": "{customerEmail}",
          "subject": "",
          "text": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "SendGrid",
      "description": "$SendGrid_description",
      "name": "SendGrid",
      "language": "Custom",
      "category": [
        "$temp_category_samples",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": [
        "to",
        "from",
        "subject",
        "text",
        "apiKey"
      ]
    }
  },
  {
    "id": "SendGrid-JavaScript",
    "runtime": "2",
    "files": {
      "index.js": "var util = require('util');\r\n\r\n// The 'From' and 'To' fields are automatically populated with the values specified by the binding settings.\r\n//\r\n// You can also optionally configure the default From/To addresses globally via host.config, e.g.:\r\n//\r\n// {\r\n//   \"sendGrid\": {\r\n//      \"to\": \"user@host.com\",\r\n//      \"from\": \"Azure Functions <samples@functions.com>\"\r\n//   }\r\n// }\r\nmodule.exports = async function (context, order) {\r\n    context.log('JavaScript queue trigger function processed order', order.orderId);\r\n\r\n    context.bindings.message = {\r\n        subject: util.format('Thanks for your order (#%d)!', order.orderId),\r\n        content: [{\r\n            type: 'text/plain',\r\n            value: util.format(\"%s, your order (%d) is being processed!\", order.customerName, order.orderId)\r\n        }]\r\n    };\r\n}",
      "sample.dat": "{ \"orderId\": 12345, \"customerName\": \"Joe Schmoe\", \"customerEmail\": \"joeschmoe@foo.com\" }"
    },
    "function": {
      "bindings": [
        {
          "type": "queueTrigger",
          "name": "order",
          "direction": "in",
          "queueName": "samples-orders"
        },
        {
          "type": "sendGrid",
          "name": "message",
          "direction": "out",
          "apiKey": "SendGridApiKey",
          "from": "Azure Functions <samples@functions.com>",
          "to": "{customerEmail}",
          "subject": "",
          "text": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "SendGrid",
      "description": "$SendGrid_description",
      "name": "SendGrid",
      "language": "JavaScript",
      "category": [
        "$temp_category_samples",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": [
        "to",
        "from",
        "subject",
        "text",
        "apiKey"
      ]
    }
  },
  {
    "id": "SendGrid-PowerShell",
    "runtime": "2",
    "files": {
      "run.ps1": "# The 'From' and 'To' fields are automatically populated with the values specified by the binding settings.\r\n#\r\n# You can also optionally configure the default From/To addresses globally via host.config, e.g.:\r\n#\r\n# {\r\n#   \"sendGrid\": {\r\n#      \"to\": \"user@host.com\",\r\n#      \"from\": \"Azure Functions <samples@functions.com>\"\r\n#   }\r\n# }\r\nparam($order, $TriggerMetadata)\r\n\r\nWrite-Host \"JavaScript queue trigger function processed order: $($order.orderId)\"\r\n\r\nPush-OutputBinding -Name Response -Value (@{\r\n    subject = \"Thanks for your order (#$($order.orderId))!\"\r\n    content = @(@{\r\n        type = 'text/plain'\r\n        value = \"$($order.customerName), your order ($($order.orderId)) is being processed!\"\r\n    })\r\n})\r\n",
      "sample.dat": "{ \"orderId\": 12345, \"customerName\": \"Joe Schmoe\", \"customerEmail\": \"joeschmoe@foo.com\" }"
    },
    "function": {
      "bindings": [
        {
          "type": "queueTrigger",
          "name": "order",
          "direction": "in",
          "queueName": "samples-orders"
        },
        {
          "type": "sendGrid",
          "name": "message",
          "direction": "out",
          "apiKey": "SendGridApiKey",
          "from": "Azure Functions <samples@functions.com>",
          "to": "{customerEmail}",
          "subject": "",
          "text": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "SendGrid",
      "description": "$SendGrid_description",
      "name": "SendGrid",
      "language": "PowerShell",
      "category": [
        "$temp_category_samples",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": [
        "to",
        "from",
        "subject",
        "text",
        "apiKey"
      ]
    }
  },
  {
    "id": "SendGrid-TypeScript",
    "runtime": "2",
    "files": {
      "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\r\n\r\n// The 'From' and 'To' fields are automatically populated with the values specified by the binding settings.\r\n//\r\n// You can also optionally configure the default From/To addresses globally via host.config, e.g.:\r\n//\r\n// {\r\n//   \"sendGrid\": {\r\n//      \"to\": \"user@host.com\",\r\n//      \"from\": \"Azure Functions <samples@functions.com>\"\r\n//   }\r\n// }\r\n\r\nconst sendGrid: AzureFunction =  async function (context: Context, order: any): Promise<void> {\r\n    context.log('Queue trigger function processed order', order.orderId);\r\n\r\n    context.bindings.message = {\r\n        subject: `Thanks for your order (#${order.orderId})!`,\r\n        content: [{\r\n            type: 'text/plain',\r\n            value: `${order.customerName}, your order (${order.orderId}) is being processed!`\r\n        }]\r\n    };\r\n}\r\n\r\nexport default sendGrid;\r\n",
      "sample.dat": "{ \"orderId\": 12345, \"customerName\": \"Joe Schmoe\", \"customerEmail\": \"joeschmoe@foo.com\" }"
    },
    "function": {
      "bindings": [
        {
          "type": "queueTrigger",
          "name": "order",
          "direction": "in",
          "queueName": "samples-orders"
        },
        {
          "type": "sendGrid",
          "name": "message",
          "direction": "out",
          "apiKey": "SendGridApiKey",
          "from": "Azure Functions <samples@functions.com>",
          "to": "{customerEmail}",
          "subject": "",
          "text": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "SendGrid",
      "description": "$SendGrid_description",
      "name": "SendGrid",
      "language": "TypeScript",
      "category": [
        "$temp_category_samples",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": [
        "to",
        "from",
        "subject",
        "text",
        "apiKey"
      ]
    }
  },
  {
    "id": "ServiceBusQueueTrigger-CSharp",
    "runtime": "2",
    "files": {
      "run.csx": "using System;\r\nusing System.Threading.Tasks;\r\n\r\npublic static void Run(string myQueueItem, ILogger log)\r\n{\r\n    log.LogInformation($\"C# ServiceBus queue trigger function processed message: {myQueueItem}\");\r\n}\r\n",
      "sample.dat": "Service Bus Message"
    },
    "function": {
      "bindings": [
        {
          "name": "myQueueItem",
          "type": "serviceBusTrigger",
          "direction": "in",
          "queueName": "myqueue",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ServiceBusQueueTrigger",
      "description": "$ServiceBusQueueTrigger_description",
      "name": "Azure Service Bus Queue trigger",
      "language": "C#",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "serviceBus",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "queueName"
      ]
    }
  },
  {
    "id": "ServiceBusQueueTrigger-Custom",
    "runtime": "2",
    "files": {},
    "function": {
      "bindings": [
        {
          "name": "mySbMsg",
          "type": "serviceBusTrigger",
          "direction": "in",
          "queueName": "myinputqueue",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ServiceBusQueueTrigger",
      "description": "$ServiceBusQueueTrigger_description",
      "name": "Azure Service Bus Queue trigger",
      "language": "Custom",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "serviceBus",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "queueName"
      ]
    }
  },
  {
    "id": "ServiceBusQueueTrigger-JavaScript",
    "runtime": "2",
    "files": {
      "index.js": "module.exports = async function(context, mySbMsg) {\r\n    context.log('JavaScript ServiceBus queue trigger function processed message', mySbMsg);\r\n};",
      "sample.dat": "Service Bus Message"
    },
    "function": {
      "bindings": [
        {
          "name": "mySbMsg",
          "type": "serviceBusTrigger",
          "direction": "in",
          "queueName": "myinputqueue",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ServiceBusQueueTrigger",
      "description": "$ServiceBusQueueTrigger_description",
      "name": "Azure Service Bus Queue trigger",
      "language": "JavaScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "serviceBus",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "queueName"
      ]
    }
  },
  {
    "id": "ServiceBusQueueTrigger-PowerShell",
    "runtime": "2",
    "files": {
      "run.ps1": "param([string] $mySbMsg, $TriggerMetadata)\r\n\r\nWrite-Host \"PowerShell ServiceBus queue trigger function processed message: $mySbMsg\"\r\n",
      "sample.dat": "Service Bus Message"
    },
    "function": {
      "bindings": [
        {
          "name": "mySbMsg",
          "type": "serviceBusTrigger",
          "direction": "in",
          "queueName": "myinputqueue",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ServiceBusQueueTrigger",
      "description": "$ServiceBusQueueTrigger_description",
      "name": "Azure Service Bus Queue trigger",
      "language": "PowerShell",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "serviceBus",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "queueName"
      ]
    }
  },
  {
    "id": "ServiceBusQueueTrigger-Python",
    "runtime": "2",
    "files": {
      "sample.dat": "Service Bus Message",
      "__init__.py": "import logging\r\n\r\nfrom azure.functions import ServiceBusMessage\r\n\r\n\r\ndef main(msg: ServiceBusMessage):\r\n    logging.info('Python ServiceBus queue trigger processed message: %s',\r\n                 msg.get_body().decode('utf-8'))\r\n"
    },
    "function": {
      "scriptFile": "__init__.py",
      "bindings": [
        {
          "name": "msg",
          "type": "serviceBusTrigger",
          "direction": "in",
          "queueName": "myinputqueue",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ServiceBusQueueTrigger",
      "description": "$ServiceBusQueueTrigger_description",
      "name": "Azure Service Bus Queue trigger",
      "language": "Python",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "serviceBus",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "queueName"
      ]
    }
  },
  {
    "id": "ServiceBusQueueTrigger-TypeScript",
    "runtime": "2",
    "files": {
      "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\r\n\r\nconst serviceBusQueueTrigger: AzureFunction = async function(context: Context, mySbMsg: any): Promise<void> {\r\n    context.log('ServiceBus queue trigger function processed message', mySbMsg);\r\n};\r\n\r\nexport default serviceBusQueueTrigger;\r\n",
      "sample.dat": "Service Bus Message"
    },
    "function": {
      "bindings": [
        {
          "name": "mySbMsg",
          "type": "serviceBusTrigger",
          "direction": "in",
          "queueName": "myinputqueue",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ServiceBusQueueTrigger",
      "description": "$ServiceBusQueueTrigger_description",
      "name": "Azure Service Bus Queue trigger",
      "language": "TypeScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "serviceBus",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "queueName"
      ]
    }
  },
  {
    "id": "ServiceBusTopicTrigger-CSharp",
    "runtime": "2",
    "files": {
      "run.csx": "using System;\r\nusing System.Threading.Tasks;\r\n\r\npublic static void Run(string mySbMsg, ILogger log)\r\n{\r\n    log.LogInformation($\"C# ServiceBus topic trigger function processed message: {mySbMsg}\");\r\n}\r\n",
      "sample.dat": "Service Bus Message"
    },
    "function": {
      "bindings": [
        {
          "name": "mySbMsg",
          "type": "serviceBusTrigger",
          "direction": "in",
          "topicName": "mytopic",
          "subscriptionName": "mysubscription",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ServiceBusTopicTrigger",
      "description": "$ServiceBusTopicTrigger_description",
      "name": "Azure Service Bus Topic trigger",
      "language": "C#",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "serviceBus",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "topicName",
        "subscriptionName"
      ]
    }
  },
  {
    "id": "ServiceBusTopicTrigger-Custom",
    "runtime": "2",
    "files": {},
    "function": {
      "bindings": [
        {
          "name": "mySbMsg",
          "type": "serviceBusTrigger",
          "direction": "in",
          "topicName": "mytopic",
          "subscriptionName": "mysubscription",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ServiceBusTopicTrigger",
      "description": "$ServiceBusTopicTrigger_description",
      "name": "Azure Service Bus Topic trigger",
      "language": "Custom",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "serviceBus",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "topicName",
        "subscriptionName"
      ]
    }
  },
  {
    "id": "ServiceBusTopicTrigger-JavaScript",
    "runtime": "2",
    "files": {
      "index.js": "module.exports = async function(context, mySbMsg) {\r\n    context.log('JavaScript ServiceBus topic trigger function processed message', mySbMsg);\r\n};",
      "sample.dat": "Service Bus Message"
    },
    "function": {
      "bindings": [
        {
          "name": "mySbMsg",
          "type": "serviceBusTrigger",
          "direction": "in",
          "topicName": "mytopic",
          "subscriptionName": "mysubscription",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ServiceBusTopicTrigger",
      "description": "$ServiceBusTopicTrigger_description",
      "name": "Azure Service Bus Topic trigger",
      "language": "JavaScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "serviceBus",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "topicName",
        "subscriptionName"
      ]
    }
  },
  {
    "id": "ServiceBusTopicTrigger-PowerShell",
    "runtime": "2",
    "files": {
      "run.ps1": "param([string] $mySbMsg, $TriggerMetadata)\r\n\r\nWrite-Host \"PowerShell ServiceBus topic trigger function processed message: $mySbMsg\"\r\n",
      "sample.dat": "Service Bus Message"
    },
    "function": {
      "bindings": [
        {
          "name": "mySbMsg",
          "type": "serviceBusTrigger",
          "direction": "in",
          "topicName": "mytopic",
          "subscriptionName": "mysubscription",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ServiceBusTopicTrigger",
      "description": "$ServiceBusTopicTrigger_description",
      "name": "Azure Service Bus Topic trigger",
      "language": "PowerShell",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "serviceBus",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "topicName",
        "subscriptionName"
      ]
    }
  },
  {
    "id": "ServiceBusTopicTrigger-Python",
    "runtime": "2",
    "files": {
      "README.md": "# Python ServiceBusTopicTrigger\r\n",
      "sample.dat": "Service Bus Message",
      "__init__.py": "import logging\r\n\r\nfrom azure.functions import ServiceBusMessage\r\n\r\n\r\ndef main(message: ServiceBusMessage):\r\n    # Log the Service Bus Message as plaintext\r\n\r\n    message_content_type = message.content_type\r\n    message_body = message.get_body().decode(\"utf-8\")\r\n\r\n    logging.info(\"Python ServiceBus topic trigger processed message.\")\r\n    logging.info(\"Message Content Type: \" + message_content_type)\r\n    logging.info(\"Message Body: \" + message_body)\r\n"
    },
    "function": {
      "scriptFile": "__init__.py",
      "entryPoint": "main",
      "bindings": [
        {
          "name": "message",
          "type": "serviceBusTrigger",
          "direction": "in",
          "topicName": "mytopic",
          "subscriptionName": "mysubscription",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ServiceBusTopicTrigger",
      "description": "$ServiceBusTopicTrigger_description",
      "name": "Azure Service Bus Topic trigger",
      "language": "Python",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "serviceBus",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "topicName",
        "subscriptionName"
      ]
    }
  },
  {
    "id": "ServiceBusTopicTrigger-TypeScript",
    "runtime": "2",
    "files": {
      "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\r\n\r\nconst serviceBusTopicTrigger: AzureFunction = async function(context: Context, mySbMsg: any): Promise<void> {\r\n    context.log('ServiceBus topic trigger function processed message', mySbMsg);\r\n};\r\n\r\nexport default serviceBusTopicTrigger;\r\n",
      "sample.dat": "Service Bus Message"
    },
    "function": {
      "bindings": [
        {
          "name": "mySbMsg",
          "type": "serviceBusTrigger",
          "direction": "in",
          "topicName": "mytopic",
          "subscriptionName": "mysubscription",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ServiceBusTopicTrigger",
      "description": "$ServiceBusTopicTrigger_description",
      "name": "Azure Service Bus Topic trigger",
      "language": "TypeScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "serviceBus",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "topicName",
        "subscriptionName"
      ]
    }
  },
  {
    "id": "SignalRConnectionInfoHttpTrigger-CSharp",
    "runtime": "2",
    "files": {
      "run.csx": "#r \"Microsoft.Azure.WebJobs.Extensions.SignalRService\"\r\nusing Microsoft.Azure.WebJobs.Extensions.SignalRService;\r\n\r\npublic static SignalRConnectionInfo Run(HttpRequest req, SignalRConnectionInfo connectionInfo)\r\n{\r\n    return connectionInfo;\r\n}\r\n",
      "sample.dat": ""
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "authLevel": "anonymous",
          "type": "httpTrigger",
          "direction": "in",
          "methods": [
            "post"
          ],
          "name": "req",
          "route": "negotiate"
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        },
        {
          "type": "signalRConnectionInfo",
          "name": "connectionInfo",
          "hubName": "default",
          "connectionStringSetting": "AzureSignalRConnectionString",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "negotiate",
      "description": "$signalRConnectionInfoNegotiate_description",
      "name": "SignalR negotiate HTTP trigger",
      "language": "C#",
      "category": [
        "$temp_category_core",
        "$temp_category_api"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": [
        "hubName",
        "connectionStringSetting",
        "route"
      ]
    }
  },
  {
    "id": "SignalRConnectionInfoHttpTrigger-Custom",
    "runtime": "2",
    "files": {},
    "function": {
      "disabled": false,
      "bindings": [
        {
          "authLevel": "anonymous",
          "type": "httpTrigger",
          "direction": "in",
          "methods": [
            "post"
          ],
          "name": "req",
          "route": "negotiate"
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        },
        {
          "type": "signalRConnectionInfo",
          "name": "connectionInfo",
          "hubName": "default",
          "connectionStringSetting": "AzureSignalRConnectionString",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "negotiate",
      "description": "$signalRConnectionInfoNegotiate_description",
      "name": "SignalR negotiate HTTP trigger",
      "language": "Custom",
      "category": [
        "$temp_category_core",
        "$temp_category_api"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": [
        "hubName",
        "connectionStringSetting",
        "route"
      ]
    }
  },
  {
    "id": "SignalRConnectionInfoHttpTrigger-JavaScript",
    "runtime": "2",
    "files": {
      "index.js": "module.exports = async function (context, req, connectionInfo) {\r\n    context.res.body = connectionInfo;\r\n};",
      "sample.dat": ""
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "authLevel": "anonymous",
          "type": "httpTrigger",
          "direction": "in",
          "methods": [
            "post"
          ],
          "name": "req",
          "route": "negotiate"
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        },
        {
          "type": "signalRConnectionInfo",
          "name": "connectionInfo",
          "hubName": "default",
          "connectionStringSetting": "AzureSignalRConnectionString",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "negotiate",
      "description": "$signalRConnectionInfoNegotiate_description",
      "name": "SignalR negotiate HTTP trigger",
      "language": "JavaScript",
      "category": [
        "$temp_category_core",
        "$temp_category_api"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": [
        "hubName",
        "connectionStringSetting",
        "route"
      ]
    }
  },
  {
    "id": "SignalRConnectionInfoHttpTrigger-PowerShell",
    "runtime": "2",
    "files": {
      "run.ps1": "using namespace System.Net\r\n\r\nparam($Request, $TriggerMetadata, $ConnectionInfo)\r\n\r\nPush-OutputBinding -Name Response -Value ([HttpResponseContext]@{\r\n    StatusCode = [HttpStatusCode]::OK\r\n    ContentType = \"application/json\"\r\n    Body = $ConnectionInfo\r\n})",
      "sample.dat": ""
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "authLevel": "anonymous",
          "type": "httpTrigger",
          "direction": "in",
          "methods": [
            "post"
          ],
          "name": "Request",
          "route": "negotiate"
        },
        {
          "type": "http",
          "direction": "out",
          "name": "Response"
        },
        {
          "type": "signalRConnectionInfo",
          "name": "ConnectionInfo",
          "hubName": "default",
          "connectionStringSetting": "AzureSignalRConnectionString",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "negotiate",
      "description": "$signalRConnectionInfoNegotiate_description",
      "name": "SignalR negotiate HTTP trigger",
      "language": "PowerShell",
      "category": [
        "$temp_category_core",
        "$temp_category_api"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": [
        "hubName",
        "connectionStringSetting",
        "route"
      ]
    }
  },
  {
    "id": "SignalRConnectionInfoHttpTrigger-TypeScript",
    "runtime": "2",
    "files": {
      "index.ts": "import { AzureFunction, Context, HttpRequest } from \"@azure/functions\"\r\n\r\nconst httpTrigger: AzureFunction = async function (context: Context, req: HttpRequest, connectionInfo: any): Promise<void> {\r\n    context.res.body = connectionInfo;\r\n};\r\n\r\nexport default httpTrigger;\r\n",
      "sample.dat": ""
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "authLevel": "anonymous",
          "type": "httpTrigger",
          "direction": "in",
          "methods": [
            "post"
          ],
          "name": "req",
          "route": "negotiate"
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        },
        {
          "type": "signalRConnectionInfo",
          "name": "connectionInfo",
          "hubName": "default",
          "connectionStringSetting": "AzureSignalRConnectionString",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "negotiate",
      "description": "$signalRConnectionInfoNegotiate_description",
      "name": "SignalR negotiate HTTP trigger",
      "language": "TypeScript",
      "category": [
        "$temp_category_core",
        "$temp_category_api"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": [
        "hubName",
        "connectionStringSetting",
        "route"
      ]
    }
  },
  {
    "id": "SqlInputBinding-CSharp",
    "runtime": "2",
    "files": {
      "readme.md": "# SQL Input Binding - C<span>#</span>\r\n\r\nThe `SQL Input Binding` makes it easy to retrieve data from a database, returning the output of the query or stored procedure to the function.\r\n\r\n## How it works\r\n\r\nFor a `SQL Input Binding` to work, you can provide the query to retrieve data from an existing object in the database. For instance, you can set the query to `SELECT * FROM [dbo].[table1]` in the `commandText` attribute to return all the values from the `[dbo].[table1]` table in the database.\r\n\r\nFor more information, see the official [docs](https://aka.ms/sqlbindingsinput)."
    },
    "function": {
      "bindings": [
        {
          "authLevel": "function",
          "name": "req",
          "type": "httpTrigger",
          "direction": "in",
          "methods": [
            "get"
          ]
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "SqlInputBinding",
      "description": "$SqlInputBinding_description",
      "name": "SQL Input Binding",
      "language": "C#",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "SqlInputBinding-JavaScript",
    "runtime": "2",
    "files": {
      "index.js": "/**\r\n * Sample SQL Input Binding\r\n * See https://aka.ms/sqlbindingsinput for more information about using this binding\r\n *\r\n * These tasks should be completed prior to running :\r\n *      1. Update \"commandText\" in function.json - this should be the query to execute to retrieve the values being returned\r\n *      2. Add an app setting named \"SqlConnectionString\" containing the connection string\r\n *          to use for the SQL connection\r\n * @param context The Azure Function runtime context\r\n * @param req The HttpRequest that triggered this function\r\n * @param results The array of objects returned by the SQL input binding\r\n */\r\nmodule.exports = async function (context, req, results) {\r\n    context.log('Query results: ', JSON.stringify(results));\r\n    return {\r\n        status: 200,\r\n        body: results\r\n    };\r\n}\r\n",
      "readme.md": "# SQL Input Binding - JavaScript\r\n\r\nThe `SQL Input Binding` makes it easy to retrieve data from a database, returning the output of the query or stored procedure to the function.\r\n\r\n## How it works\r\n\r\nFor a `SQL Input Binding` to work, you can provide the query to retrive data from an existing object in the database. For instance, you can set the query to `Select * From [dbo].[table1]` to query `[dbo].[table1]` in the `commandText` value in your `function.json`.\r\n\r\nFor more information, see the official [docs](https://aka.ms/sqlbindingsinput)."
    },
    "function": {
      "bindings": [
        {
          "authLevel": "function",
          "name": "req",
          "type": "httpTrigger",
          "direction": "in",
          "methods": [
            "get"
          ]
        },
        {
          "name": "$return",
          "type": "http",
          "direction": "out"
        },
        {
          "type": "sql",
          "name": "results",
          "direction": "in",
          "commandText": "SELECT * FROM [dbo].[table1]",
          "commandType": "Text",
          "connectionStringSetting": "SqlConnectionString"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "SqlInputBinding",
      "description": "$SqlInputBinding_description",
      "name": "SQL Input Binding",
      "language": "JavaScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "SqlInputBinding-PowerShell",
    "runtime": "2",
    "files": {
      "readme.md": "# SQL Input Binding - PowerShell\r\n\r\nThe `SQL Input Binding` makes it easy to retrieve data from a database, returning the output of the query or stored procedure to the function.\r\n\r\n## How it works\r\n\r\nFor a `SQL Input Binding` to work, you can provide the query to retrieve data from an existing object in the database. For instance, you can set the query to `SELECT * FROM [dbo].[table1]` in the `commandText` value in your `function.json` to return all the values from the `[dbo].[table1]` table in the database.\r\n\r\nFor more information, see the official [docs](https://aka.ms/sqlbindingsinput).",
      "run.ps1": "<#\r\nSample SQL Input Binding\r\nSee https://aka.ms/sqlbindingsinput for more information about using this binding\r\nThese tasks should be completed prior to running:\r\n    1. Update \"commandText\" in function.json - this should be the query to execute to retrieve the values being returned\r\n    2. Add an app setting named \"SqlConnectionString\" containing the connection string to use for the SQL connection\r\n@param Request The HttpRequest that triggered this function\r\n@param items The array of objects returned by the SQL input binding\r\n#>\r\nusing namespace System.Net\r\n\r\n# Trigger and input binding data are passed in via the param block.\r\nparam($Request, $items)\r\n\r\n# Write to the Azure Functions log stream.\r\nWrite-Host \"PowerShell function with SQL Input Binding processed a request.\"\r\n\r\n# Assign the value to return as the HTTP response. \r\n# The -Name value matches the name property in the function.json for the binding\r\nPush-OutputBinding -Name Response -Value ([HttpResponseContext]@{\r\n    StatusCode = [System.Net.HttpStatusCode]::OK\r\n    Body = $items\r\n})"
    },
    "function": {
      "bindings": [
        {
          "authLevel": "function",
          "type": "httpTrigger",
          "direction": "in",
          "name": "Request",
          "methods": [
            "get"
          ]
        },
        {
          "type": "http",
          "direction": "out",
          "name": "Response"
        },
        {
          "name": "items",
          "type": "sql",
          "direction": "in",
          "commandText": "SELECT * FROM [dbo].[table1]",
          "commandType": "Text",
          "connectionStringSetting": "SqlConnectionString"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "SqlInputBinding",
      "description": "$SqlInputBinding_description",
      "name": "SQL Input Binding",
      "language": "PowerShell",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "SqlInputBinding-Python",
    "runtime": "2",
    "files": {
      "readme.md": "# SQL Input Binding - Python\r\n\r\nThe `SQL Input Binding` makes it easy to retrieve data from a database, returning the output of the query or stored procedure to the function.\r\n\r\n## How it works\r\n\r\nFor a `SQL Input Binding` to work, you can provide the query to retrieve data from an existing object in the database. For instance, you can set the query to `SELECT * FROM [dbo].[table1]` in the `commandText` value in your `function.json` to return all the values from the `[dbo].[table1]` table in the database.\r\n\r\nFor more information, see the official [docs](https://aka.ms/sqlbindingsinput).",
      "__init__.py": "import json\r\n\r\nfrom azure.functions import HttpRequest, HttpResponse, SqlRowList\r\n\r\ndef main(req: HttpRequest, items: SqlRowList) -> HttpResponse:\r\n    \"\"\"Sample SQL Input Binding\r\n\r\n    See https://aka.ms/sqlbindingsinput for more information about using this binding\r\n\r\n    *IMPORTANT*\r\n        Local Development : You must have version >= 4.0.5030 of the Azure Function Core Tools installed.\r\n\r\n    These tasks should be completed prior to running :\r\n    1. Update \"commandText\" in function.json - this should be the query to execute to retrieve the values being returned\r\n    2. Add an app setting named \"SqlConnectionString\" containing the connection string to use for the SQL connection\r\n\r\n    Arguments:\r\n    req: The HttpRequest that triggered this function\r\n    items: The list of objects returned by the SQL input binding\r\n    \"\"\"\r\n\r\n    rows = list(map(lambda r: json.loads(r.to_json()), items))\r\n\r\n    return HttpResponse(\r\n        json.dumps(rows),\r\n        status_code=200,\r\n        mimetype=\"application/json\"\r\n    )\r\n"
    },
    "function": {
      "scriptFile": "__init__.py",
      "bindings": [
        {
          "authLevel": "function",
          "type": "httpTrigger",
          "direction": "in",
          "name": "req",
          "methods": [
            "get"
          ]
        },
        {
          "type": "sql",
          "name": "items",
          "direction": "in",
          "commandText": "SELECT * FROM [dbo].[table1]",
          "commandType": "Text",
          "connectionStringSetting": "SqlConnectionString"
        },
        {
          "type": "http",
          "direction": "out",
          "name": "$return"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "SqlInputBinding",
      "description": "$SqlInputBinding_description",
      "name": "SQL Input Binding",
      "language": "Python",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "filters": [
        "Python3"
      ]
    }
  },
  {
    "id": "SqlInputBinding-Typescript",
    "runtime": "2",
    "files": {
      "index.ts": "import { AzureFunction, Context, HttpRequest } from \"@azure/functions\"\r\n\r\n/**\r\n * Sample SQL Input Binding\r\n * See https://aka.ms/sqlbindingsinput for more information about using this binding\r\n *\r\n * These tasks should be completed prior to running :\r\n *      1. Update \"commandText\" in function.json - this should be the query to execute to retrieve the values being returned\r\n *      2. Add an app setting named \"SqlConnectionString\" containing the connection string\r\n *          to use for the SQL connection\r\n * @param context The Azure Function runtime context\r\n * @param req The HttpRequest that triggered this function\r\n * @param items The array of objects returned by the SQL input binding\r\n */\r\nconst sqlInputBinding: AzureFunction = async function (context: Context, req: HttpRequest, items: any[]): Promise<void> {\r\n    context.log('HTTP trigger with SQL input binding function processed a request.');\r\n    context.res = {\r\n        // status: 200, /* Defaults to 200 */\r\n        body: items\r\n    };\r\n};\r\n\r\nexport default sqlInputBinding;",
      "readme.md": "# SQL Input Binding - Typescript\r\n\r\nThe `SQL Input Binding` makes it easy to retrieve data from a database, returning the output of the query or stored procedure to the function.\r\n\r\n## How it works\r\n\r\nFor a `SQL Input Binding` to work, you can provide the query to retrieve data from an existing object in the database. For instance, you can set the query to `SELECT * FROM [dbo].[table1]` in the `commandText` value in your `function.json` to return all the values from the `[dbo].[table1]` table in the database.\r\n\r\nFor more information, see the official [docs](https://aka.ms/sqlbindingsinput)."
    },
    "function": {
      "bindings": [
        {
          "authLevel": "function",
          "type": "httpTrigger",
          "direction": "in",
          "name": "req",
          "methods": [
            "get"
          ]
        },
        {
          "type": "sql",
          "name": "items",
          "direction": "in",
          "commandText": "SELECT * FROM [dbo].[table1]",
          "commandType": "Text",
          "connectionStringSetting": "SqlConnectionString"
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "SqlInputBinding",
      "description": "$SqlInputBinding_description",
      "name": "SQL Input Binding",
      "language": "Typescript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "SqlOutputBinding-CSharp",
    "runtime": "2",
    "files": {
      "readme.md": "# SQL Output Binding - C<span>#</span>\r\n\r\nThe `SQL Output Binding` makes it easy to take an array of rows and upsert them into the user table (i.e. If a row doesn't already exist, it is added. If it does, it is updated).\r\n\r\n## How it works\r\n\r\nFor a `SQL Output Binding` to work, you provide the existing table in the database to upsert rows into. For instance, you can set the table to `[dbo].[table1]` in the `commandText` attribute to upsert into this table.\r\n\r\nFor more information, see the official [docs](https://aka.ms/sqlbindingsoutput)"
    },
    "function": {
      "bindings": [
        {
          "authLevel": "function",
          "name": "req",
          "type": "httpTrigger",
          "direction": "in",
          "methods": [
            "get"
          ]
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "SqlOutputBinding",
      "description": "$SqlOutputBinding_description",
      "name": "SQL Output Binding",
      "language": "C#",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "SqlOutputBinding-JavaScript",
    "runtime": "2",
    "files": {
      "index.js": "/**\r\n * Sample SQL Output Binding\r\n * See https://aka.ms/sqlbindingsoutput for more information about using this binding\r\n *\r\n * These tasks should be completed prior to running :\r\n *      1. Update \"commandText\" in function.json - this should be the name of the table that you wish to upsert values to\r\n *      2. Add an app setting named \"SqlConnectionString\" containing the connection string\r\n *          to use for the SQL connection\r\n * @param context The Azure Function runtime context\r\n * @param req The HttpRequest that triggered this function\r\n */\r\nmodule.exports = async function (context, req) {\r\n    context.log('HTTP trigger with SQL output binding function processed a request.');\r\n\r\n    // Set results array to context.bindings for upsertion\r\n    // Note that this expects the body to be a JSON object or array of objects which have a property\r\n    // matching each of the columns in the table to upsert to.\r\n    context.bindings.results = JSON.stringify(req.body);\r\n\r\n    context.res = {\r\n        status: 201,\r\n        body: req.body\r\n    };\r\n}",
      "readme.md": "# SQL Output Binding - JavaScript\r\n\r\nThe `SQL Output Binding` makes it easy to take an array of rows and upsert them into the user table (i.e. If a row doesn't already exist, it is added. If it does, it is updated).\r\n\r\n## How it works\r\n\r\nFor a `SQL Output Binding` to work, you provide the existing table in the database to upsert rows into. For instance, you can set the table to `[dbo].[table1]` in the `commandText` value in your `function.json` to upsert into this table.\r\n\r\nFor more information, see the official [docs](https://aka.ms/sqlbindingsoutput)"
    },
    "function": {
      "bindings": [
        {
          "authLevel": "function",
          "name": "req",
          "direction": "in",
          "type": "httpTrigger",
          "methods": [
            "post"
          ]
        },
        {
          "name": "$return",
          "type": "http",
          "direction": "out"
        },
        {
          "type": "sql",
          "name": "results",
          "direction": "out",
          "commandText": "[dbo].[table1]",
          "commandType": "Text",
          "connectionStringSetting": "SqlConnectionString"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "SqlOutputBinding",
      "description": "$SqlOutputBinding_description",
      "name": "SQL Output Binding",
      "language": "JavaScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "SqlOutputBinding-PowerShell",
    "runtime": "2",
    "files": {
      "readme.md": "# SQL Output Binding - PowerShell\r\n\r\nThe `SQL Output Binding` makes it easy to take an array of rows and upsert them into the user table (i.e. If a row doesn't already exist, it is added. If it does, it is updated).\r\n\r\n## How it works\r\n\r\nFor a `SQL Output Binding` to work, you provide the existing table in the database to upsert rows into. For instance, you can set the table to `[dbo].[table1]` in the `commandText` value in your `function.json` to upsert into this table.\r\n\r\nFor more information, see the official [docs](https://aka.ms/sqlbindingsoutput)",
      "run.ps1": "<#\r\nSample SQL Output Binding\r\nSee https://aka.ms/sqlbindingsinput for more information about using this binding\r\nThese tasks should be completed prior to running :\r\n    1. Update \"commandText\" in function.json - this should be the name of the table that you wish to upsert values to\r\n    2. Add an app setting named \"SqlConnectionString\" containing the connection string to use for the SQL connection\r\n@param Request The HttpRequest that triggered this function\r\n#>\r\nusing namespace System.Net\r\n\r\n# Trigger binding data passed in via param block\r\nparam($Request)\r\n\r\n# Write to the Azure Functions log stream.\r\nWrite-Host \"PowerShell function with SQL Output Binding processed a request.\"\r\n\r\n# Update req_body with the body of the request\r\n# Note that this expects the body to be a JSON object or array of objects \r\n# which have a property matching each of the columns in the table to upsert to.\r\n$req_body = $Request.Body\r\n\r\n# Assign the value we want to pass to the SQL Output binding. \r\n# The -Name value corresponds to the name property in the function.json for the binding\r\nPush-OutputBinding -Name results -Value $req_body\r\n\r\n# Assign the value to return as the HTTP response. \r\n# The -Name value matches the name property in the function.json for the binding\r\nPush-OutputBinding -Name Response -Value ([HttpResponseContext]@{\r\n    StatusCode = [HttpStatusCode]::OK\r\n    Body = $req_body\r\n})"
    },
    "function": {
      "bindings": [
        {
          "authLevel": "function",
          "type": "httpTrigger",
          "direction": "in",
          "name": "Request",
          "methods": [
            "post"
          ]
        },
        {
          "type": "http",
          "direction": "out",
          "name": "Response"
        },
        {
          "name": "results",
          "type": "sql",
          "direction": "out",
          "commandText": "[dbo].[table1]",
          "connectionStringSetting": "SqlConnectionString"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "SqlOutputBinding",
      "description": "$SqlOutputBinding_description",
      "name": "SQL Output Binding",
      "language": "PowerShell",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "SqlOutputBinding-Python",
    "runtime": "2",
    "files": {
      "readme.md": "# SQL Output Binding - Python\r\n\r\nThe `SQL Output Binding` makes it easy to take a list of rows and upsert them into the user table (i.e. If a row doesn't already exist, it is added. If it does, it is updated).\r\n\r\n## How it works\r\n\r\nFor a `SQL Output Binding` to work, you provide the existing table in the database to upsert rows into. For instance, you can set the table to `[dbo].[table1]` in the `commandText` value in your `function.json` to upsert into this table.\r\n\r\nFor more information, see the official [docs](https://aka.ms/sqlbindingsoutput)",
      "__init__.py": "import json\r\n\r\nfrom azure.functions import HttpRequest, HttpResponse, Out, SqlRowList, SqlRow\r\n\r\ndef main(req: HttpRequest, items: Out[SqlRowList]) -> HttpResponse:\r\n    \"\"\"Sample SQL Output Binding\r\n\r\n    See https://aka.ms/sqlbindingsoutput for more information about using this binding\r\n\r\n    *IMPORTANT*\r\n        Local Development : You must have version >= 4.0.5030 of the Azure Function Core Tools installed.\r\n\r\n    See https://github.com/Azure/azure-functions-sql-extension/issues/250 for the current state of Python support for the SQL binding\r\n\r\n    These tasks should be completed prior to running :\r\n    1. Update \"commandText\" in function.json - this should be the name of the table that you wish to upsert values to\r\n    2. Add an app setting named \"SqlConnectionString\" containing the connection string to use for the SQL connection\r\n\r\n    Arguments:\r\n    req: The HttpRequest that triggered this function\r\n    items: The objects to be upserted to the database\r\n    \"\"\"\r\n\r\n    # Note that this expects the body to be an array of JSON objects which\r\n    # have a property matching each of the columns in the table to upsert to.\r\n    body = json.loads(req.get_body())\r\n    rows = SqlRowList(map(lambda r: SqlRow.from_dict(r), body))\r\n    items.set(rows)\r\n\r\n    return HttpResponse(\r\n        body=req.get_body(),\r\n        status_code=201, # 201 Created\r\n        mimetype=\"application/json\"\r\n    )\r\n"
    },
    "function": {
      "scriptFile": "__init__.py",
      "bindings": [
        {
          "authLevel": "function",
          "type": "httpTrigger",
          "direction": "in",
          "name": "req",
          "methods": [
            "post"
          ]
        },
        {
          "type": "sql",
          "name": "items",
          "direction": "out",
          "commandText": "[dbo].[table1]",
          "connectionStringSetting": "SqlConnectionString"
        },
        {
          "type": "http",
          "direction": "out",
          "name": "$return"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "SqlOutputBinding",
      "description": "$SqlOutputBinding_description",
      "name": "SQL Output Binding",
      "language": "Python",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "filters": [
        "Python3"
      ]
    }
  },
  {
    "id": "SqlTrigger-CSharp",
    "runtime": "2",
    "files": {
      "readme.md": "# SQL Trigger Binding - C<span>#</span>\r\n\r\nThe `SQL Trigger Binding` monitors the user table for changes (i.e., row inserts, updates, and deletes) and invokes the function with updated rows.\r\n\r\n## How it works\r\n\r\n`SQL Trigger Binding` utilizes SQL change tracking functionality to monitor the user table for changes. As such, it is necessary to enable change tracking on the SQL database and the SQL table before using the trigger support.\r\n\r\nFor more information, see the official [docs](https://aka.ms/sqltrigger)."
    },
    "function": {
      "bindings": [
        {
          "name": "changes",
          "type": "sqlTrigger",
          "direction": "in",
          "tableName": "[dbo].[table1]",
          "connectionStringSetting": "SqlConnectionString"
        }
      ],
      "disabled": false
    },
    "metadata": {
      "defaultFunctionName": "SqlTriggerBinding",
      "description": "$SqlTriggerBinding_description",
      "name": "SQL Trigger",
      "language": "C#",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "SqlTrigger-JavaScript",
    "runtime": "2",
    "files": {
      "index.js": "/**\r\n * Sample SQL Trigger Binding\r\n * See https://aka.ms/sqltrigger for more information about using this binding\r\n *\r\n * These tasks should be completed prior to running :\r\n *      1. Update \"tableName\" in function.json - this should be the table that is monitored for changes and triggers/invokes the function.\r\n *      2. Add an app setting named \"SqlConnectionString\" containing the connection string\r\n *          to use for the SQL connection\r\n *      3. Change the bundle name in host.json to \"Microsoft.Azure.Functions.ExtensionBundle.Preview\" and the version to \"[4.*, 5.0.0)\"\r\n * @param context The Azure Function runtime context\r\n * @param changes The updated objects returned by the trigger binding\r\n */\r\nmodule.exports = async function (context, changes) {\r\n    context.log(`SQL Changes: ${JSON.stringify(changes)}`)\r\n}\r\n",
      "readme.md": "# SQL Trigger Binding - JavaScript\r\n\r\nThe `SQL Trigger Binding` monitors the user table for changes (i.e., row inserts, updates, and deletes) and invokes the function with updated rows.\r\n\r\n## How it works\r\n\r\n`SQL Trigger Binding` utilizes SQL change tracking functionality to monitor the user table for changes. As such, it is necessary to enable change tracking on the SQL database and the SQL table before using the trigger support.\r\n\r\nFor more information, see the official [docs](https://aka.ms/sqltrigger)."
    },
    "function": {
      "bindings": [
        {
          "name": "changes",
          "type": "sqlTrigger",
          "direction": "in",
          "tableName": "[dbo].[table1]",
          "connectionStringSetting": "SqlConnectionString"
        }
      ],
      "disabled": false
    },
    "metadata": {
      "defaultFunctionName": "SqlTriggerBinding",
      "description": "$SqlTriggerBinding_description",
      "name": "SQL Trigger",
      "language": "JavaScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "SqlTrigger-PowerShell",
    "runtime": "2",
    "files": {
      "readme.md": "# SQL Input Binding - PowerShell\r\n\r\nThe `SQL Trigger Binding` monitors the user table for changes (i.e., row inserts, updates, and deletes) and invokes the function with updated rows.\r\n\r\n## How it works\r\n\r\n`SQL Trigger Binding` utilizes SQL change tracking functionality to monitor the user table for changes. As such, it is necessary to enable change tracking on the SQL database and the SQL table before using the trigger support.\r\n\r\nFor more information, see the official [docs](https://aka.ms/sqltrigger).",
      "run.ps1": "<#\r\nSample SQL Trigger Binding\r\nSee https://aka.ms/sqltrigger for more information about using this binding\r\nThese tasks should be completed prior to running:\r\n    1. Update \"tableName\" in function.json - this should be the table that is monitored for changes and triggers/invokes the function.\r\n    2. Add an app setting named \"SqlConnectionString\" containing the connection string to use for the SQL connection\r\n    3. Change the bundle name in host.json to \"Microsoft.Azure.Functions.ExtensionBundle.Preview\" and the version to \"[4.*, 5.0.0)\"\r\n@param Request The HttpRequest that triggered this function\r\n@param items The array of objects returned by the SQL input binding\r\n#>\r\nusing namespace System.Net\r\n\r\n# Trigger and input binding data are passed in via the param block.\r\nparam($changes)\r\n\r\n# Write to the Azure Functions log stream.\r\nWrite-Host \"PowerShell function with SQL Trigger Binding processed a request.\"\r\n\r\n# The output is used to inspect the trigger binding parameter in test methods.\r\n# Use -Compress to remove new lines and spaces for testing purposes.\r\n$changesJson = $changes | ConvertTo-Json -Compress\r\nWrite-Host \"SQL Changes: $changesJson\""
    },
    "function": {
      "bindings": [
        {
          "name": "changes",
          "type": "sqlTrigger",
          "direction": "in",
          "tableName": "[dbo].[table1]",
          "connectionStringSetting": "SqlConnectionString"
        }
      ],
      "disabled": false
    },
    "metadata": {
      "defaultFunctionName": "SqlTriggerBinding",
      "description": "$SqlTriggerBinding_description",
      "name": "SQL Trigger",
      "language": "PowerShell",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "SqlTrigger-Python",
    "runtime": "2",
    "files": {
      "readme.md": "# SQL Trigger Binding - Python\r\n\r\nThe `SQL Trigger Binding` monitors the user table for changes (i.e., row inserts, updates, and deletes) and invokes the function with updated rows.\r\n\r\n## How it works\r\n\r\n`SQL Trigger Binding` utilizes SQL change tracking functionality to monitor the user table for changes. As such, it is necessary to enable change tracking on the SQL database and the SQL table before using the trigger support.\r\n\r\nFor more information, see the official [docs](https://aka.ms/sqltrigger).",
      "__init__.py": "import json\r\nimport logging\r\n\r\ndef main(changes) :\r\n    \"\"\"Sample SQL Trigger Binding\r\n\r\n    See https://aka.ms/sqltrigger for more information about using this binding\r\n\r\n    *IMPORTANT*\r\n        Local Development : You must have version >= 4.0.5030 of the Azure Function Core Tools installed.\r\n\r\n    These tasks should be completed prior to running :\r\n    1. Update \"tableName\" in function.json - this should be the table that is monitored for changes and triggers/invokes the function.\r\n    2. Add an app setting named \"SqlConnectionString\" containing the connection string to use for the SQL connection\r\n    3. Change the bundle name in host.json to \"Microsoft.Azure.Functions.ExtensionBundle.Preview\" and the version to \"[4.*, 5.0.0)\"\r\n\r\n    Arguments:\r\n    changes: The list of updated objects returned by the SQL trigger binding\r\n    \"\"\"\r\n\r\n    logging.info(\"SQL Changes: %s\", json.loads(changes))\r\n"
    },
    "function": {
      "bindings": [
        {
          "name": "changes",
          "type": "sqlTrigger",
          "direction": "in",
          "tableName": "[dbo].[table1]",
          "connectionStringSetting": "SqlConnectionString"
        }
      ],
      "disabled": false
    },
    "metadata": {
      "defaultFunctionName": "SqlTriggerBinding",
      "description": "$SqlTriggerBinding_description",
      "name": "SQL Trigger",
      "language": "Python",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "filters": [
        "Python3"
      ]
    }
  },
  {
    "id": "SqlTrigger-Typescript",
    "runtime": "2",
    "files": {
      "index.ts": "import { AzureFunction, Context } from \"@azure/functions\"\r\n\r\n/**\r\n * Sample SQL Trigger Binding\r\n * See https://aka.ms/sqltrigger for more information about using this binding\r\n *\r\n * These tasks should be completed prior to running :\r\n *      1. Update \"tableName\" in function.json - this should be the table that is monitored for changes and triggers/invokes the function.\r\n *      2. Add an app setting named \"SqlConnectionString\" containing the connection string\r\n *          to use for the SQL connection\r\n *      3. Change the bundle name in host.json to \"Microsoft.Azure.Functions.ExtensionBundle.Preview\" and the version to \"[4.*, 5.0.0)\"\r\n * @param context The Azure Function runtime context\r\n * @param req The HttpRequest that triggered this function\r\n * @param items The array of objects returned by the SQL input binding\r\n */\r\nconst sqlTriggerBinding: AzureFunction = async function (context: Context, changes: any[]): Promise<void> {\r\n    context.log(`SQL Changes: ${JSON.stringify(changes)}`);\r\n};\r\n\r\nexport default sqlTriggerBinding;",
      "readme.md": "# SQL Trigger Binding - Typescript\r\n\r\nThe `SQL Trigger Binding` monitors the user table for changes (i.e., row inserts, updates, and deletes) and invokes the function with updated rows.\r\n\r\n## How it works\r\n\r\n`SQL Trigger Binding` utilizes SQL change tracking functionality to monitor the user table for changes. As such, it is necessary to enable change tracking on the SQL database and the SQL table before using the trigger support.\r\n\r\nFor more information, see the official [docs](https://aka.ms/sqltrigger)."
    },
    "function": {
      "bindings": [
        {
          "name": "changes",
          "type": "sqlTrigger",
          "direction": "in",
          "tableName": "[dbo].[table1]",
          "connectionStringSetting": "SqlConnectionString"
        }
      ],
      "disabled": false
    },
    "metadata": {
      "defaultFunctionName": "SqlTriggerBinding",
      "description": "$SqlTriggerBinding_description",
      "name": "SQL Trigger",
      "language": "Typescript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "TimerTrigger-CSharp",
    "runtime": "2",
    "files": {
      "readme.md": "# TimerTrigger - C<span>#</span>\r\n\r\nThe `TimerTrigger` makes it incredibly easy to have your functions executed on a schedule. This sample demonstrates a simple use case of calling your function every 5 minutes.\r\n\r\n## How it works\r\n\r\nFor a `TimerTrigger` to work, you provide a schedule in the form of a [cron expression](https://en.wikipedia.org/wiki/Cron#CRON_expression)(See the link for full details). A cron expression is a string with 6 separate expressions which represent a given schedule via patterns. The pattern we use to represent every 5 minutes is `0 */5 * * * *`. This, in plain text, means: \"When seconds is equal to 0, minutes is divisible by 5, for any hour, day of the month, month, day of the week, or year\".\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
      "run.csx": "using System;\r\n\r\npublic static void Run(TimerInfo myTimer, ILogger log)\r\n{\r\n    log.LogInformation($\"C# Timer trigger function executed at: {DateTime.Now}\");\r\n}\r\n",
      "sample.dat": ""
    },
    "function": {
      "bindings": [
        {
          "name": "myTimer",
          "type": "timerTrigger",
          "direction": "in",
          "schedule": "0 */5 * * * *"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "TimerTrigger",
      "description": "$TimerTrigger_description",
      "name": "Timer trigger",
      "language": "C#",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "timer",
      "enabledInTryMode": true,
      "userPrompt": [
        "schedule"
      ]
    }
  },
  {
    "id": "TimerTrigger-Custom",
    "runtime": "2",
    "files": {},
    "function": {
      "bindings": [
        {
          "name": "myTimer",
          "type": "timerTrigger",
          "direction": "in",
          "schedule": "0 */5 * * * *"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "TimerTrigger",
      "description": "$TimerTrigger_description",
      "name": "Timer trigger",
      "language": "Custom",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "timer",
      "enabledInTryMode": true,
      "userPrompt": [
        "schedule"
      ]
    }
  },
  {
    "id": "TimerTrigger-JavaScript",
    "runtime": "2",
    "files": {
      "index.js": "module.exports = async function (context, myTimer) {\r\n    var timeStamp = new Date().toISOString();\r\n    \r\n    if (myTimer.isPastDue)\r\n    {\r\n        context.log('JavaScript is running late!');\r\n    }\r\n    context.log('JavaScript timer trigger function ran!', timeStamp);   \r\n};",
      "readme.md": "# TimerTrigger - JavaScript\r\n\r\nThe `TimerTrigger` makes it incredibly easy to have your functions executed on a schedule. This sample demonstrates a simple use case of calling your function every 5 minutes.\r\n\r\n## How it works\r\n\r\nFor a `TimerTrigger` to work, you provide a schedule in the form of a [cron expression](https://en.wikipedia.org/wiki/Cron#CRON_expression)(See the link for full details). A cron expression is a string with 6 separate expressions which represent a given schedule via patterns. The pattern we use to represent every 5 minutes is `0 */5 * * * *`. This, in plain text, means: \"When seconds is equal to 0, minutes is divisible by 5, for any hour, day of the month, month, day of the week, or year\".\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
      "sample.dat": ""
    },
    "function": {
      "bindings": [
        {
          "name": "myTimer",
          "type": "timerTrigger",
          "direction": "in",
          "schedule": "0 */5 * * * *"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "TimerTrigger",
      "description": "$TimerTrigger_description",
      "name": "Timer trigger",
      "language": "JavaScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "timer",
      "enabledInTryMode": true,
      "userPrompt": [
        "schedule"
      ]
    }
  },
  {
    "id": "TimerTrigger-PowerShell",
    "runtime": "2",
    "files": {
      "readme.md": "# TimerTrigger - PowerShell\r\n\r\nThe `TimerTrigger` makes it incredibly easy to have your functions executed on a schedule. This sample demonstrates a simple use case of calling your function every 5 minutes.\r\n\r\n## How it works\r\n\r\nFor a `TimerTrigger` to work, you provide a schedule in the form of a [cron expression](https://en.wikipedia.org/wiki/Cron#CRON_expression)(See the link for full details). A cron expression is a string with 6 separate expressions which represent a given schedule via patterns. The pattern we use to represent every 5 minutes is `0 */5 * * * *`. This, in plain text, means: \"When seconds is equal to 0, minutes is divisible by 5, for any hour, day of the month, month, and day of the week\".\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation\r\n",
      "run.ps1": "# Input bindings are passed in via param block.\r\nparam($Timer)\r\n\r\n# Get the current universal time in the default string format.\r\n$currentUTCtime = (Get-Date).ToUniversalTime()\r\n\r\n# The 'IsPastDue' property is 'true' when the current function invocation is later than scheduled.\r\nif ($Timer.IsPastDue) {\r\n    Write-Host \"PowerShell timer is running late!\"\r\n}\r\n\r\n# Write an information log with the current time.\r\nWrite-Host \"PowerShell timer trigger function ran! TIME: $currentUTCtime\"\r\n",
      "sample.dat": ""
    },
    "function": {
      "bindings": [
        {
          "name": "Timer",
          "type": "timerTrigger",
          "direction": "in",
          "schedule": "0 */5 * * * *"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "TimerTrigger",
      "description": "$TimerTrigger_description",
      "name": "Timer trigger",
      "language": "PowerShell",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "timer",
      "enabledInTryMode": true,
      "userPrompt": [
        "schedule"
      ]
    }
  },
  {
    "id": "TimerTrigger-Python",
    "runtime": "2",
    "files": {
      "readme.md": "# TimerTrigger - Python\r\n\r\nThe `TimerTrigger` makes it incredibly easy to have your functions executed on a schedule. This sample demonstrates a simple use case of calling your function every 5 minutes.\r\n\r\n## How it works\r\n\r\nFor a `TimerTrigger` to work, you provide a schedule in the form of a [cron expression](https://en.wikipedia.org/wiki/Cron#CRON_expression)(See the link for full details). A cron expression is a string with 6 separate expressions which represent a given schedule via patterns. The pattern we use to represent every 5 minutes is `0 */5 * * * *`. This, in plain text, means: \"When seconds is equal to 0, minutes is divisible by 5, for any hour, day of the month, month, day of the week, or year\".\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation\r\n",
      "sample.dat": "",
      "__init__.py": "import logging\r\n\r\nfrom azure.functions import TimerRequest\r\nfrom datetime import datetime, timezone\r\n\r\n\r\ndef main(mytimer: TimerRequest) -> None:\r\n    utc_timestamp = datetime.utcnow().replace(tzinfo=timezone.utc).isoformat()\r\n\r\n    if mytimer.past_due:\r\n        logging.info('The timer is past due!')\r\n\r\n    logging.info('Python timer trigger function ran at %s', utc_timestamp)\r\n"
    },
    "function": {
      "scriptFile": "__init__.py",
      "bindings": [
        {
          "name": "mytimer",
          "type": "timerTrigger",
          "direction": "in",
          "schedule": "0 */5 * * * *"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "TimerTrigger",
      "description": "$TimerTrigger_description",
      "name": "Timer trigger",
      "language": "Python",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "timer",
      "enabledInTryMode": true,
      "userPrompt": [
        "schedule"
      ],
      "filters": [
        "Python3"
      ]
    }
  },
  {
    "id": "TimerTrigger-TypeScript",
    "runtime": "2",
    "files": {
      "index.ts": "import { AzureFunction, Context, Timer } from \"@azure/functions\"\r\n\r\nconst timerTrigger: AzureFunction = async function (context: Context, myTimer: Timer): Promise<void> {\r\n    var timeStamp = new Date().toISOString();\r\n    \r\n    if (myTimer.isPastDue)\r\n    {\r\n        context.log('Timer function is running late!');\r\n    }\r\n    context.log('Timer trigger function ran!', timeStamp);   \r\n};\r\n\r\nexport default timerTrigger;\r\n",
      "readme.md": "# TimerTrigger - TypeScript\r\n\r\nThe `TimerTrigger` makes it incredibly easy to have your functions executed on a schedule. This sample demonstrates a simple use case of calling your function every 5 minutes.\r\n\r\n## How it works\r\n\r\nFor a `TimerTrigger` to work, you provide a schedule in the form of a [cron expression](https://en.wikipedia.org/wiki/Cron#CRON_expression)(See the link for full details). A cron expression is a string with 6 separate expressions which represent a given schedule via patterns. The pattern we use to represent every 5 minutes is `0 */5 * * * *`. This, in plain text, means: \"When seconds is equal to 0, minutes is divisible by 5, for any hour, day of the month, month, day of the week, or year\".\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation"
    },
    "function": {
      "bindings": [
        {
          "name": "myTimer",
          "type": "timerTrigger",
          "direction": "in",
          "schedule": "0 */5 * * * *"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "TimerTrigger",
      "description": "$TimerTrigger_description",
      "name": "Timer trigger",
      "language": "TypeScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "timer",
      "enabledInTryMode": true,
      "userPrompt": [
        "schedule"
      ]
    }
  }
]