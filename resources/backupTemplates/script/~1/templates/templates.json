[
  {
    "id": "AppInsightsHttpAvailability-CSharp",
    "runtime": "1",
    "files": {
      "project.json": "{\r\n    \"frameworks\": {\r\n        \"net46\": {\r\n            \"dependencies\": {\r\n                \"Microsoft.ApplicationInsights\": \"2.3.0\"\r\n            }\r\n        }\r\n    }\r\n}\r\n",
      "readme.md": "# AppInsightsHttpAvailability - C<span>#</span>\r\n\r\nThe `AppInsightsHttpAvailability` makes it incredibly easy to have a custom function, \r\nwhich monitor availability and responsiveness of any web app with Application Insights executed on a schedule. \r\nThis sample demonstrates a simple use case of calling your web app every 5 minutes.\r\n\r\n> Note that you can also create multiple `AppInsightsHttpAvailability` function from multiple [Azure regions](https://azure.microsoft.com/en-us/regions) \r\n> to monitor the availability from multiple locations around the world.  \r\n> RunLocation will be configured accordingly from these regions.\r\n\r\n## How it works\r\n\r\nFor a `AppInsightsHttpAvailability` to work, \r\nyou provide a schedule in the form of a [cron expression](https://en.wikipedia.org/wiki/Cron#CRON_expression) (See the link for full details). \r\nA cron expression is a string with 6 separate expressions which represent a given schedule via patterns. \r\nThe pattern we use to represent every 5 minutes is `0 */5 * * * *`. \r\nThis, in plain text, means: \"When seconds is equal to 0, minutes is divisible by 5, for any hour, day of the month, month, day of the week, or year\".\r\n\r\nYou also have to provide the `Application Insights Instrumentation Key` by adding `AI_IKEY` in the `Application settings`.\r\n\r\n## Learn more\r\n\r\nHere's how you can [Create an Application Insights resource](https://docs.microsoft.com/en-us/azure/application-insights/app-insights-create-new-resource)  \r\nHere's how you can [Configure Azure Function Application settings](https://docs.microsoft.com/en-us/azure/azure-functions/functions-how-to-use-azure-function-app-settings)\r\n\r\n## Feedbacks or Questions\r\n\r\nPlease visit [Application Insights forum](https://social.msdn.microsoft.com/Forums/vstudio/en-US/home?forum=ApplicationInsights)\r\n",
      "run.csx": "using System.Configuration;\r\nusing System.Diagnostics;\r\n\r\nusing Microsoft.ApplicationInsights;\r\nusing Microsoft.ApplicationInsights.DataContracts;\r\n\r\n// This sample demonstrates a simple use case of calling your web app every 5 minutes.\r\n\r\n// Note that you can also create multiple functions from multiple [Azure regions](https://azure.microsoft.com/en-us/regions) \r\n// to monitor the availability from multiple locations around the world.\r\n// RunLocation will be configured accordingly from these regions.\r\n\r\n// For questions or feedbacks, please visit [Application Insights forum] https://social.msdn.microsoft.com/Forums/vstudio/en-US/home?forum=ApplicationInsights\r\n\r\n// setup synthetic headers used for client-server telemetry correlation\r\nprivate const string SyntheticTestId = \"SyntheticTest-Id\";\r\nprivate const string SyntheticTestRunId = \"SyntheticTest-RunId\";\r\nprivate const string SyntheticTestLocation = \"SyntheticTest-Location\";\r\n\r\n// [CONFIGURATION_REQUIRED] configure {AI_IKEY} accordingly in App Settings with Instrumentation Key obtained from Application Insights\r\n// [Get an Application Insights Instrumentation Key] https://docs.microsoft.com/en-us/azure/application-insights/app-insights-create-new-resource\r\n// [Configure Azure Function Application settings] https://docs.microsoft.com/en-us/azure/azure-functions/functions-how-to-use-azure-function-app-settings\r\nprivate static readonly TelemetryClient TelemetryClient = new TelemetryClient { InstrumentationKey = ConfigurationManager.AppSettings[\"AI_IKEY\"] };\r\n\r\n// [CONFIGURATION_REQUIRED] configure test timeout accordingly for which your request should run\r\nprivate static readonly HttpClient HttpClient = new HttpClient { Timeout = TimeSpan.FromSeconds(30) };\r\n\r\npublic static async Task Run(TimerInfo myTimer, TraceWriter log)\r\n{\r\n    if (myTimer.IsPastDue)\r\n    {\r\n        log.Warning($\"[Warning]: Timer is running late! Last ran at: {myTimer.ScheduleStatus.Last}\");\r\n    }\r\n\r\n    // [CONFIGURATION_REQUIRED] provide {testName} accordingly for your test function\r\n    string testName = \"AvailabilityTestFunction\";\r\n    if (!HttpClient.DefaultRequestHeaders.Contains(SyntheticTestId))\r\n    {\r\n        HttpClient.DefaultRequestHeaders.Add(SyntheticTestId, testName);\r\n    }\r\n\r\n    // REGION_NAME is a default environment variable that comes with App Service\r\n    string location = Environment.GetEnvironmentVariable(\"REGION_NAME\");\r\n    if (!HttpClient.DefaultRequestHeaders.Contains(SyntheticTestLocation))\r\n    {\r\n        HttpClient.DefaultRequestHeaders.Add(SyntheticTestLocation, location);\r\n    }\r\n\r\n    // [CONFIGURATION_REQUIRED] configure {uri} and {contentMatch} accordingly for your web app\r\n    await AvailabilityTestRun(\r\n        name: testName,\r\n        location: location,\r\n        uri: \"https://azure.microsoft.com/en-us/services/application-insights\",\r\n        contentMatch: \"Application Insights\",\r\n        log: log\r\n    );\r\n}\r\n\r\nprivate static async Task AvailabilityTestRun(string name, string location, string uri, string contentMatch, TraceWriter log)\r\n{\r\n    log.Info($\"Executing availability test run for {name} at: {DateTime.Now}\");\r\n\r\n    // generate operation ID to allow issue tracking\r\n    string operationId = Guid.NewGuid().ToString();\r\n    log.Verbose($\"[Verbose]: Operation ID is {operationId}\");\r\n\r\n    // always update the run Id for every run\r\n    if (HttpClient.DefaultRequestHeaders.Contains(SyntheticTestRunId))\r\n    {\r\n        HttpClient.DefaultRequestHeaders.Remove(SyntheticTestRunId);\r\n    }\r\n\r\n    HttpClient.DefaultRequestHeaders.Add(SyntheticTestRunId, operationId);\r\n\r\n    var availability = new AvailabilityTelemetry\r\n    {\r\n        Id = operationId,\r\n        Name = name,\r\n        RunLocation = location,\r\n        Success = false\r\n    };\r\n    availability.Context.Operation.Id = operationId;\r\n    availability.Properties.Add(\"TestUri\", uri);\r\n    var stopwatch = new Stopwatch();\r\n    stopwatch.Start();\r\n    bool isMonitoringFailure = false;\r\n\r\n    try\r\n    {\r\n        using (var httpResponse = await HttpClient.GetAsync(uri))\r\n        {\r\n            // add test results to availability telemetry property\r\n            availability.Properties.Add(\"HttpResponseStatusCode\", Convert.ToInt32(httpResponse.StatusCode).ToString());\r\n\r\n            // check if response content contains specific text\r\n            string content = httpResponse.Content != null ? await httpResponse.Content.ReadAsStringAsync() : \"\";\r\n            availability.Properties.Add(\"HttpResponseContent\", content);\r\n            if (httpResponse.IsSuccessStatusCode && content.Contains(contentMatch))\r\n            {\r\n                availability.Success = true;\r\n                availability.Message = $\"Test succeeded with response: {httpResponse.StatusCode}\";\r\n                log.Verbose($\"[Verbose]: {availability.Message}\");\r\n            }\r\n            else if (!httpResponse.IsSuccessStatusCode)\r\n            {\r\n                availability.Message = $\"Test failed with response: {httpResponse.StatusCode}\";\r\n                log.Warning($\"[Warning]: {availability.Message}\");\r\n            }\r\n            else\r\n            {\r\n                availability.Message = $\"Test content does not contain: {contentMatch}\";\r\n                log.Warning($\"[Warning]: {availability.Message}\");\r\n            }\r\n        }\r\n    }\r\n    catch (TaskCanceledException e)\r\n    {\r\n        availability.Message = $\"Test timed out: {e.Message}\";\r\n        log.Warning($\"[Warning]: {availability.Message}\");\r\n    }\r\n    catch (Exception ex)\r\n    {\r\n        // track exception when unable to determine the state of web app\r\n        isMonitoringFailure = true;\r\n        var exceptionTelemetry = new ExceptionTelemetry(ex);\r\n        exceptionTelemetry.Context.Operation.Id = operationId;\r\n        exceptionTelemetry.Properties.Add(\"TestName\", name);\r\n        exceptionTelemetry.Properties.Add(\"TestLocation\", location);\r\n        exceptionTelemetry.Properties.Add(\"TestUri\", uri);\r\n        TelemetryClient.TrackException(exceptionTelemetry);\r\n        log.Error($\"[Error]: {ex.Message}\");\r\n\r\n        // optional - throw to fail the function\r\n        throw;\r\n    }\r\n    finally\r\n    {\r\n        stopwatch.Stop();\r\n        availability.Duration = stopwatch.Elapsed;\r\n        availability.Timestamp = DateTimeOffset.UtcNow;\r\n\r\n        // do not make assumption for the state of web app when is monitoring failure\r\n        if (!isMonitoringFailure)\r\n        {\r\n            TelemetryClient.TrackAvailability(availability);\r\n            log.Info($\"Availability telemetry for {name} is sent.\");\r\n        }\r\n\r\n        // call flush to ensure telemetries are sent\r\n        TelemetryClient.Flush();\r\n    }\r\n}"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "type": "timerTrigger",
          "name": "myTimer",
          "direction": "in",
          "schedule": "0 */5 * * * *"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "HttpAvailability",
      "description": "$AppInsightsHttpAvailability_description",
      "name": "Application Insights HTTP availability",
      "language": "C#",
      "category": [
        "$temp_category_monitoring",
        "$temp_category_samples"
      ],
      "categoryStyle": "timer",
      "enabledInTryMode": false,
      "userPrompt": [
        "schedule"
      ]
    }
  },
  {
    "id": "AppInsightsRealtimePowerBI-CSharp",
    "runtime": "1",
    "files": {
      "readme.md": "# AppInsightsRealtimePowerBI - C<span>#</span>\r\n\r\nThe `AppInsightsRealtimePowerBI` makes it incredibly easy to push real-time data from Application Insights to Power BI. \r\nThis sample demonstrates a simple use case of getting real-time availability percentage \r\nover last 20 minutes on Power BI at per minute refresh with specified target availability percentage.\r\n\r\n> Note that you can also change the query to use different metrics/segments/aggregations/filters for your need  \r\n\r\n> Also note that about [API Rate limits](https://dev.applicationinsights.io/documentation/Authorization/Rate-limits)  \r\n> So it would be wise to disable the function (Your Function > Manage > Disabled) when not in use\r\n\r\n## How it works\r\n\r\nFor a `AppInsightsRealtimePowerBI` to work, \r\nyou provide a schedule in the form of a [cron expression](https://en.wikipedia.org/wiki/Cron#CRON_expression) (See the link for full details). \r\nA cron expression is a string with 6 separate expressions which represent a given schedule via patterns. \r\nThe pattern we use to represent every day is `0 * * * * *`. \r\nThis, in plain text, means: \"When seconds is equal to 0, for any minute, hour, day of the month, month, day of the week, or year\".\r\n\r\nYou also have to provide the `Application Insights Application ID` and `Application Insights API Access KEY` with `Read telemetry` access, \r\nby adding `AI_APP_ID` and `AI_APP_KEY` in the `Application settings`.\r\n\r\nFor the Power BI to work, you need to provide the **Push URL** which can be obtained as follows:  \r\napp.powerbi.com > new dashboard > Add tile > Custom Streaming Data > Add streaming dataset > API > Next >  \r\nAdd a field with name `ts` and type DateTime (represents timestamp of calculation)  \r\nAdd a field with name `availability` and type Number (represents availability percentage for the interval)  \r\nAdd a field with name `target` and type Number (represents targeting percentage)  \r\nAdd a field with name `min` and type Number (represents minimum percentage)  \r\nAdd a field with name `max` and type Number (represents maximum percentage)  \r\nCreate > Copy the **\"Push URL\"** and paste it as the value of {RealTimePushURL}  \r\n\r\n## Learn more\r\n\r\nHere's how you can [Create an Application Insights resource](https://docs.microsoft.com/en-us/azure/application-insights/app-insights-create-new-resource)  \r\nHere's how you can [Get your Application ID and API key](https://dev.applicationinsights.io/documentation/Authorization/API-key-and-App-ID)  \r\nHere's how you can [Configure Azure Function Application settings](https://docs.microsoft.com/en-us/azure/azure-functions/functions-how-to-use-azure-function-app-settings)  \r\nHere's where you can find out more about [Power BI REST API for real-time data push](https://msdn.microsoft.com/en-us/library/dn877544.aspx)  \r\nHere's where you can find out more about [Application Insights data access REST API](https://dev.applicationinsights.io/documentation/Using-the-API/Power-BI)  \r\n\r\n## Feedbacks or Questions\r\n\r\nPlease visit [Application Insights forum](https://social.msdn.microsoft.com/Forums/vstudio/en-US/home?forum=ApplicationInsights)\r\n",
      "run.csx": "#r \"Newtonsoft.Json\"\r\n\r\nusing System.Configuration;\r\nusing System.Text;\r\n\r\nusing Newtonsoft.Json.Linq;\r\n\r\n// This sample demonstrates a simple use case of getting real-time availability percentage \r\n// over last 20 minutes onto Power BI at per minute refresh with specified target availability percentage.\r\n\r\n// Note that you can also change the query to use different metrics/segments/aggregations/filters for your need\r\n\r\n// Also note that about [API Rate limits](https://dev.applicationinsights.io/documentation/Authorization/Rate-limits)\r\n// So it would be wise to disable the function (Your Function > Manage > Disabled) when not in use\r\n\r\n// For the Power BI to work, you need to provide the \"Push URL\" which can be obtained as follows:\r\n// app.powerbi.com > new dashboard > Add tile > Custom Streaming Data > Add streaming dataset > API > Next >\r\n// Add a field with name `ts` and type DateTime (represents timestamp of calculation)\r\n// Add a field with name `availability` and type Number (represents availability percentage for the interval)\r\n// Add a field with name `target` and type Number (represents targeting percentage)\r\n// Add a field with name `min` and type Number (represents minimum percentage)\r\n// Add a field with name `max` and type Number (represents maximum percentage)\r\n// Create > Copy the \"Push URL\" and paste it as the value of {RealTimePushURL}\r\n\r\n// For questions or feedbacks, please visit [Application Insights forum] https://social.msdn.microsoft.com/Forums/vstudio/en-US/home?forum=ApplicationInsights\r\n\r\nprivate const string AppInsightsApi = \"https://api.applicationinsights.io/beta/apps\";\r\n\r\n// [CONFIGURATION_REQUIRED] configure {RealTimePushURL} accordingly with values obtained from Power BI\r\n// [Get REST API URL endpoint] https://powerbi.microsoft.com/documentation/powerbi-service-real-time-streaming\r\nprivate const string RealTimePushURL = \"REAL_TIME_PUSH_URL\";\r\n\r\n// [CONFIGURATION_REQUIRED] configure {AI_APP_ID} and {AI_APP_KEY} accordingly in App Settings with values obtained from Application Insights\r\n// [Get your Application ID and API key] https://dev.applicationinsights.io/documentation/Authorization/API-key-and-App-ID\r\n// [Configure Azure Function Application settings] https://docs.microsoft.com/en-us/azure/azure-functions/functions-how-to-use-azure-function-app-settings\r\nprivate static readonly string AiAppId = ConfigurationManager.AppSettings[\"AI_APP_ID\"];\r\nprivate static readonly string AiAppKey = ConfigurationManager.AppSettings[\"AI_APP_KEY\"];\r\n\r\npublic static async Task Run(TimerInfo myTimer, TraceWriter log)\r\n{\r\n    if (myTimer.IsPastDue)\r\n    {\r\n        log.Warning($\"[Warning]: Timer is running late! Last ran at: {myTimer.ScheduleStatus.Last}\");\r\n    }\r\n\r\n    log.Info($\"Executing real-time Power BI run at: {DateTime.Now}\");\r\n\r\n    // [CONFIGURATION_REQUIRED] update accordingly for your scenario\r\n    TimeSpan availabilityInterval = TimeSpan.FromMinutes(20);\r\n    double targetAvailability = 80;\r\n\r\n    using (var httpClient = new HttpClient())\r\n    {\r\n        // generate request ID to allow issue tracking\r\n        string requestId = Guid.NewGuid().ToString();\r\n        log.Verbose($\"[Verbose]: API request ID is {requestId}\");\r\n        httpClient.DefaultRequestHeaders.Add(\"x-api-key\", AiAppKey);\r\n        httpClient.DefaultRequestHeaders.Add(\"x-ms-app\", \"FunctionTemplate\");\r\n        httpClient.DefaultRequestHeaders.Add(\"x-ms-client-request-id\", requestId);\r\n        string metric = \"availabilityResults/count\";\r\n        string segment = \"availabilityResult/success\";\r\n        string aggregation = \"sum\";\r\n        string from = DateTime.UtcNow.Subtract(availabilityInterval).ToString(\"o\");\r\n        string to = DateTime.UtcNow.ToString(\"o\");\r\n        string apiPath = $\"{AppInsightsApi}/{AiAppId}/metrics/{metric}?useMDM=true&clientId={requestId}&timespan={from}/{to}&segment={segment}&aggregation={aggregation}\";\r\n        using (var httpResponse = await httpClient.GetAsync(apiPath))\r\n        {\r\n            httpResponse.EnsureSuccessStatusCode();\r\n            var resultJson = await httpResponse.Content.ReadAsAsync<JToken>();\r\n            JToken segments = resultJson.SelectToken(\"value.segments\");\r\n            int segmentCount = segments?.Count() ?? 0;\r\n            long[] results = new long[2];\r\n            for (int i = 0; i < segmentCount; i++)\r\n            {\r\n                int segmentValue = segments.SelectToken($\"[{i}].{segment}\").ToObject<int>();\r\n                results[segmentValue] = segments.SelectToken($\"[{i}].{metric}.{aggregation}\").ToObject<long>();\r\n            }\r\n\r\n            long passed = results[1];\r\n            long failed = results[0];\r\n            long total = passed + failed;\r\n            string availabilityPercentage = passed > 0 ? (100.0d * passed / total).ToString(\"N2\") : \"0\";\r\n            string postData = $\"[{{ \\\"ts\\\": \\\"{to}\\\", \\\"availability\\\": {availabilityPercentage}, \\\"target\\\": {targetAvailability}, \\\"min\\\": 0, \\\"max\\\": 100 }}]\";\r\n            log.Verbose($\"[Verbose]: Sending data: {postData}\");\r\n            using (var response = await httpClient.PostAsync(RealTimePushURL, new ByteArrayContent(Encoding.UTF8.GetBytes(postData))))\r\n            {\r\n                log.Verbose($\"[Verbose]: Data sent with response: {response.StatusCode}\");\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "type": "timerTrigger",
          "name": "myTimer",
          "direction": "in",
          "schedule": "0 * * * * *"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "RealtimePowerBI",
      "description": "$AppInsightsRealtimePowerBI_description",
      "name": "Application Insights Power BI",
      "language": "C#",
      "category": [
        "$temp_category_monitoring",
        "$temp_category_samples"
      ],
      "categoryStyle": "timer",
      "enabledInTryMode": false,
      "userPrompt": [
        "schedule"
      ]
    }
  },
  {
    "id": "AppInsightsScheduledAnalytics-CSharp",
    "runtime": "1",
    "files": {
      "project.json": "{\r\n    \"frameworks\": {\r\n        \"net46\": {\r\n            \"dependencies\": {\r\n                \"Microsoft.ApplicationInsights\": \"2.3.0\"\r\n            }\r\n        }\r\n    }\r\n}\r\n",
      "readme.md": "# AppInsightsScheduledAnalytics - C<span>#</span>\r\n\r\nThe `AppInsightsScheduledAnalytics` makes it incredibly easy to generate derived metric from your query. \r\nThis sample demonstrates a simple use case of generating derived metric every 5 minutes.\r\n\r\n> Note that the idea with this derived metric is that you can easily use it to setup _query-like_ alerting or dashboard. \r\n> Another important usage of this is to support Autoscale, you can use this derived metric as the source for an Autoscale setting. \r\n> [Get started with auto scale by custom metric in Azure](https://docs.microsoft.com/en-us/azure/monitoring-and-diagnostics/monitoring-autoscale-scale-by-custom-metric)\r\n\r\n## How it works\r\n\r\nFor a `AppInsightsScheduledAnalytics` to work, \r\nyou provide a schedule in the form of a [cron expression](https://en.wikipedia.org/wiki/Cron#CRON_expression) (See the link for full details). \r\nA cron expression is a string with 6 separate expressions which represent a given schedule via patterns. \r\nThe pattern we use to represent every 5 minutes is `0 */5 * * * *`. \r\nThis, in plain text, means: \"When seconds is equal to 0, minutes is divisible by 5, for any hour, day of the month, month, day of the week, or year\".\r\n\r\nYou also have to provide the `Application Insights Instrumentation Key`, \r\n`Application Insights Application ID` and `Application Insights API Access KEY` with `Read telemetry` access, \r\nby adding `AI_IKEY`, `AI_APP_ID` and `AI_APP_KEY` repectively in the `Application settings`.\r\n\r\nAlso please be sure to execute the query in `Application Insights Analytics` portal first for validation of the query!\r\n\r\n## Learn more\r\n\r\nHere's how you can [Create an Application Insights resource](https://docs.microsoft.com/en-us/azure/application-insights/app-insights-create-new-resource)  \r\nHere's how you can [Get your Application ID and API key](https://dev.applicationinsights.io/documentation/Authorization/API-key-and-App-ID)  \r\nHere's how you can [Configure Azure Function Application settings](https://docs.microsoft.com/en-us/azure/azure-functions/functions-how-to-use-azure-function-app-settings)  \r\nHere's how you can [Setup alerts](https://docs.microsoft.com/en-us/azure/application-insights/app-insights-alerts)  \r\nHere's where you can find out more about [Application Insights Analytics](https://docs.microsoft.com/en-us/azure/application-insights/app-insights-analytics)  \r\nHere's where you can find out more about [Application Insights Dashboards](https://docs.microsoft.com/en-us/azure/application-insights/app-insights-dashboards)\r\n\r\n## Feedbacks or Questions\r\n\r\nPlease visit [Application Insights forum](https://social.msdn.microsoft.com/Forums/vstudio/en-US/home?forum=ApplicationInsights)\r\n",
      "run.csx": "#r \"Newtonsoft.Json\"\r\n\r\nusing System.Configuration;\r\n\r\nusing Microsoft.ApplicationInsights;\r\nusing Microsoft.ApplicationInsights.DataContracts;\r\nusing Newtonsoft.Json.Linq;\r\n\r\n// This sample demonstrates a simple use case of generating derived metric every 5 minutes.\r\n\r\n// Note that the idea with this derived metric is that you can easily use it to setup _query-like_ alerting or dashboard.\r\n// Another important usage of this is to support Autoscale, you can use this derived metric as the source for an Autoscale setting.\r\n// [Get started with auto scale by custom metric in Azure] https://docs.microsoft.com/en-us/azure/monitoring-and-diagnostics/monitoring-autoscale-scale-by-custom-metric\r\n\r\n// For questions or feedbacks, please visit [Application Insights forum] https://social.msdn.microsoft.com/Forums/vstudio/en-US/home?forum=ApplicationInsights\r\n\r\nprivate const string AppInsightsApi = \"https://api.applicationinsights.io/beta/apps\";\r\n\r\n// [CONFIGURATION_REQUIRED] configure {AI_IKEY} accordingly in App Settings with Instrumentation Key obtained from Application Insights\r\n// [Get an Application Insights Instrumentation Key] https://docs.microsoft.com/en-us/azure/application-insights/app-insights-create-new-resource\r\n// [Configure Azure Function Application settings] https://docs.microsoft.com/en-us/azure/azure-functions/functions-how-to-use-azure-function-app-settings\r\nprivate static readonly TelemetryClient TelemetryClient = new TelemetryClient { InstrumentationKey = ConfigurationManager.AppSettings[\"AI_IKEY\"] };\r\n\r\n// [CONFIGURATION_REQUIRED] configure {AI_APP_ID} and {AI_APP_KEY} accordingly in App Settings with values obtained from Application Insights\r\n// [Get your Application ID and API key] https://dev.applicationinsights.io/documentation/Authorization/API-key-and-App-ID\r\nprivate static readonly string AiAppId = ConfigurationManager.AppSettings[\"AI_APP_ID\"];\r\nprivate static readonly string AiAppKey = ConfigurationManager.AppSettings[\"AI_APP_KEY\"];\r\n\r\npublic static async Task Run(TimerInfo myTimer, TraceWriter log)\r\n{\r\n    if (myTimer.IsPastDue)\r\n    {\r\n        log.Warning($\"[Warning]: Timer is running late! Last ran at: {myTimer.ScheduleStatus.Last}\");\r\n    }\r\n\r\n    // [CONFIGURATION_REQUIRED] update the query accordingly for your need\r\n    // be sure to run it against Application Insights Analytics portal first for validation\r\n    // output should be a number if sending derived metrics\r\n    // [Application Insights Analytics] https://docs.microsoft.com/en-us/azure/application-insights/app-insights-analytics\r\n    await ScheduledAnalyticsRun(\r\n        name: \"ScheduledAnalyticsFunction\",\r\n        query: @\"\r\nrequests \r\n| where timestamp > ago(1h) \r\n| summarize passed = countif(success == true), total = count() \r\n| project passed * 1.0 / total * 100\r\n\",\r\n        log: log\r\n    );\r\n}\r\n\r\nprivate static async Task ScheduledAnalyticsRun(string name, string query, TraceWriter log)\r\n{\r\n    log.Info($\"Executing scheduled analytics run for {name} at: {DateTime.Now}\");\r\n\r\n    // generate request ID to allow issue tracking\r\n    string requestId = Guid.NewGuid().ToString();\r\n    log.Verbose($\"[Verbose]: API request ID is {requestId}\");\r\n\r\n    try\r\n    {\r\n        MetricTelemetry metric = new MetricTelemetry { Name = name };\r\n        metric.Context.Operation.Id = requestId;\r\n        metric.Properties.Add(\"TestAppId\", AiAppId);\r\n        metric.Properties.Add(\"TestQuery\", query);\r\n        metric.Properties.Add(\"TestRequestId\", requestId);\r\n        using (var httpClient = new HttpClient())\r\n        {\r\n            httpClient.DefaultRequestHeaders.Add(\"x-api-key\", AiAppKey);\r\n            httpClient.DefaultRequestHeaders.Add(\"x-ms-app\", \"FunctionTemplate\");\r\n            httpClient.DefaultRequestHeaders.Add(\"x-ms-client-request-id\", requestId);\r\n            string apiPath = $\"{AppInsightsApi}/{AiAppId}/query?clientId={requestId}&timespan=P1D&query={query}\";\r\n            using (var httpResponse = await httpClient.GetAsync(apiPath))\r\n            {\r\n                // throw exception when unable to determine the metric value\r\n                httpResponse.EnsureSuccessStatusCode();\r\n                var resultJson = await httpResponse.Content.ReadAsAsync<JToken>();\r\n                double result;\r\n                if (double.TryParse(resultJson.SelectToken(\"Tables[0].Rows[0][0]\")?.ToString(), out result))\r\n                {\r\n                    metric.Sum = result;\r\n                    log.Verbose($\"[Verbose]: Metric result is {metric.Sum}\");\r\n                }\r\n                else\r\n                {\r\n                    log.Error($\"[Error]: {resultJson.ToString()}\");\r\n                    throw new FormatException(\"Query must result in a single metric number. Try it on Analytics before scheduling.\");\r\n                }\r\n            }\r\n        }\r\n\r\n        TelemetryClient.TrackMetric(metric);\r\n        log.Info($\"Metric telemetry for {name} is sent.\");\r\n    }\r\n    catch (Exception ex)\r\n    {\r\n        // track exception when unable to determine the metric value\r\n        var exceptionTelemetry = new ExceptionTelemetry(ex);\r\n        exceptionTelemetry.Context.Operation.Id = requestId;\r\n        exceptionTelemetry.Properties.Add(\"TestName\", name);\r\n        exceptionTelemetry.Properties.Add(\"TestAppId\", AiAppId);\r\n        exceptionTelemetry.Properties.Add(\"TestQuery\", query);\r\n        exceptionTelemetry.Properties.Add(\"TestRequestId\", requestId);\r\n        TelemetryClient.TrackException(exceptionTelemetry);\r\n        log.Error($\"[Error]: Client Request ID {requestId}: {ex.Message}\");\r\n\r\n        // optional - throw to fail the function\r\n        throw;\r\n    }\r\n    finally\r\n    {\r\n        TelemetryClient.Flush();\r\n    }\r\n}\r\n"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "type": "timerTrigger",
          "name": "myTimer",
          "direction": "in",
          "schedule": "0 */5 * * * *"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ScheduledAnalytics",
      "description": "$AppInsightsScheduledAnalytics_description",
      "name": "Application Insights scheduled analytics",
      "language": "C#",
      "category": [
        "$temp_category_dataProcessing",
        "$temp_category_monitoring",
        "$temp_category_samples"
      ],
      "categoryStyle": "timer",
      "enabledInTryMode": false,
      "userPrompt": [
        "schedule"
      ]
    }
  },
  {
    "id": "AppInsightsScheduledDigest-CSharp",
    "runtime": "1",
    "files": {
      "readme.md": "# AppInsightsScheduledDigest - C<span>#</span>\r\n\r\nThe `AppInsightsScheduledDigest` makes it incredibly easy to customize your digest emails and execute it on configurable schedule. \r\nThis sample demonstrates a simple use case of getting digest email once a day.\r\n\r\n> Note that you can also update the query for weekly or monthly digest reports, or even to provide deeper insights.\r\n\r\n## How it works\r\n\r\nFor a `AppInsightsScheduledDigest` to work, \r\nyou provide a schedule in the form of a [cron expression](https://en.wikipedia.org/wiki/Cron#CRON_expression) (See the link for full details). \r\nA cron expression is a string with 6 separate expressions which represent a given schedule via patterns. \r\nThe pattern we use to represent every day is `0 0 2 * * *`. \r\nThis, in plain text, means: \"When seconds is equal to 0, minutes is equal to 0, hours is equal to 2, for any day of the month, month, day of the week, or year\".\r\n\r\nYou also have to provide the `Application Insights Application ID` and `Application Insights API Access KEY` with `Read telemetry` access, \r\nby adding `AI_APP_ID` and `AI_APP_KEY` in the `Application settings`.\r\n\r\nAlso note that if you are updating the query, be sure to run it through `Application Insights Analytics` portal first for validation of the query!\r\n\r\nFor the email to work, you need to provide the `SendGridApiKey` in the `Application settings`. \r\nThe one in the `function.json` points to the `Key Name` in the `Application Settings`, \r\nso create a `Key` named `SendGridApiKey` with the value for the API Key obtained from `SendGrid`.\r\n\r\n## Learn more\r\n\r\nHere's how you can [Create an Application Insights resource](https://docs.microsoft.com/en-us/azure/application-insights/app-insights-create-new-resource)  \r\nHere's how you can [Get your Application ID and API key](https://dev.applicationinsights.io/documentation/Authorization/API-key-and-App-ID)  \r\nHere's how you can [Configure Azure Function Application settings](https://docs.microsoft.com/en-us/azure/azure-functions/functions-how-to-use-azure-function-app-settings)  \r\nHere's where you can find out more about [SendGrid API Key](https://sendgrid.com/docs/Classroom/Basics/API/what_is_my_api_key.html)\r\n\r\n## Feedbacks or Questions\r\n\r\nPlease visit [Application Insights forum](https://social.msdn.microsoft.com/Forums/vstudio/en-US/home?forum=ApplicationInsights)\r\n",
      "run.csx": "#r \"Newtonsoft.Json\"\r\n#r \"SendGrid\"\r\n\r\nusing System.Configuration;\r\n\r\nusing Newtonsoft.Json.Linq;\r\nusing SendGrid.Helpers.Mail;\r\n\r\n// This sample demonstrates a simple use case of getting digest email once a day.\r\n\r\n// Note that you can also update the query for weekly or monthly digest reports, or even to provide deeper insights.\r\n\r\n// For questions or feedbacks, please visit [Application Insights forum] https://social.msdn.microsoft.com/Forums/vstudio/en-US/home?forum=ApplicationInsights\r\n\r\nprivate const string AppInsightsApi = \"https://api.applicationinsights.io/beta/apps\";\r\n\r\n// [CONFIGURATION_REQUIRED] configure {AI_APP_ID} and {AI_APP_KEY} accordingly in App Settings with values obtained from Application Insights\r\n// [Get your Application ID and API key] https://dev.applicationinsights.io/documentation/Authorization/API-key-and-App-ID\r\n// [Configure Azure Function Application settings] https://docs.microsoft.com/en-us/azure/azure-functions/functions-how-to-use-azure-function-app-settings\r\nprivate static readonly string AiAppId = ConfigurationManager.AppSettings[\"AI_APP_ID\"];\r\nprivate static readonly string AiAppKey = ConfigurationManager.AppSettings[\"AI_APP_KEY\"];\r\n\r\n// [CONFIGURATION_REQUIRED] configure {SendGridApiKey} accordingly in App Settings with API Key obtained from SendGrid\r\n// [Obtain SendGrid API Key] https://sendgrid.com/docs/Classroom/Basics/API/what_is_my_api_key.html\r\npublic static async Task<Mail> Run(TimerInfo myTimer, TraceWriter log)\r\n{\r\n    if (myTimer.IsPastDue)\r\n    {\r\n        log.Warning($\"[Warning]: Timer is running late! Last ran at: {myTimer.ScheduleStatus.Last}\");\r\n    }\r\n\r\n    DigestResult result = await ScheduledDigestRun(\r\n        query: GetQueryString(),\r\n        log: log\r\n    );\r\n\r\n    // [CONFIGURATION_REQUIRED] configure {appName} accordingly for your app/email\r\n    string appName = \"Your\";\r\n    var today = DateTime.Today.ToShortDateString();\r\n    Content content = new Content\r\n    {\r\n        Type = \"text/html\",\r\n        Value = GetHtmlContentValue(appName, today, result)\r\n    };\r\n    Mail message = new Mail()\r\n    {\r\n        Subject = $\"Your daily Application Insights digest report for {today}\"\r\n    };\r\n    message.AddContent(content);\r\n\r\n    log.Info($\"Generating daily report for {today} at {DateTime.Now}\");\r\n    return message;\r\n}\r\n\r\nprivate static async Task<DigestResult> ScheduledDigestRun(string query, TraceWriter log)\r\n{\r\n    log.Info($\"Executing scheduled daily digest run at: {DateTime.Now}\");\r\n\r\n    // generate request ID to allow issue tracking\r\n    string requestId = Guid.NewGuid().ToString();\r\n    log.Verbose($\"[Verbose]: API request ID is {requestId}\");\r\n\r\n    try\r\n    {\r\n        using (var httpClient = new HttpClient())\r\n        {\r\n            httpClient.DefaultRequestHeaders.Add(\"x-api-key\", AiAppKey);\r\n            httpClient.DefaultRequestHeaders.Add(\"x-ms-app\", \"FunctionTemplate\");\r\n            httpClient.DefaultRequestHeaders.Add(\"x-ms-client-request-id\", requestId);\r\n            string apiPath = $\"{AppInsightsApi}/{AiAppId}/query?clientId={requestId}&timespan=P1W&query={query}\";\r\n            using (var httpResponse = await httpClient.GetAsync(apiPath))\r\n            {\r\n                // throw exception when unable to determine the metric value\r\n                httpResponse.EnsureSuccessStatusCode();\r\n                var resultJson = await httpResponse.Content.ReadAsAsync<JToken>();\r\n                DigestResult result = new DigestResult\r\n                {\r\n                    TotalRequests = resultJson.SelectToken(\"Tables[0].Rows[0][0]\")?.ToObject<long>().ToString(\"N0\"),\r\n                    FailedRequests = resultJson.SelectToken(\"Tables[0].Rows[0][1]\")?.ToObject<long>().ToString(\"N0\"),\r\n                    RequestsDuration = resultJson.SelectToken(\"Tables[0].Rows[0][2]\")?.ToString(),\r\n                    TotalDependencies = resultJson.SelectToken(\"Tables[0].Rows[0][3]\")?.ToObject<long>().ToString(\"N0\"),\r\n                    FailedDependencies = resultJson.SelectToken(\"Tables[0].Rows[0][4]\")?.ToObject<long>().ToString(\"N0\"),\r\n                    DependenciesDuration = resultJson.SelectToken(\"Tables[0].Rows[0][5]\")?.ToString(),\r\n                    TotalViews = resultJson.SelectToken(\"Tables[0].Rows[0][6]\")?.ToObject<long>().ToString(\"N0\"),\r\n                    TotalExceptions = resultJson.SelectToken(\"Tables[0].Rows[0][7]\")?.ToObject<long>().ToString(\"N0\"),\r\n                    OverallAvailability = resultJson.SelectToken(\"Tables[0].Rows[0][8]\")?.ToString(),\r\n                    AvailabilityDuration = resultJson.SelectToken(\"Tables[0].Rows[0][9]\")?.ToString()\r\n                };\r\n                return result;\r\n            }\r\n        }\r\n    }\r\n    catch (Exception ex)\r\n    {\r\n        log.Error($\"[Error]: Client Request ID {requestId}: {ex.Message}\");\r\n\r\n        // optional - throw to fail the function\r\n        throw;\r\n    }\r\n}\r\n\r\nprivate static string GetQueryString()\r\n{\r\n    // update the query accordingly for your need (be sure to run it against Application Insights Analytics portal first for validation)\r\n    // [Application Insights Analytics] https://docs.microsoft.com/en-us/azure/application-insights/app-insights-analytics\r\n    return @\"\r\nrequests\r\n| where timestamp > ago(1d)\r\n| summarize Row = 1, TotalRequests = sum(itemCount), FailedRequests = sum(toint(success == 'False')),\r\n    RequestsDuration = iff(isnan(avg(duration)), '------', tostring(toint(avg(duration) * 100) / 100.0))\r\n| join (\r\ndependencies\r\n| where timestamp > ago(1d)\r\n| summarize Row = 1, TotalDependencies = sum(itemCount), FailedDependencies = sum(success == 'False'),\r\n    DependenciesDuration = iff(isnan(avg(duration)), '------', tostring(toint(avg(duration) * 100) / 100.0))\r\n) on Row | join (\r\npageViews\r\n| where timestamp > ago(1d)\r\n| summarize Row = 1, TotalViews = sum(itemCount)\r\n) on Row | join (\r\nexceptions\r\n| where timestamp > ago(1d)\r\n| summarize Row = 1, TotalExceptions = sum(itemCount)\r\n) on Row | join (\r\navailabilityResults\r\n| where timestamp > ago(1d)\r\n| summarize Row = 1, OverallAvailability = iff(isnan(avg(toint(success))), '------', tostring(toint(avg(toint(success)) * 10000) / 100.0)),\r\n    AvailabilityDuration = iff(isnan(avg(duration)), '------', tostring(toint(avg(duration) * 100) / 100.0))\r\n) on Row\r\n| project TotalRequests, FailedRequests, RequestsDuration, TotalDependencies, FailedDependencies, DependenciesDuration, TotalViews, TotalExceptions, OverallAvailability, AvailabilityDuration\r\n\";\r\n}\r\n\r\nprivate static string GetHtmlContentValue(string appName, string today, DigestResult result)\r\n{\r\n    // update the HTML template accordingly for your need\r\n    return $@\"\r\n<html><body>\r\n<p style='text-align: center;'><strong>{appName} daily telemetry report {today}</strong></p>\r\n<p style='text-align: center;'>The following data shows insights based on telemetry from last 24 hours.</p>\r\n<table align='center' style='width: 95%; max-width: 480px;'><tbody>\r\n<tr>\r\n<td style='min-width: 150px; text-align: left;'><strong>Total requests</strong></td>\r\n<td style='min-width: 100px; text-align: right;'><strong>{result.TotalRequests}</strong></td>\r\n</tr>\r\n<tr>\r\n<td style='min-width: 120px; padding-left: 5%; text-align: left;'>Failed requests</td>\r\n<td style='min-width: 100px; text-align: right;'>{result.FailedRequests}</td>\r\n</tr>\r\n<tr>\r\n<td style='min-width: 120px; padding-left: 5%; text-align: left;'>Average response time</td>\r\n<td style='min-width: 100px; text-align: right;'>{result.RequestsDuration} ms</td>\r\n</tr>\r\n<tr>\r\n<td colspan='2'><hr /></td>\r\n</tr>\r\n<tr>\r\n<td style='min-width: 150px; text-align: left;'><strong>Total dependencies</strong></td>\r\n<td style='min-width: 100px; text-align: right;'><strong>{result.TotalDependencies}</strong></td>\r\n</tr>\r\n<tr>\r\n<td style='min-width: 120px; padding-left: 5%; text-align: left;'>Failed dependencies</td>\r\n<td style='min-width: 100px; text-align: right;'>{result.FailedDependencies}</td>\r\n</tr>\r\n<tr>\r\n<td style='min-width: 120px; padding-left: 5%; text-align: left;'>Average response time</td>\r\n<td style='min-width: 100px; text-align: right;'>{result.DependenciesDuration} ms</td>\r\n</tr>\r\n<tr>\r\n<td colspan='2'><hr /></td>\r\n</tr>\r\n<tr>\r\n<td style='min-width: 150px; text-align: left;'><strong>Total views</strong></td>\r\n<td style='min-width: 100px; text-align: right;'><strong>{result.TotalViews}</strong></td>\r\n</tr>\r\n<tr>\r\n<td style='min-width: 150px; text-align: left;'><strong>Total exceptions</strong></td>\r\n<td style='min-width: 100px; text-align: right;'><strong>{result.TotalExceptions}</strong></td>\r\n</tr>\r\n<tr>\r\n<td colspan='2'><hr /></td>\r\n</tr>\r\n<tr>\r\n<td style='min-width: 150px; text-align: left;'><strong>Overall Availability</strong></td>\r\n<td style='min-width: 100px; text-align: right;'><strong>{result.OverallAvailability} %</strong></td>\r\n</tr>\r\n<tr>\r\n<td style='min-width: 120px; padding-left: 5%; text-align: left;'>Average response time</td>\r\n<td style='min-width: 100px; text-align: right;'>{result.AvailabilityDuration} ms</td>\r\n</tr>\r\n</tbody></table>\r\n</body></html>\r\n\";\r\n}\r\n\r\nprivate struct DigestResult\r\n{\r\n    public string TotalRequests;\r\n    public string FailedRequests;\r\n    public string RequestsDuration;\r\n    public string TotalDependencies;\r\n    public string FailedDependencies;\r\n    public string DependenciesDuration;\r\n    public string TotalViews;\r\n    public string TotalExceptions;\r\n    public string OverallAvailability;\r\n    public string AvailabilityDuration;\r\n}\r\n"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "type": "timerTrigger",
          "name": "myTimer",
          "direction": "in",
          "schedule": "0 0 2 * * *"
        },
        {
          "type": "sendGrid",
          "name": "$return",
          "direction": "out",
          "apiKey": "SendGridApiKey",
          "from": "Application Insights <ai-noreply@mail.windowsazure.com>",
          "to": "{EmailAddressToReceiveDigestReport}"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ScheduledDigest",
      "description": "$AppInsightsScheduledDigest_description",
      "name": "Application Insights scheduled digest",
      "language": "C#",
      "category": [
        "$temp_category_monitoring",
        "$temp_category_samples"
      ],
      "categoryStyle": "timer",
      "enabledInTryMode": false,
      "userPrompt": [
        "to",
        "from",
        "apiKey",
        "schedule"
      ]
    }
  },
  {
    "id": "BlobTrigger-Batch",
    "runtime": "1",
    "files": {
      "run.bat": "echo OFF\r\nFOR /F \"usebackq\" %%i IN ('%inputBlob%') DO set size=%%~zi\r\necho Blob trigger function Processed, blob size:%size% bytes",
      "sample.dat": "incontainer/sample.txt"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "inputBlob",
          "type": "blobTrigger",
          "direction": "in",
          "path": "incontainer/{name}",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "BlobTriggerBatch",
      "description": "$BlobTrigger_description",
      "name": "Blob trigger",
      "language": "Batch",
      "category": [
        "$temp_category_experimental"
      ],
      "categoryStyle": "blob",
      "enabledInTryMode": true,
      "userPrompt": [
        "connection",
        "path"
      ]
    }
  },
  {
    "id": "BlobTrigger-CSharp",
    "runtime": "1",
    "files": {
      "readme.md": "# BlobTrigger - C<span>#</span>\r\n\r\nThe `BlobTrigger` makes it incredibly easy to react to new Blobs inside of Azure Blob Storage. This sample demonstrates a simple use case of processing data from a given Blob using C#.\r\n\r\n## How it works\r\n\r\nFor a `BlobTrigger` to work, you provide a path which dictates where the blobs are located inside your container, and can also help restrict the types of blobs you wish to return. For instance, you can set the path to `samples/{name}.png` to restrict the trigger to only the samples path and only blobs with \".png\" at the end of their name.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
      "run.csx": "public static void Run(Stream myBlob, string name, TraceWriter log)\r\n{\r\n    log.Info($\"C# Blob trigger function Processed blob\\n Name:{name} \\n Size: {myBlob.Length} Bytes\");\r\n}\r\n",
      "sample.dat": "samples-workitems/workitem.txt"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "myBlob",
          "type": "blobTrigger",
          "direction": "in",
          "path": "samples-workitems/{name}",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "BlobTriggerCSharp",
      "description": "$BlobTrigger_description",
      "name": "Blob trigger",
      "language": "C#",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "blob",
      "enabledInTryMode": true,
      "userPrompt": [
        "connection",
        "path"
      ]
    }
  },
  {
    "id": "BlobTrigger-FSharp",
    "runtime": "1",
    "files": {
      "readme.md": "# BlobTrigger - FSharp\r\n\r\nThe `BlobTrigger` makes it incredibly easy to react to new Blobs inside of Azure Blob Storage. This sample demonstrates a simple use case of processing data from a given Blob using F#.\r\n\r\n## How it works\r\n\r\nFor a `BlobTrigger` to work, you provide a path which dictates where the blobs are located inside your container, and can also help restrict the types of blobs you wish to return. For instance, you can set the path to `samples/{name}.png` to restrict the trigger to only the samples path and only blobs with \".png\" at the end of their name.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
      "run.fsx": "open System\r\n\r\nlet Run(myBlob: Stream, name: string, log: TraceWriter) =\r\n    log.Verbose(sprintf \"F# Blob trigger function processed blob\\n Name: %s \\n Size: %d Bytes\" name myBlob.Length)\r\n",
      "sample.dat": "samples-workitems/workitem.txt"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "myBlob",
          "type": "blobTrigger",
          "direction": "in",
          "path": "samples-workitems/{name}",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "BlobTriggerFSharp",
      "description": "$BlobTrigger_description",
      "name": "Blob trigger",
      "language": "F#",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "blob",
      "enabledInTryMode": true,
      "userPrompt": [
        "connection",
        "path"
      ]
    }
  },
  {
    "id": "BlobTrigger-JavaScript",
    "runtime": "1",
    "files": {
      "index.js": "module.exports = function (context, myBlob) {\r\n    context.log(\"JavaScript blob trigger function processed blob \\n Name:\", context.bindingData.name, \"\\n Blob Size:\", myBlob.length, \"Bytes\");\r\n    context.done();\r\n};",
      "readme.md": "# BlobTrigger - JavaScript\r\n\r\nThe `BlobTrigger` makes it incredibly easy to react to new Blobs inside of Azure Blob Storage. This sample demonstrates a simple use case of processing data from a given Blob using JavaScript.\r\n\r\n## How it works\r\n\r\nFor a `BlobTrigger` to work, you provide a path which dictates where the blobs are located inside your container, and can also help restrict the types of blobs you wish to return. For instance, you can set the path to `samples/{name}.png` to restrict the trigger to only the samples path and only blobs with \".png\" at the end of their name.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
      "sample.dat": "samples-workitems/workitem.txt"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "myBlob",
          "type": "blobTrigger",
          "direction": "in",
          "path": "samples-workitems/{name}",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "BlobTriggerJS",
      "description": "$BlobTrigger_description",
      "name": "Blob trigger",
      "language": "JavaScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "blob",
      "enabledInTryMode": true,
      "userPrompt": [
        "connection",
        "path"
      ]
    }
  },
  {
    "id": "BlobTrigger-TypeScript",
    "runtime": "1",
    "files": {
      "index.ts": "export function run(context: any, myBlob: any): void {\r\n    context.log(`TypeScript blob trigger function processed blob \r\nName: ${context.bindingData.name}\r\nBlob Size: ${myBlob.length} Bytes`);\r\n    context.done();\r\n};",
      "readme.md": "# BlobTrigger - TypeScript\r\n\r\nThe `BlobTrigger` makes it incredibly easy to react to new Blobs inside of Azure Blob Storage. This sample demonstrates a simple use case of processing data from a given Blob using TypeScript.\r\n\r\n## How it works\r\n\r\nFor a `BlobTrigger` to work, you provide a path which dictates where the blobs are located inside your container, and can also help restrict the types of blobs you wish to return. For instance, you can set the path to `samples/{name}.png` to restrict the trigger to only the samples path and only blobs with \".png\" at the end of their name.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
      "sample.dat": "samples-workitems/workitem.txt"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "myBlob",
          "type": "blobTrigger",
          "direction": "in",
          "path": "samples-workitems/{name}",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "BlobTriggerTS",
      "description": "$BlobTrigger_description",
      "name": "Blob trigger",
      "language": "TypeScript",
      "category": [
        "$temp_category_experimental"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": true,
      "userPrompt": [
        "connection",
        "path"
      ]
    }
  },
  {
    "id": "CosmosDBTrigger-CSharp",
    "runtime": "1",
    "files": {
      "run.csx": "#r \"Microsoft.Azure.Documents.Client\"\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing Microsoft.Azure.Documents;\r\n\r\npublic static void Run(IReadOnlyList<Document> documents, TraceWriter log)\r\n{\r\n    if (documents != null && documents.Count > 0)\r\n    {\r\n        log.Verbose(\"Documents modified \" + documents.Count);\r\n        log.Verbose(\"First document Id \" + documents[0].Id);\r\n    }\r\n}\r\n"
    },
    "function": {
      "bindings": [
        {
          "type": "cosmosDBTrigger",
          "name": "documents",
          "direction": "in",
          "leaseCollectionName": "leases"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "CosmosTriggerCSharp",
      "description": "$CosmosDBTrigger_description",
      "name": "Cosmos DB trigger",
      "language": "C#",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "cosmosDB",
      "enabledInTryMode": false,
      "userPrompt": [
        "connectionStringSetting",
        "databaseName",
        "collectionName",
        "leaseCollectionName",
        "createLeaseCollectionIfNotExists"
      ]
    }
  },
  {
    "id": "CosmosDBTrigger-JavaScript",
    "runtime": "1",
    "files": {
      "index.js": "module.exports = function (context, documents) {\r\n    if (!!documents && documents.length > 0) {\r\n        context.log('Document Id: ', documents[0].id);\r\n    }\r\n\r\n    context.done();\r\n}\r\n",
      "sample.dat": "[\r\n\t{\r\n\t\t\"id\": \"sample\"\r\n\t}\r\n]"
    },
    "function": {
      "bindings": [
        {
          "type": "cosmosDBTrigger",
          "name": "documents",
          "direction": "in",
          "leaseCollectionName": "leases"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "CosmosTriggerJavascript",
      "description": "$CosmosDBTrigger_description",
      "name": "Cosmos DB trigger",
      "language": "JavaScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "cosmosDB",
      "enabledInTryMode": false,
      "userPrompt": [
        "connectionStringSetting",
        "databaseName",
        "collectionName",
        "leaseCollectionName",
        "createLeaseCollectionIfNotExists"
      ]
    }
  },
  {
    "id": "EventGridTrigger-CSharp",
    "runtime": "1",
    "files": {
      "run.csx": "#r \"Newtonsoft.Json\"\r\n\r\nusing Newtonsoft.Json;\r\nusing Newtonsoft.Json.Linq;\r\n\r\npublic static void Run(JObject eventGridEvent, TraceWriter log)\r\n{\r\n    log.Info(eventGridEvent.ToString(Formatting.Indented));\r\n}\r\n",
      "sample.dat": "{\n  'topic': '/subscriptions/5b4b650e-28b9-4790-b3ab-ddbd88d727c4/resourcegroups/test/providers/Microsoft.EventHub/namespaces/test',\n  'subject': 'eventhubs/test',\n  'eventType': 'captureFileCreated',\n  'eventTime': '2017-07-14T23:10:27.7689666Z',\n  'id': '7b11c4ce-1c34-4416-848b-1730e766f126',\n  'data': {\n    'fileUrl': 'https://test.blob.core.windows.net/debugging/testblob.txt',\n    'fileType': 'AzureBlockBlob',\n    'partitionId': '1',\n    'sizeInBytes': 0,\n    'eventCount': 0,\n    'firstSequenceNumber': -1,\n    'lastSequenceNumber': -1,\n    'firstEnqueueTime': '0001-01-01T00:00:00',\n    'lastEnqueueTime': '0001-01-01T00:00:00'\n  },\n  \"dataVersion\": \"\",\n  \"metadataVersion\": \"1\" \n}\n"
    },
    "function": {
      "bindings": [
        {
          "type": "eventGridTrigger",
          "name": "eventGridEvent",
          "direction": "in"
        }
      ],
      "disabled": false
    },
    "metadata": {
      "defaultFunctionName": "EventGridTriggerCSharp",
      "description": "$EventGridTrigger_description",
      "name": "Event Grid trigger",
      "language": "C#",
      "category": [
        "$temp_category_experimental"
      ],
      "categoryStyle": "eventGrid",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "EventGridTrigger-JavaScript",
    "runtime": "1",
    "files": {
      "index.js": "module.exports = function (context, eventGridEvent) {\r\n    context.log(typeof eventGridEvent);\r\n    context.log(eventGridEvent);\r\n    context.done();\r\n};",
      "sample.dat": "{\n  'topic': '/subscriptions/5b4b650e-28b9-4790-b3ab-ddbd88d727c4/resourcegroups/test/providers/Microsoft.EventHub/namespaces/test',\n  'subject': 'eventhubs/test',\n  'eventType': 'captureFileCreated',\n  'eventTime': '2017-07-14T23:10:27.7689666Z',\n  'id': '7b11c4ce-1c34-4416-848b-1730e766f126',\n  'data': {\n    'fileUrl': 'https://test.blob.core.windows.net/debugging/testblob.txt',\n    'fileType': 'AzureBlockBlob',\n    'partitionId': '1',\n    'sizeInBytes': 0,\n    'eventCount': 0,\n    'firstSequenceNumber': -1,\n    'lastSequenceNumber': -1,\n    'firstEnqueueTime': '0001-01-01T00:00:00',\n    'lastEnqueueTime': '0001-01-01T00:00:00'\n  },\n  \"dataVersion\": \"\", \n  \"metadataVersion\": \"1\" \n}\n"
    },
    "function": {
      "bindings": [
        {
          "type": "eventGridTrigger",
          "name": "eventGridEvent",
          "direction": "in"
        }
      ],
      "disabled": false
    },
    "metadata": {
      "defaultFunctionName": "EventGridTriggerJS",
      "description": "$EventGridTrigger_description",
      "name": "Event Grid trigger",
      "language": "JavaScript",
      "category": [
        "$temp_category_experimental"
      ],
      "categoryStyle": "eventGrid",
      "enabledInTryMode": false,
      "userPrompt": []
    }
  },
  {
    "id": "EventHubTrigger-CSharp",
    "runtime": "1",
    "files": {
      "run.csx": "using System;\r\n\r\npublic static void Run(string myEventHubMessage, TraceWriter log)\r\n{\r\n    log.Info($\"C# Event Hub trigger function processed a message: {myEventHubMessage}\");\r\n}\r\n",
      "sample.dat": "Test Message"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "type": "eventHubTrigger",
          "name": "myEventHubMessage",
          "direction": "in",
          "path": "samples-workitems",
          "connection": "",
          "consumerGroup": "$Default"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "EventHubTriggerCSharp",
      "description": "$EventHubTrigger_description",
      "name": "Event Hub trigger",
      "language": "C#",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "eventHub",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "path",
        "consumerGroup"
      ]
    }
  },
  {
    "id": "EventHubTrigger-FSharp",
    "runtime": "1",
    "files": {
      "run.fsx": "open System\r\n\r\nlet Run(myEventHubMessage: string, log: TraceWriter) =\r\n    log.Info(sprintf \"F# Event Hub trigger function processed a message: %s\" myEventHubMessage)\r\n",
      "sample.dat": "Test Message"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "type": "eventHubTrigger",
          "name": "myEventHubMessage",
          "direction": "in",
          "path": "samples-workitems",
          "connection": "",
          "consumerGroup": "$Default"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "EventHubTriggerFSharp",
      "description": "$EventHubTrigger_description",
      "name": "Event Hub trigger",
      "language": "F#",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "eventHub",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "path",
        "consumerGroup"
      ]
    }
  },
  {
    "id": "EventHubTrigger-JavaScript",
    "runtime": "1",
    "files": {
      "index.js": "module.exports = function (context, eventHubMessages) {\r\n    context.log(`JavaScript eventhub trigger function called for message array: ${eventHubMessages}`);\r\n    \r\n    eventHubMessages.forEach(message => {\r\n        context.log(`Processed message: ${message}`);\r\n    });\r\n\r\n    context.done();\r\n};",
      "sample.dat": "Test Message"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "type": "eventHubTrigger",
          "name": "eventHubMessages",
          "direction": "in",
          "path": "samples-workitems",
          "connection": "",
          "cardinality": "many",
          "consumerGroup": "$Default"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "EventHubTriggerJS",
      "description": "$EventHubTrigger_description",
      "name": "Event Hub trigger",
      "language": "JavaScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "eventHub",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "path",
        "consumerGroup"
      ]
    }
  },
  {
    "id": "EventHubTrigger-TypeScript",
    "runtime": "1",
    "files": {
      "index.ts": "export function run(context: any, eventHubMessages: any[]): void {\r\n    context.log(`TypeScript eventhub trigger function called for message array ${eventHubMessages}`);\r\n\r\n    eventHubMessages.forEach(message => {\r\n        context.log(`Processed message ${message}`);\r\n    });\r\n\r\n    context.done();\r\n};",
      "sample.dat": "Test Message"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "type": "eventHubTrigger",
          "name": "eventHubMessages",
          "direction": "in",
          "path": "samples-workitems",
          "connection": "",
          "cardinality": "many",
          "consumerGroup": "$Default"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "EventHubTriggerTS",
      "description": "$EventHubTrigger_description",
      "name": "Event Hub trigger",
      "language": "TypeScript",
      "category": [
        "$temp_category_experimental"
      ],
      "categoryStyle": "eventHub",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "path",
        "consumerGroup"
      ]
    }
  },
  {
    "id": "ExternalFileTrigger-Batch",
    "runtime": "1",
    "files": {
      "run.bat": "@echo off\r\n\r\ncopy %inputFile% %outputFile%\r\n\r\necho Windows Batch script processed a file!",
      "sample.dat": "input-batch/{your file}\r\n\r\n"
    },
    "function": {
      "bindings": [
        {
          "type": "apiHubFileTrigger",
          "name": "inputFile",
          "direction": "in",
          "path": "input-batch/{name}",
          "connection": ""
        },
        {
          "type": "apiHubFile",
          "name": "outputFile",
          "direction": "out",
          "path": "output-batch/{name}",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ExternalFileTriggerBatch",
      "description": "$SaasFileTrigger_description",
      "name": "External file trigger",
      "language": "Batch",
      "category": [
        "$temp_category_experimental"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "path"
      ]
    }
  },
  {
    "id": "ExternalFileTrigger-CSharp",
    "runtime": "1",
    "files": {
      "run.csx": "using System;\r\n\r\npublic static string Run(string inputFile, string name, TraceWriter log)\r\n{\r\n    log.Info($\"C# External trigger function processed file: \" + name);\r\n    return inputFile;\r\n}",
      "sample.dat": "input-cs/{your file}\r\n\r\n"
    },
    "function": {
      "bindings": [
        {
          "type": "apiHubFileTrigger",
          "name": "inputFile",
          "direction": "in",
          "path": "input-cs/{name}",
          "connection": ""
        },
        {
          "type": "apiHubFile",
          "name": "$return",
          "direction": "out",
          "path": "output-cs/{name}",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ExternalFileTriggerCSharp",
      "description": "$SaasFileTrigger_description",
      "name": "External file trigger",
      "language": "C#",
      "category": [
        "$temp_category_experimental"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "path"
      ]
    }
  },
  {
    "id": "ExternalFileTrigger-FSharp",
    "runtime": "1",
    "files": {
      "run.fsx": "let Run(input: string, name: string, log: TraceWriter) =\r\n    log.Info(sprintf \"F# External trigger function processed file: %s\" name)\r\n    input\r\n",
      "sample.dat": "input-cs/{your file}\r\n\r\n"
    },
    "function": {
      "bindings": [
        {
          "type": "apiHubFileTrigger",
          "name": "input",
          "direction": "in",
          "path": "input-cs/{name}",
          "connection": ""
        },
        {
          "type": "apiHubFile",
          "name": "$return",
          "direction": "out",
          "path": "output-cs/{name}",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ExternalFileTriggerFSharp",
      "description": "$SaasFileTrigger_description",
      "name": "External file trigger",
      "language": "F#",
      "category": [
        "$temp_category_experimental"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "path"
      ]
    }
  },
  {
    "id": "ExternalFileTrigger-JavaScript",
    "runtime": "1",
    "files": {
      "index.js": "module.exports = function (context, inputFile) {\r\n    context.log('JavaScript External trigger function processed a file!');\r\n    context.done(null, {\r\n        outputFile: inputFile\r\n    });\r\n};\r\n",
      "sample.dat": "input-JavaScript/{your file}\r\n\r\n"
    },
    "function": {
      "bindings": [
        {
          "type": "apiHubFileTrigger",
          "name": "inputFile",
          "direction": "in",
          "path": "input-javascript/{name}",
          "connection": ""
        },
        {
          "type": "apiHubFile",
          "name": "outputFile",
          "direction": "out",
          "path": "output-javascript/{name}",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ExternalFileTriggerJS",
      "description": "$SaasFileTrigger_description",
      "name": "External file trigger",
      "language": "JavaScript",
      "category": [
        "$temp_category_experimental"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "path"
      ]
    }
  },
  {
    "id": "ExternalTable-CSharp",
    "runtime": "1",
    "files": {
      "run.csx": "#r \"Microsoft.Azure.ApiHub.Sdk\" \r\n\r\nusing System;\r\nusing System.Net;\r\nusing Microsoft.Azure.ApiHub;\r\n\r\npublic class Contact\r\n{\r\n    public string Id { get; set; }\r\n    public string LastName { get; set; }\r\n    public string FirstName { get; set; }\r\n}\r\n\r\n\r\npublic static async Task<HttpResponseMessage> Run(HttpRequestMessage req, ITable<Contact> inputTable, TraceWriter log)\r\n{\r\n    log.Info(\"C# HTTP trigger function processed a request.\");\r\n    ContinuationToken continuationToken = null;\r\n    \r\n    do\r\n    {\r\n        var segment = await inputTable.ListEntitiesAsync(continuationToken: continuationToken);\r\n        foreach (var item in segment.Items)\r\n        {\r\n            log.Info(item.FirstName + \" \" + item.LastName);\r\n        }\r\n        continuationToken = segment.ContinuationToken; ;\r\n    }\r\n    while (continuationToken != null);\r\n\r\n    return req.CreateResponse(HttpStatusCode.OK);\r\n}\r\n"
    },
    "function": {
      "bindings": [
        {
          "authLevel": "function",
          "name": "req",
          "type": "httpTrigger",
          "direction": "in"
        },
        {
          "name": "res",
          "type": "http",
          "direction": "out"
        },
        {
          "type": "apiHubTable",
          "name": "inputTable",
          "dataSetName": "default",
          "tableName": "Contact",
          "connection": "",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ExternalTableCSharp",
      "description": "$SaasTable_description",
      "name": "External table",
      "language": "C#",
      "category": [
        "$temp_category_experimental"
      ],
      "categoryStyle": "other",
      "userPrompt": [
        "connection",
        "tableName"
      ]
    }
  },
  {
    "id": "ExternalTable-FSharp",
    "runtime": "1",
    "files": {
      "project.json": "{\r\n  \"frameworks\": {\r\n    \"net46\":{\r\n      \"dependencies\": {\r\n        \"Microsoft.Azure.ApiHub.Sdk\": \"0.6.2\"\r\n      }\r\n    }\r\n  }\r\n}\r\n",
      "run.fsx": "#r \"System.Net.Http\"\r\n#r \"Microsoft.Azure.ApiHub.Sdk\" \r\n\r\nopen System.Net\r\nopen System.Net.Http\r\nopen Microsoft.Azure.ApiHub\r\n\r\ntype Contact() =\r\n    member val Id: string = null with get, set\r\n    member val FirstName: string = null with get, set\r\n    member val LastName: string = null with get, set\r\n\r\nlet Run(req: HttpRequestMessage, input: ITable<Contact>, log: TraceWriter) =\r\n    async {\r\n        log.Info(sprintf \r\n            \"F# HTTP trigger function processed a request.\")\r\n\r\n        let rec q (cont: ContinuationToken) = async {\r\n            let! segment =\r\n                input.ListEntitiesAsync(continuationToken = cont)\r\n                |> Async.AwaitTask\r\n            \r\n            for item in segment.Items do\r\n                log.Info(sprintf \"%s %s\" item.FirstName item.LastName)\r\n\r\n            match segment.ContinuationToken with\r\n            | null -> return ()\r\n            | token -> q token |> Async.RunSynchronously\r\n        }\r\n\r\n        q null |> Async.RunSynchronously\r\n        return req.CreateResponse(HttpStatusCode.OK)\r\n    } |> Async.StartAsTask\r\n"
    },
    "function": {
      "bindings": [
        {
          "authLevel": "function",
          "name": "req",
          "type": "httpTrigger",
          "direction": "in"
        },
        {
          "name": "res",
          "type": "http",
          "direction": "out"
        },
        {
          "type": "apiHubTable",
          "name": "input",
          "dataSetName": "default",
          "tableName": "Contact",
          "connection": "",
          "direction": "in"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ExternalTableFSharp",
      "description": "$SaasTable_description",
      "name": "External table",
      "language": "F#",
      "category": [
        "$temp_category_experimental"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "tableName"
      ]
    }
  },
  {
    "id": "FaceLocator-CSharp",
    "runtime": "1",
    "files": {
      "run.csx": "// Setup\r\n// 1) Go to https://www.microsoft.com/cognitive-services/en-us/computer-vision-api \r\n//    Sign up for computer vision api\r\n// 2) Go to Platform features -> Application settings\r\n//    create a new app setting Vision_API_Subscription_Key and use Computer vision key as value\r\n\r\n#r \"Microsoft.WindowsAzure.Storage\"\r\n#r \"Newtonsoft.Json\"\r\n\r\nusing System.IO;\r\nusing System.Net;\r\nusing System.Net.Http;\r\nusing System.Net.Http.Headers;\r\nusing Newtonsoft.Json;\r\nusing Microsoft.WindowsAzure.Storage.Table;\r\n\r\npublic static async Task Run(Stream image, string name, IAsyncCollector<FaceRectangle> outTable, TraceWriter log)\r\n{\r\n    string result = await CallVisionAPI(image);\r\n    log.Info(result);\r\n\r\n    if (String.IsNullOrEmpty(result))\r\n    {\r\n        return;\r\n    }\r\n\r\n    ImageData imageData = JsonConvert.DeserializeObject<ImageData>(result);\r\n    foreach (Face face in imageData.Faces)\r\n    {\r\n        var faceRectangle = face.FaceRectangle;\r\n        faceRectangle.RowKey = Guid.NewGuid().ToString();\r\n        faceRectangle.PartitionKey = \"Functions\";\r\n        faceRectangle.ImageFile = name + \".jpg\";\r\n        await outTable.AddAsync(faceRectangle);\r\n    }\r\n}\r\n\r\nstatic async Task<string> CallVisionAPI(Stream image)\r\n{\r\n    using (var client = new HttpClient())\r\n    {\r\n        var content = new StreamContent(image);\r\n        var url = \"https://westus.api.cognitive.microsoft.com/vision/v1.0/analyze?visualFeatures=Faces&language=en\";\r\n        client.DefaultRequestHeaders.Add(\"Ocp-Apim-Subscription-Key\", Environment.GetEnvironmentVariable(\"Vision_API_Subscription_Key\"));\r\n        content.Headers.ContentType = new MediaTypeHeaderValue(\"application/octet-stream\");\r\n        var httpResponse = await client.PostAsync(url, content);\r\n\r\n        if (httpResponse.StatusCode == HttpStatusCode.OK)\r\n        {\r\n            return await httpResponse.Content.ReadAsStringAsync();\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\npublic class ImageData\r\n{\r\n    public List<Face> Faces { get; set; }\r\n}\r\n\r\npublic class Face\r\n{\r\n    public int Age { get; set; }\r\n\r\n    public string Gender { get; set; }\r\n\r\n    public FaceRectangle FaceRectangle { get; set; }\r\n}\r\n\r\npublic class FaceRectangle : TableEntity\r\n{\r\n    public string ImageFile { get; set; }\r\n\r\n    public int Left { get; set; }\r\n\r\n    public int Top { get; set; }\r\n\r\n    public int Width { get; set; }\r\n\r\n    public int Height { get; set; }\r\n}\r\n",
      "sample.dat": "images/image.jpg"
    },
    "function": {
      "bindings": [
        {
          "type": "blobTrigger",
          "name": "image",
          "path": "images/{name}.jpg",
          "connection": "",
          "direction": "in"
        },
        {
          "type": "table",
          "name": "outTable",
          "tableName": "faceRectangle",
          "connection": "",
          "direction": "out"
        }
      ],
      "disabled": false
    },
    "metadata": {
      "defaultFunctionName": "FaceLocatorCSharp",
      "description": "$FaceLocator_description",
      "name": "Face locator",
      "language": "C#",
      "trigger": "HttpTrigger",
      "category": [
        "$temp_category_samples"
      ],
      "categoryStyle": "blob",
      "enabledInTryMode": true,
      "userPrompt": [
        "path",
        "connection",
        "tableName"
      ]
    }
  },
  {
    "id": "FaceLocator-FSharp",
    "runtime": "1",
    "files": {
      "run.fsx": "// Setup\r\n// 1) Go to https://www.microsoft.com/cognitive-services/en-us/computer-vision-api \r\n//    Sign up for computer vision api\r\n// 2) Go to Platform features -> Application settings\r\n//    create a new app setting Vision_API_Subscription_Key and use Computer vision key as value\r\n\r\n#r \"Microsoft.WindowsAzure.Storage\"\r\n#r \"Newtonsoft.Json\"\r\n#r \"System.Net.Http\"\r\n\r\nopen System\r\nopen System.Net\r\nopen System.Net.Http\r\nopen System.Net.Http.Headers\r\nopen System.IO\r\nopen Newtonsoft.Json\r\nopen Microsoft.WindowsAzure.Storage.Table\r\n\r\ntype FaceRectangle() =\r\n    inherit TableEntity()\r\n    member val ImageFile: string = null with get, set\r\n    member val Left: int = 0 with get, set\r\n    member val Top: int = 0 with get, set\r\n    member val Width: int = 0 with get, set\r\n    member val Height: int = 0 with get, set\r\n\r\ntype Face = {\r\n    Age: int\r\n    Gender: string\r\n    FaceRectangle: FaceRectangle\r\n}\r\n\r\ntype ImageData = {\r\n    Faces: Face list\r\n}\r\n\r\nlet callVisionAPI (image: Stream) = async {\r\n    use client = new HttpClient()\r\n    use content = new StreamContent(image)\r\n    let url = \"https://westus.api.cognitive.microsoft.com/vision/v1.0/analyze?visualFeatures=Faces&language=en\"\r\n\r\n    client.DefaultRequestHeaders.Add(\r\n        \"Ocp-Apim-Subscription-Key\",\r\n        Environment.GetEnvironmentVariable(\"Vision_API_Subscription_Key\"))\r\n    content.Headers.ContentType <-\r\n        new MediaTypeHeaderValue(\"application/octet-stream\");\r\n\r\n    let! httpResponse = client.PostAsync(url, content) |> Async.AwaitTask\r\n\r\n    if httpResponse.StatusCode = HttpStatusCode.OK then\r\n        return! httpResponse.Content.ReadAsStringAsync() |> Async.AwaitTask\r\n    else\r\n        return null\r\n}\r\n\r\nlet Run(image: Stream, name: string, outTable: IAsyncCollector<FaceRectangle>, log: TraceWriter) =\r\n    let result = callVisionAPI(image) |> Async.RunSynchronously\r\n    log.Info(result)\r\n\r\n    if not (String.IsNullOrEmpty(result)) then\r\n        let imageData = JsonConvert.DeserializeObject<ImageData>(result)\r\n        for face in imageData.Faces do\r\n            let faceRectangle = face.FaceRectangle\r\n            faceRectangle.RowKey <- Guid.NewGuid().ToString()\r\n            faceRectangle.PartitionKey <- \"Functions\"\r\n            faceRectangle.ImageFile <- name + \".jpg\"\r\n            outTable.AddAsync(faceRectangle)\r\n            |> Async.AwaitTask\r\n            |> Async.RunSynchronously\r\n",
      "sample.dat": "images/image.jpg"
    },
    "function": {
      "bindings": [
        {
          "type": "blobTrigger",
          "name": "image",
          "path": "images/{name}.jpg",
          "connection": "",
          "direction": "in"
        },
        {
          "type": "table",
          "name": "outTable",
          "tableName": "faceRectangle",
          "connection": "",
          "direction": "out"
        }
      ],
      "disabled": false
    },
    "metadata": {
      "defaultFunctionName": "FaceLocatorFSharp",
      "description": "$FaceLocator_description",
      "name": "Face locator",
      "language": "F#",
      "trigger": "HttpTrigger",
      "category": [
        "$temp_category_samples"
      ],
      "categoryStyle": "blob",
      "enabledInTryMode": true,
      "userPrompt": [
        "path",
        "connection",
        "tableName"
      ]
    }
  },
  {
    "id": "FaceLocator-JavaScript",
    "runtime": "1",
    "files": {
      "index.js": "// Setup\r\n// 1) Go to https://www.microsoft.com/cognitive-services/en-us/computer-vision-api \r\n//    Sign up for computer vision api\r\n// 2) Go to Platform features -> Application settings\r\n//    create a new app setting Vision_API_Subscription_Key and use Computer vision key as value\r\n// 3) Go to Platform features -> Console\r\n//    Enter the following commands: \r\n//    > cd <functionName>\r\n//    > npm install\r\n\r\nvar request = require('request-promise');\r\nvar guid = require('node-uuid');\r\n\r\nmodule.exports = function (context, image) {\r\n\r\n    context.log(\"Image Size:\", image.length);\r\n    var options = {\r\n        uri: \"https://westus.api.cognitive.microsoft.com/vision/v1.0/analyze?visualFeatures=Faces&language=en\",\r\n        method: 'POST',\r\n        body: image,\r\n        headers: {\r\n            'Content-Type': 'application/octet-stream',\r\n            'Ocp-Apim-Subscription-Key': process.env.Vision_API_Subscription_Key\r\n        }\r\n    };\r\n\r\n    request(options)\r\n        .then((response) => {\r\n            response = JSON.parse(response);\r\n\r\n            if (!response || !response.faces.length) {\r\n                return context.done();\r\n            }\r\n\r\n            context.log(\"From Vision Api:\", response);\r\n\r\n            context.bindings.outTable = response.faces.map((face) => {\r\n                var faceMapping = {\r\n                    rowKey: guid.v1(),\r\n                    imageFile: context.bindingData.name + \".jpg\",\r\n                    partitionKey: \"Functions\"\r\n                };\r\n                Object.assign(faceMapping, face.faceRectangle);\r\n                return faceMapping;\r\n            });\r\n        })\r\n        .catch((error) => context.log(error))\r\n        .finally(() => context.done());\r\n};",
      "package.json": "{\r\n  \"name\": \"FaceLocator-JavaScript\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"\",\r\n  \"main\": \"index.js\",\r\n  \"scripts\": {\r\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\r\n  },\r\n  \"keywords\": [],\r\n  \"author\": \"\",\r\n  \"license\": \"ISC\",\r\n  \"dependencies\": {\r\n    \"node-uuid\": \"^1.4.7\",\r\n    \"request-promise\": \"^3.0.0\"\r\n  }\r\n}\r\n",
      "sample.dat": "images/image.jpg"
    },
    "function": {
      "bindings": [
        {
          "type": "blobTrigger",
          "name": "image",
          "path": "images/{name}.jpg",
          "dataType": "binary",
          "connection": "",
          "direction": "in"
        },
        {
          "type": "table",
          "name": "outTable",
          "tableName": "faceRectangle",
          "connection": "",
          "direction": "out"
        }
      ],
      "disabled": false
    },
    "metadata": {
      "defaultFunctionName": "FaceLocatorJS",
      "description": "$FaceLocator_description",
      "name": "Face locator",
      "language": "JavaScript",
      "trigger": "HttpTrigger",
      "category": [
        "$temp_category_samples"
      ],
      "categoryStyle": "blob",
      "enabledInTryMode": true,
      "userPrompt": [
        "path",
        "connection",
        "tableName"
      ]
    }
  },
  {
    "id": "GenericWebHook-CSharp",
    "runtime": "1",
    "files": {
      "run.csx": "#r \"Newtonsoft.Json\"\r\n\r\nusing System;\r\nusing System.Net;\r\nusing Newtonsoft.Json;\r\n\r\npublic static async Task<object> Run(HttpRequestMessage req, TraceWriter log)\r\n{\r\n    log.Info($\"Webhook was triggered!\");\r\n\r\n    string jsonContent = await req.Content.ReadAsStringAsync();\r\n    dynamic data = JsonConvert.DeserializeObject(jsonContent);\r\n\r\n    if (data.first == null || data.last == null)\r\n    {\r\n        return req.CreateResponse(HttpStatusCode.BadRequest, new\r\n        {\r\n            error = \"Please pass first/last properties in the input object\"\r\n        });\r\n    }\r\n\r\n    return req.CreateResponse(HttpStatusCode.OK, new\r\n    {\r\n        greeting = $\"Hello {data.first} {data.last}!\"\r\n    });\r\n}\r\n",
      "sample.dat": "{\r\n    \"first\": \"Azure\",\r\n    \"last\": \"Functions\"\r\n}\r\n"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "type": "httpTrigger",
          "direction": "in",
          "webHookType": "genericJson",
          "name": "req"
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "GenericWebhookCSharp",
      "description": "$GenericWebhook_description",
      "name": "Generic webhook",
      "language": "C#",
      "enabledInTryMode": true,
      "category": [
        "$temp_category_core",
        "$temp_category_api"
      ],
      "categoryStyle": "webhook"
    }
  },
  {
    "id": "GenericWebHook-FSharp",
    "runtime": "1",
    "files": {
      "run.fsx": "#r \"System.Net.Http\"\r\n#r \"Newtonsoft.Json\"\r\n\r\nopen System.Net\r\nopen System.Net.Http\r\nopen Newtonsoft.Json\r\n\r\ntype Name = {\r\n    First: string\r\n    Last: string\r\n}\r\n\r\ntype Greeting = {\r\n    Greeting: string\r\n}\r\n\r\nlet Run(req: HttpRequestMessage, log: TraceWriter) =\r\n    async {\r\n        log.Info(\"Webhook was triggered!\")\r\n        let! jsonContent = req.Content.ReadAsStringAsync() |> Async.AwaitTask\r\n\r\n        try\r\n            let name = JsonConvert.DeserializeObject<Name>(jsonContent)\r\n            return req.CreateResponse(HttpStatusCode.OK, \r\n                { Greeting = sprintf \"Hello %s %s!\" name.First name.Last })\r\n        with _ ->\r\n            return req.CreateResponse(HttpStatusCode.BadRequest)\r\n    } |> Async.StartAsTask\r\n",
      "sample.dat": "{\r\n    \"first\": \"Azure\",\r\n    \"last\": \"Functions\"\r\n}\r\n"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "type": "httpTrigger",
          "direction": "in",
          "webHookType": "genericJson",
          "name": "req"
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "GenericWebhookFSharp",
      "description": "$GenericWebhook_description",
      "name": "Generic webhook",
      "language": "F#",
      "enabledInTryMode": true,
      "category": [
        "$temp_category_core",
        "$temp_category_api"
      ],
      "categoryStyle": "webhook"
    }
  },
  {
    "id": "GenericWebHook-JavaScript",
    "runtime": "1",
    "files": {
      "index.js": "module.exports = function (context, data) {\r\n    context.log('Webhook was triggered!');\r\n\r\n    // Check if we got first/last properties\r\n    if('first' in data && 'last' in data) {\r\n        context.res = {\r\n            body: { greeting: 'Hello ' + data.first + ' ' + data.last + '!'}\r\n        };\r\n    }\r\n    else {\r\n        context.res = {\r\n            status: 400,\r\n            body: { error: 'Please pass first/last properties in the input object'}\r\n        };\r\n    }\r\n\r\n    context.done();\r\n}\r\n",
      "sample.dat": "{\r\n    \"first\": \"Azure\",\r\n    \"last\": \"Functions\"\r\n}\r\n"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "type": "httpTrigger",
          "direction": "in",
          "webHookType": "genericJson",
          "name": "req"
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "GenericWebhookJS",
      "description": "$GenericWebhook_description",
      "name": "Generic webhook",
      "language": "JavaScript",
      "enabledInTryMode": true,
      "category": [
        "$temp_category_core",
        "$temp_category_api"
      ],
      "categoryStyle": "webhook"
    }
  },
  {
    "id": "GenericWebHook-TypeScript",
    "runtime": "1",
    "files": {
      "index.ts": "export function run(context: any, data: IData): void {\r\n    context.log(\"Webhook was triggered!\");\r\n\r\n    // check if we got first/last properties\r\n    if (\"first\" in data && \"last\" in data) {\r\n        context.res = {\r\n            body: { greeting: `Hello ${data.first} ${data.last}!` }\r\n        };\r\n    } else {\r\n        context.res = {\r\n            status: 400,\r\n            body: { error: \"Please pass first/last properties in the input object\" }\r\n        };\r\n    }\r\n\r\n    context.done();\r\n}\r\n\r\ninterface IData {\r\n    first: string;\r\n    last: string;\r\n}\r\n\r\n",
      "sample.dat": "{\r\n    \"first\": \"Azure\",\r\n    \"last\": \"Functions\"\r\n}\r\n"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "type": "httpTrigger",
          "direction": "in",
          "webHookType": "genericJson",
          "name": "req"
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "GenericWebhookTS",
      "description": "$GenericWebhookNode_description",
      "name": "Generic webhook",
      "language": "TypeScript",
      "enabledInTryMode": true,
      "category": [
        "$temp_category_experimental"
      ],
      "categoryStyle": "webhook"
    }
  },
  {
    "id": "GitHubCommenter-CSharp",
    "runtime": "1",
    "files": {
      "run.csx": "// Please follow the link https://developer.github.com/v3/oauth/ to get information on GitHub authentication\r\n\r\nusing System.Net;\r\nusing System.Net.Http;\r\nusing System.Net.Http.Headers;\r\nusing System.Text;\r\n\r\npublic static async Task Run(dynamic payload, TraceWriter log)\r\n{\r\n    if (payload.action != \"opened\")\r\n    {\r\n        return;\r\n    }\r\n\r\n    string comment = \"{ \\\"body\\\": \\\"Thank you for your contribution, We will get to it shortly\\\" }\";\r\n    string label = \"[ \\\"bug\\\" ]\";\r\n\r\n    if (payload.issue != null)\r\n    {\r\n        log.Info($\"{payload.issue.user.login} posted an issue #{payload.issue.number}:{payload.issue.title}\");\r\n\r\n        //Post a comment \r\n        await SendGitHubRequest(payload.issue.comments_url.ToString(), comment);\r\n\r\n        //Add a label\r\n        await SendGitHubRequest($\"{payload.issue.url.ToString()}/labels\", label);\r\n    }\r\n\r\n    if (payload.pull_request != null)\r\n    {\r\n        log.Info($\"{payload.pull_request.user.login} submitted pull request #{payload.pull_request.number}:{payload.pull_request.title}\");\r\n\r\n        // posting a comment\r\n        await SendGitHubRequest(payload.pull_request.comments_url.ToString(), comment);\r\n    }\r\n}\r\n\r\npublic static async Task SendGitHubRequest(string url, string requestBody)\r\n{\r\n    using (var client = new HttpClient())\r\n    {\r\n        client.DefaultRequestHeaders.UserAgent.Add(new ProductInfoHeaderValue(\"username\", \"version\"));\r\n\r\n        // Add the GITHUB_CREDENTIALS as an app setting, Value is the \"PersonalAccessToken\"\r\n        // Please follow the link https://developer.github.com/v3/oauth/ to get more information on GitHub authentication \r\n        client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\"token\", Environment.GetEnvironmentVariable(\"GITHUB_CREDENTIALS\"));\r\n        var content = new StringContent(requestBody, Encoding.UTF8, \"application/json\");\r\n        await client.PostAsync(url, content);\r\n    }\r\n}\r\n",
      "sample.dat": "{\r\n  \"action\": \"opened\",\r\n  \"issue\": {\r\n    \"url\": \"https://api.github.com/repos/<USER>/<REPOSITORY>/issues/<ISSUE_NUMBER>\",\r\n    \"comments_url\": \"https://api.github.com/repos/<USER>/<REPOSITORY>/issues/<ISSUE_NUMBER>/comments\",    \r\n    \"title\": \"issue title\",\r\n    \"user\": {\r\n      \"login\": \"<USER>\"\r\n    },    \r\n    \"body\": \"issue description\"\r\n  }  \r\n}"
    },
    "function": {
      "bindings": [
        {
          "type": "httpTrigger",
          "direction": "in",
          "webHookType": "github",
          "name": "payload"
        }
      ],
      "disabled": false
    },
    "metadata": {
      "defaultFunctionName": "GitHubCommenterCSharp",
      "description": "$GitHubCommenter_description",
      "name": "GitHub commenter",
      "language": "C#",
      "enabledInTryMode": true,
      "category": [
        "$temp_category_samples"
      ],
      "categoryStyle": "webhook"
    }
  },
  {
    "id": "GitHubCommenter-FSharp",
    "runtime": "1",
    "files": {
      "run.fsx": "// Please follow the link https://developer.github.com/v3/oauth/ to get information on GitHub authentication\r\n\r\n#r \"System.Net.Http\"\r\n#r \"Newtonsoft.Json\"\r\n\r\nopen System\r\nopen System.Net\r\nopen System.Net.Http\r\nopen System.Net.Http.Headers\r\nopen System.Text\r\nopen Newtonsoft.Json\r\nopen Newtonsoft.Json.Linq\r\n\r\nlet SendGitHubRequest (url: string) requestBody =\r\n    async {\r\n        use client = new HttpClient()\r\n\r\n        client.DefaultRequestHeaders.UserAgent.Add(\r\n            ProductInfoHeaderValue(\"username\", \"version\"))\r\n\r\n        // Add the GITHUB_CREDENTIALS as an app setting, Value for the app setting is a base64 encoded string in the following format\r\n        // \"Username:Password\" or \"Username:PersonalAccessToken\"\r\n        // Please follow the link https://developer.github.com/v3/oauth/ to get more information on GitHub authentication \r\n        client.DefaultRequestHeaders.Authorization <-\r\n            AuthenticationHeaderValue(\"Basic\",\r\n                Environment.GetEnvironmentVariable(\"GITHUB_CREDENTIALS\"))\r\n        use content =\r\n            new StringContent(requestBody, Encoding.UTF8, \"application/json\")\r\n        return! client.PostAsync(url, content) |> Async.AwaitTask\r\n    } |> Async.RunSynchronously\r\n\r\nlet rec hasProp (key: string list) (from: JObject) =\r\n    match from with\r\n    | null -> false\r\n    | _ ->\r\n        let x = from.[key.Head]\r\n        match x with\r\n        | null -> false\r\n        | _ ->\r\n            match key with\r\n            | [_] -> true\r\n            | _::tl -> hasProp tl (x.Value<JObject>())\r\n            | [] -> false\r\n\r\nlet rec prop<'T> (key: string list) (def: 'T) (from: JObject) =\r\n    match from with\r\n    | null -> def\r\n    | _ ->\r\n        let x = from.[key.Head]\r\n        match x with\r\n        | null -> def\r\n        | _ ->\r\n            match key with\r\n            | [_] -> x.Value<'T>()\r\n            | _::tl ->\r\n                prop<'T> tl def (x.Value<JObject>())\r\n            | [] -> def\r\n\r\nlet Run(payload: string, log: TraceWriter) =\r\n    let comment = \"{ \\\"body\\\": \\\"Thank you for your contribution, We will get to it shortly\\\" }\";\r\n    let label = \"[ \\\"bug\\\" ]\";\r\n\r\n    let json = JObject.Parse(payload)\r\n    if json |> prop [\"action\"] \"none\" = \"opened\" then\r\n        if hasProp [\"issue\"] json then\r\n            log.Info(\r\n                sprintf \"%s posted an issue #%d: %s\"\r\n                    (prop [\"issue\"; \"user\"; \"login\"] \"unknown user\" json)\r\n                    (prop [\"issue\"; \"number\"] 0 json)\r\n                    (prop [\"issue\"; \"title\"] \"unknown title\" json)\r\n                    )\r\n            SendGitHubRequest (prop [\"issue\"; \"comments_url\"] \"\" json) comment\r\n                |> ignore\r\n            SendGitHubRequest\r\n                (sprintf \"%s/labels\" (prop [\"issue\"; \"url\"] \"\" json)) label\r\n                |> ignore\r\n\r\n        if hasProp [\"pull_request\"] json then\r\n            log.Info(\r\n                sprintf \"%s submitted pull request #%d: %s\"\r\n                    (prop [\"pull_request\"; \"user\"; \"login\"] \"unknown user\" json)\r\n                    (prop [\"pull_request\"; \"number\"] 0 json)\r\n                    (prop [\"pull_request\"; \"title\"] \"unknown title\" json)\r\n                    )\r\n            SendGitHubRequest\r\n                (prop [\"pull_request\"; \"comments_url\"] \"\" json) comment\r\n                |> ignore\r\n",
      "sample.dat": "{\r\n  \"action\": \"opened\",\r\n  \"issue\": {\r\n    \"url\": \"https://api.github.com/repos/<USER>/<REPOSITORY>/issues/<ISSUE_NUMBER>\",\r\n    \"comments_url\": \"https://api.github.com/repos/<USER>/<REPOSITORY>/issues/<ISSUE_NUMBER>/comments\",    \r\n    \"title\": \"issue title\",\r\n    \"user\": {\r\n      \"login\": \"<USER>\"\r\n    },    \r\n    \"body\": \"issue description\"\r\n  }  \r\n}"
    },
    "function": {
      "bindings": [
        {
          "type": "httpTrigger",
          "direction": "in",
          "webHookType": "github",
          "name": "payload"
        }
      ],
      "disabled": false
    },
    "metadata": {
      "defaultFunctionName": "GitHubCommenterFSharp",
      "description": "$GitHubCommenter_description",
      "name": "GitHub commenter",
      "language": "F#",
      "enabledInTryMode": true,
      "category": [
        "$temp_category_samples"
      ],
      "categoryStyle": "webhook"
    }
  },
  {
    "id": "GitHubCommenter-JavaScript",
    "runtime": "1",
    "files": {
      "index.js": "// Setup\r\n// 1) Go to Function app settings -> App Service settings -> Tools -> Console\r\n//    Enter the following commands: \r\n//    > cd <functionName>\r\n//    > npm install\r\n// 2) Add the GITHUB_CREDENTIALS as an app setting, Value for the app setting is a base64 encoded string in the following format\r\n//    \"Username:Password\" or \"Username:PersonalAccessToken\"\r\n//     Please follow the link https://developer.github.com/v3/oauth/ to get more information on GitHub authentication\r\nmodule.exports = function (context, payload) {\r\n    if (payload.action != \"opened\") {\r\n        context.done();\r\n        return;\r\n    }\r\n\r\n    var comment = { \"body\": \"Thank you for your contribution, We will get to it shortly\" };\r\n    var label = [\"bug\"];\r\n\r\n    if (payload.issue) {\r\n        context.log(payload.issue.user.login, \":posted issue #\", payload.issue.number, \":\", payload.issue.title);\r\n\r\n        //Post a comment \r\n        SendGitHubRequest(payload.issue.comments_url, comment, context);\r\n\r\n        //Add a label\r\n        SendGitHubRequest(payload.issue.url + \"/labels\", label, context);\r\n    }\r\n\r\n    if (payload.pull_request) {\r\n        context.log(payload.pull_request.user.login, \":submitted pull request #\", payload.pull_request.number, \":\", payload.pull_request.title);\r\n\r\n        // posting a comment\r\n        SendGitHubRequest(payload.pull_request.comments_url, comment, context);\r\n    }\r\n\r\n    context.done();\r\n};\r\n\r\nfunction SendGitHubRequest(url, requestBody, context) {\r\n\r\n    var request = require('request');\r\n    var githubCred = 'Basic ' + process.env.GITHUB_CREDENTIALS;\r\n    request({\r\n        url: url,\r\n        method: 'POST',\r\n        headers: {\r\n            'User-Agent': '<username>',\r\n            'Authorization': githubCred\r\n        },\r\n        json: requestBody\r\n    }, function (error, response, body) {\r\n        if (error) {\r\n            context.log(error);\r\n        } else {\r\n            context.log(response.statusCode, body);\r\n        }\r\n    });\r\n}",
      "package.json": "{\r\n  \"name\": \"GitHubCommenter-JavaScript\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"\",\r\n  \"main\": \"index.js\",\r\n  \"scripts\": {\r\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\r\n  },\r\n  \"keywords\": [],\r\n  \"author\": \"\",\r\n  \"license\": \"ISC\",\r\n  \"dependencies\": {\r\n    \"request\": \"^2.72.0\"\r\n  }\r\n}\r\n",
      "sample.dat": "{\r\n  \"action\": \"opened\",\r\n  \"issue\": {\r\n    \"url\": \"https://api.github.com/repos/<USER>/<REPOSITORY>/issues/<ISSUE_NUMBER>\",\r\n    \"comments_url\": \"https://api.github.com/repos/<USER>/<REPOSITORY>/issues/<ISSUE_NUMBER>/comments\",    \r\n    \"title\": \"issue title\",\r\n    \"user\": {\r\n      \"login\": \"<USER>\"\r\n    },    \r\n    \"body\": \"issue description\"\r\n  }  \r\n}"
    },
    "function": {
      "bindings": [
        {
          "type": "httpTrigger",
          "direction": "in",
          "webHookType": "github",
          "name": "payload"
        }
      ],
      "disabled": false
    },
    "metadata": {
      "defaultFunctionName": "GitHubCommenterJS",
      "description": "$GitHubCommenter_description",
      "name": "GitHub commenter",
      "language": "JavaScript",
      "enabledInTryMode": true,
      "category": [
        "$temp_category_samples"
      ],
      "categoryStyle": "webhook"
    }
  },
  {
    "id": "GitHubWebHook-CSharp",
    "runtime": "1",
    "files": {
      "run.csx": "using System.Net;\r\n\r\npublic static async Task<HttpResponseMessage> Run(HttpRequestMessage req, TraceWriter log)\r\n{\r\n    log.Info(\"C# HTTP trigger function processed a request.\");\r\n\r\n    // Get request body\r\n    dynamic data = await req.Content.ReadAsAsync<object>();\r\n\r\n    // Extract github comment from request body\r\n    string gitHubComment = data?.comment?.body;\r\n\r\n    return req.CreateResponse(HttpStatusCode.OK, \"From Github:\" + gitHubComment);\r\n}\r\n",
      "sample.dat": "{\r\n    \"comment\": {\r\n        \"body\": \"This is a comment on a GitHub issue\"\r\n    }\r\n}\r\n"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "type": "httpTrigger",
          "direction": "in",
          "webHookType": "github",
          "name": "req"
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "GithubWebhookCSharp",
      "description": "$GithubWebhook_description",
      "name": "GitHub webhook",
      "language": "C#",
      "enabledInTryMode": true,
      "category": [
        "$temp_category_core",
        "$temp_category_api"
      ],
      "categoryStyle": "webhook"
    }
  },
  {
    "id": "GitHubWebHook-FSharp",
    "runtime": "1",
    "files": {
      "run.fsx": "#r \"System.Net.Http\"\r\n#r \"Newtonsoft.Json\"\r\n\r\nopen System.Net\r\nopen System.Net.Http\r\nopen Newtonsoft.Json\r\n\r\ntype Body = {\r\n    body: string\r\n}\r\n\r\ntype Comment = {\r\n    comment: Body\r\n}\r\n\r\nlet Run(req: HttpRequestMessage, log: TraceWriter) =\r\n    async {\r\n        log.Info(sprintf \"F# HTTP trigger function processed a request.\")\r\n\r\n        let! body = req.Content.ReadAsStringAsync() |> Async.AwaitTask\r\n        let data = JsonConvert.DeserializeObject<Comment>(body)\r\n        let comment = data.comment.body\r\n\r\n        if comment = null then\r\n            return req.CreateResponse(HttpStatusCode.BadRequest, \"No comment data\")\r\n        else\r\n            return req.CreateResponse(HttpStatusCode.OK, \"From Github: \" + comment)\r\n    } |> Async.StartAsTask\r\n",
      "sample.dat": "{\r\n    \"comment\": {\r\n        \"body\": \"This is a comment on a GitHub issue\"\r\n    }\r\n}\r\n"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "type": "httpTrigger",
          "direction": "in",
          "webHookType": "github",
          "name": "req"
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "GithubWebhookFSharp",
      "description": "$GithubWebhook_description",
      "name": "GitHub webhook",
      "language": "F#",
      "enabledInTryMode": true,
      "category": [
        "$temp_category_core",
        "$temp_category_api"
      ],
      "categoryStyle": "webhook"
    }
  },
  {
    "id": "GitHubWebHook-JavaScript",
    "runtime": "1",
    "files": {
      "index.js": "// Please visit http://go.microsoft.com/fwlink/?LinkID=761099&clcid=0x409 for more information on settting up Github Webhooks\r\nmodule.exports = function (context, data) {\r\n    context.log('GitHub Webhook triggered!', data.comment.body);\r\n    context.res = { body: 'New GitHub comment: ' + data.comment.body };\r\n    context.done();\r\n};",
      "sample.dat": "{\r\n    \"comment\": {\r\n        \"body\": \"This is a comment on a GitHub issue\"\r\n    }\r\n}\r\n"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "type": "httpTrigger",
          "direction": "in",
          "webHookType": "github",
          "name": "req"
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "GithubWebhookJS",
      "description": "$GithubWebhook_description",
      "name": "GitHub webhook",
      "language": "JavaScript",
      "enabledInTryMode": true,
      "category": [
        "$temp_category_core",
        "$temp_category_api"
      ],
      "categoryStyle": "webhook"
    }
  },
  {
    "id": "GitHubWebHook-TypeScript",
    "runtime": "1",
    "files": {
      "index.ts": "/*\r\n Please visit http://go.microsoft.com/fwlink/?LinkID=761099&clcid=0x409\r\n     for more information on settting up Github Webhooks\r\n*/\r\nexport function run(context: any, data: any): any {\r\n    context.log(\"GitHub Webhook triggered!\", data.comment.body);\r\n    context.res = { body: `New GitHub comment: ${data.comment.body}` };\r\n    context.done();\r\n};",
      "sample.dat": "{\r\n    \"comment\": {\r\n        \"body\": \"This is a comment on a GitHub issue\"\r\n    }\r\n}\r\n"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "type": "httpTrigger",
          "direction": "in",
          "webHookType": "github",
          "name": "req"
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "GithubWebhookTS",
      "description": "$GithubWebhook_description",
      "name": "GitHub webhook",
      "language": "TypeScript",
      "enabledInTryMode": true,
      "category": [
        "$temp_category_experimental"
      ],
      "categoryStyle": "webhook"
    }
  },
  {
    "id": "HttpGET(CRUD)-CSharp",
    "runtime": "1",
    "files": {
      "run.csx": "#r \"Microsoft.WindowsAzure.Storage\"\r\n\r\nusing System.Net;\r\nusing Microsoft.WindowsAzure.Storage.Table;\r\n\r\npublic static HttpResponseMessage Run(HttpRequestMessage req, IQueryable<Person> inTable, TraceWriter log)\r\n{\r\n    var query = from person in inTable select person;\r\n    foreach (Person person in query)\r\n    {\r\n        log.Info($\"Name:{person.Name}\");\r\n    }\r\n    return req.CreateResponse(HttpStatusCode.OK, inTable.ToList());\r\n}\r\n\r\npublic class Person : TableEntity\r\n{\r\n    public string Name { get; set; }\r\n}\r\n",
      "sample.dat": ""
    },
    "function": {
      "bindings": [
        {
          "type": "httpTrigger",
          "direction": "in",
          "name": "req",
          "methods": [
            "get"
          ]
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        },
        {
          "type": "table",
          "name": "inTable",
          "tableName": "person",
          "connection": "",
          "direction": "in"
        }
      ],
      "disabled": false
    },
    "metadata": {
      "defaultFunctionName": "HttpGET-CRUD-CSharp",
      "description": "$HttpGETCRUD_description",
      "name": "HTTP GET",
      "language": "C#",
      "trigger": "HttpTrigger",
      "category": [
        "$temp_category_samples"
      ],
      "categoryStyle": "http",
      "enabledInTryMode": true,
      "userPrompt": [
        "authLevel",
        "tableName",
        "connection"
      ]
    }
  },
  {
    "id": "HttpGET(CRUD)-FSharp",
    "runtime": "1",
    "files": {
      "run.fsx": "#r \"System.Net.Http\"\r\n#r \"Microsoft.WindowsAzure.Storage\"\r\n\r\nopen System.Linq\r\nopen System.Net\r\nopen System.Net.Http\r\nopen Microsoft.WindowsAzure.Storage.Table\r\n\r\ntype Person() =\r\n    inherit TableEntity()\r\n    member val Name: string = null with get, set\r\n\r\nlet Run(req: HttpRequestMessage, inTable: IQueryable<Person>, log: TraceWriter) =\r\n    let people =\r\n        query {\r\n            for person in inTable do\r\n            select person\r\n        }\r\n        |> Seq.map (fun person -> sprintf \"\\\"Name\\\": \\\"%s\\\"\" person.Name)\r\n        |> String.concat \",\"\r\n\r\n    req.CreateResponse(HttpStatusCode.OK, sprintf \"{%s}\" people)\r\n",
      "sample.dat": ""
    },
    "function": {
      "bindings": [
        {
          "type": "httpTrigger",
          "direction": "in",
          "name": "req",
          "methods": [
            "get"
          ]
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        },
        {
          "type": "table",
          "name": "inTable",
          "tableName": "person",
          "connection": "",
          "direction": "in"
        }
      ],
      "disabled": false
    },
    "metadata": {
      "defaultFunctionName": "HttpGET-CRUD-FSharp",
      "description": "$HttpGETCRUD_description",
      "name": "HTTP GET",
      "language": "F#",
      "trigger": "HttpTrigger",
      "category": [
        "$temp_category_samples"
      ],
      "categoryStyle": "http",
      "enabledInTryMode": true,
      "userPrompt": [
        "authLevel",
        "tableName",
        "connection"
      ]
    }
  },
  {
    "id": "HttpGET(CRUD)-JavaScript",
    "runtime": "1",
    "files": {
      "index.js": "module.exports = function (context, req, intable) {\r\n    context.log(\"Retrieved records:\", intable);\r\n    context.res = {\r\n        status: 200,\r\n        body: intable\r\n    };\r\n    context.done();\r\n};",
      "sample.dat": ""
    },
    "function": {
      "bindings": [
        {
          "type": "httpTrigger",
          "direction": "in",
          "name": "req",
          "methods": [
            "get"
          ]
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        },
        {
          "type": "table",
          "name": "inTable",
          "tableName": "person",
          "connection": "",
          "direction": "in"
        }
      ],
      "disabled": false
    },
    "metadata": {
      "defaultFunctionName": "HttpGET-CRUD-JS",
      "description": "$HttpGETCRUD_description",
      "name": "HTTP GET",
      "language": "JavaScript",
      "trigger": "HttpTrigger",
      "category": [
        "$temp_category_samples"
      ],
      "categoryStyle": "http",
      "enabledInTryMode": true,
      "userPrompt": [
        "authLevel",
        "tableName",
        "connection"
      ]
    }
  },
  {
    "id": "HttpGET(CRUD)-PHP",
    "runtime": "1",
    "files": {
      "run.php": "<?php\r\n$inTable = json_decode(file_get_contents(getenv('inTable')));\r\nfile_put_contents(getenv('res'), json_encode($inTable));\r\n?>",
      "sample.dat": ""
    },
    "function": {
      "bindings": [
        {
          "type": "httpTrigger",
          "direction": "in",
          "name": "req",
          "methods": [
            "get"
          ]
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        },
        {
          "type": "table",
          "name": "inTable",
          "tableName": "person",
          "connection": "",
          "direction": "in"
        }
      ],
      "disabled": false
    },
    "metadata": {
      "defaultFunctionName": "HttpGET-CRUD-PHP",
      "description": "$HttpGETCRUD_description",
      "name": "HTTP GET",
      "language": "PHP",
      "trigger": "HttpTrigger",
      "category": [
        "$temp_category_experimental"
      ],
      "categoryStyle": "http",
      "enabledInTryMode": true,
      "userPrompt": [
        "authLevel",
        "tableName",
        "connection"
      ]
    }
  },
  {
    "id": "HttpPOST(CRUD)-CSharp",
    "runtime": "1",
    "files": {
      "run.csx": "#r \"Microsoft.WindowsAzure.Storage\"\r\n\r\nusing System.Net;\r\nusing Microsoft.WindowsAzure.Storage.Table;\r\n\r\npublic static async Task<HttpResponseMessage> Run(HttpRequestMessage req, ICollector<Person> outTable, TraceWriter log)\r\n{\r\n    dynamic data = await req.Content.ReadAsAsync<object>();\r\n    string name = data?.name;\r\n\r\n    if (name == null)\r\n    {\r\n        return req.CreateResponse(HttpStatusCode.BadRequest, \"Please pass a name in the request body\");\r\n    }\r\n\r\n    outTable.Add(new Person()\r\n    {\r\n        PartitionKey = \"Functions\",\r\n        RowKey = Guid.NewGuid().ToString(),\r\n        Name = name\r\n    });\r\n    return req.CreateResponse(HttpStatusCode.Created);\r\n}\r\n\r\npublic class Person : TableEntity\r\n{\r\n    public string Name { get; set; }\r\n}\r\n",
      "sample.dat": "{\r\n    \"name\": \"Azure\"\r\n}"
    },
    "function": {
      "bindings": [
        {
          "type": "httpTrigger",
          "direction": "in",
          "name": "req",
          "methods": [
            "post"
          ]
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        },
        {
          "type": "table",
          "name": "outTable",
          "tableName": "person",
          "connection": "",
          "direction": "out"
        }
      ],
      "disabled": false
    },
    "metadata": {
      "defaultFunctionName": "HttpPOST-CRUD-CSharp",
      "description": "$HttpPOSTCRUD_description",
      "name": "HTTP POST",
      "language": "C#",
      "trigger": "HttpTrigger",
      "category": [
        "$temp_category_samples"
      ],
      "categoryStyle": "http",
      "enabledInTryMode": true,
      "userPrompt": [
        "authLevel",
        "tableName",
        "connection"
      ]
    }
  },
  {
    "id": "HttpPOST(CRUD)-FSharp",
    "runtime": "1",
    "files": {
      "run.fsx": "#r \"System.Net.Http\"\r\n#r \"Microsoft.WindowsAzure.Storage\"\r\n#r \"Newtonsoft.Json\"\r\n\r\nopen System\r\nopen System.Net\r\nopen System.Net.Http\r\nopen Microsoft.WindowsAzure.Storage.Table\r\nopen Newtonsoft.Json\r\nopen Newtonsoft.Json.Linq\r\n\r\ntype Person() =\r\n    inherit TableEntity()\r\n    member val Name: string = null with get, set\r\n\r\nlet Run(req: HttpRequestMessage, outTable: ICollector<Person>, log: TraceWriter) =\r\n    async {\r\n        let! data = req.Content.ReadAsStringAsync() |> Async.AwaitTask\r\n        let json = JObject.Parse(data)\r\n        let nameJ = json.[\"name\"]\r\n\r\n        if nameJ <> null then\r\n            let name = nameJ.Value<string>()\r\n            let person = Person()\r\n            person.PartitionKey <- \"Functions\"\r\n            person.RowKey <- Guid.NewGuid().ToString()\r\n            person.Name <- name\r\n            outTable.Add(person)\r\n\r\n            return req.CreateResponse(HttpStatusCode.Created)\r\n        else\r\n            return req.CreateResponse(HttpStatusCode.BadRequest,\r\n                \"Please pass a name in the request body\")\r\n    } |> Async.StartAsTask\r\n",
      "sample.dat": "{\r\n    \"name\": \"Azure\"\r\n}"
    },
    "function": {
      "bindings": [
        {
          "type": "httpTrigger",
          "direction": "in",
          "name": "req",
          "methods": [
            "post"
          ]
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        },
        {
          "type": "table",
          "name": "outTable",
          "tableName": "person",
          "connection": "",
          "direction": "out"
        }
      ],
      "disabled": false
    },
    "metadata": {
      "defaultFunctionName": "HttpPOST-CRUD-FSharp",
      "description": "$HttpPOSTCRUD_description",
      "name": "HTTP POST",
      "language": "F#",
      "trigger": "HttpTrigger",
      "category": [
        "$temp_category_samples"
      ],
      "categoryStyle": "http",
      "enabledInTryMode": true,
      "userPrompt": [
        "authLevel",
        "tableName",
        "connection"
      ]
    }
  },
  {
    "id": "HttpPOST(CRUD)-JavaScript",
    "runtime": "1",
    "files": {
      "index.js": "module.exports = function (context, req) {\r\n    var statusCode = 400;\r\n    var responseBody = \"Invalid request object\";\r\n\r\n    if (typeof req.body != 'undefined' && typeof req.body == 'object') {\r\n        statusCode = 201;\r\n        context.bindings.outTable = req.body;\r\n        responseBody = \"Table Storage Created\";\r\n    }\r\n\r\n    context.res = {\r\n        status: statusCode,\r\n        body: responseBody\r\n    };\r\n\r\n    context.done();\r\n};",
      "sample.dat": "{\r\n    \"name\": \"Azure\"    \r\n}"
    },
    "function": {
      "bindings": [
        {
          "type": "httpTrigger",
          "direction": "in",
          "name": "req",
          "methods": [
            "post"
          ]
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        },
        {
          "type": "table",
          "name": "outTable",
          "tableName": "person",
          "partitionKey": "functions",
          "rowKey": "{rand-guid}",
          "connection": "",
          "direction": "out"
        }
      ],
      "disabled": false
    },
    "metadata": {
      "defaultFunctionName": "HttpPOST-CRUD-JS",
      "description": "$HttpPOSTCRUD_description",
      "name": "HTTP POST",
      "language": "JavaScript",
      "trigger": "HttpTrigger",
      "category": [
        "$temp_category_samples"
      ],
      "categoryStyle": "http",
      "enabledInTryMode": true,
      "userPrompt": [
        "authLevel",
        "tableName",
        "connection"
      ]
    }
  },
  {
    "id": "HttpPOST(CRUD)Queue-FSharp",
    "runtime": "1",
    "files": {
      "run.fsx": "#r \"System.Net.Http\"\r\n#r \"Microsoft.WindowsAzure.Storage\"\r\n#r \"Newtonsoft.Json\"\r\n\r\nopen System\r\nopen System.Net\r\nopen System.Net.Http\r\nopen Newtonsoft.Json\r\nopen Newtonsoft.Json.Linq\r\nopen Microsoft.WindowsAzure.Storage\r\nopen Microsoft.WindowsAzure.Storage.Queue\r\n\r\ntype Person() =\r\n    member val id: Guid = Guid.NewGuid() with get    \r\n    member val firstName: string = null with get, set    \r\n    member val lastName: string = null with get, set    \r\n    member val address: string = null with get, set    \r\n\r\nlet inline getValue (value:JToken) = \r\n    match isNull value with\r\n    | false -> value.Value<string>()  \r\n    | true -> \"\"\r\n\r\nlet hydrate data = \r\n    let json = JObject.Parse(data)\r\n    let person = Person()\r\n    person.firstName <- getValue json.[\"firstName\"]\r\n    person.lastName <- getValue json.[\"lastName\"] \r\n    person.address <- getValue json.[\"address\"] \r\n    person\r\n\r\nlet isValid (person:Person) =\r\n    [person.firstName; person.lastName; person.address]\r\n    |> List.forall (not << String.IsNullOrEmpty)\r\n\r\nlet Run(req: HttpRequestMessage, personItem:string byref) =\r\n    let data = req.Content.ReadAsStringAsync().Result\r\n    let person = hydrate data\r\n    match isValid person with\r\n    | true -> \r\n        let queueMessage = person |> JsonConvert.SerializeObject\r\n        personItem <- queueMessage\r\n        req.CreateResponse(HttpStatusCode.Created)\r\n    | false ->\r\n        req.CreateResponse(HttpStatusCode.BadRequest, \"Please pass all of the values in the request body\")\r\n",
      "sample.dat": "{\r\n  \"firstName\": \"Test\",\r\n  \"lastName\": \"Person\",\r\n  \"address\": \"123 Main Street\"\r\n}"
    },
    "function": {
      "bindings": [
        {
          "type": "httpTrigger",
          "direction": "in",
          "name": "req",
          "methods": [
            "post"
          ]
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        },
        {
          "type": "queue",
          "name": "personItem",
          "queueName": "person",
          "connection": "",
          "direction": "out"
        }
      ],
      "disabled": false
    },
    "metadata": {
      "defaultFunctionName": "HttpPOST-CRUD-Queue-FSharp",
      "description": "$HttpPOST(CRUD)Queue_description",
      "name": "HTTP POST with Azure Storage Queue",
      "language": "F#",
      "trigger": "HttpTrigger",
      "category": [
        "$temp_category_samples"
      ],
      "categoryStyle": "http",
      "enabledInTryMode": true,
      "userPrompt": [
        "authLevel",
        "queueName",
        "connection"
      ]
    }
  },
  {
    "id": "HttpPUT(CRUD)-CSharp",
    "runtime": "1",
    "files": {
      "run.csx": "#r \"Microsoft.WindowsAzure.Storage\"\r\n\r\nusing System.Net;\r\nusing Microsoft.WindowsAzure.Storage.Table;\r\n\r\npublic static HttpResponseMessage Run(Person person, CloudTable outTable, TraceWriter log)\r\n{\r\n    if (string.IsNullOrEmpty(person.Name))\r\n    {\r\n        return new HttpResponseMessage(HttpStatusCode.BadRequest)\r\n        {\r\n            Content = new StringContent(\"A non-empty Name must be specified.\")\r\n        };\r\n    };\r\n\r\n    log.Info($\"PersonName={person.Name}\");\r\n\r\n    TableOperation updateOperation = TableOperation.InsertOrReplace(person);\r\n    TableResult result = outTable.Execute(updateOperation);\r\n    return new HttpResponseMessage((HttpStatusCode)result.HttpStatusCode);\r\n}\r\n\r\npublic class Person : TableEntity\r\n{\r\n    public string Name { get; set; }\r\n}\r\n",
      "sample.dat": "{\r\n    \"name\": \"Azure\",\r\n    \"partitionKey\": \"Functions\",\r\n    \"rowKey\" :  \"<RowKey>\"\r\n}"
    },
    "function": {
      "bindings": [
        {
          "type": "httpTrigger",
          "direction": "in",
          "name": "person",
          "methods": [
            "put"
          ]
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        },
        {
          "type": "table",
          "name": "outTable",
          "tableName": "person",
          "connection": "",
          "direction": "out"
        }
      ],
      "disabled": false
    },
    "metadata": {
      "defaultFunctionName": "HttpPUT-CRUD-CSharp",
      "description": "$HttpPUTCRUD_description",
      "name": "HTTP PUT",
      "language": "C#",
      "trigger": "HttpTrigger",
      "category": [
        "$temp_category_samples"
      ],
      "categoryStyle": "http",
      "enabledInTryMode": true,
      "userPrompt": [
        "authLevel",
        "tableName",
        "connection"
      ]
    }
  },
  {
    "id": "HttpPUT(CRUD)-FSharp",
    "runtime": "1",
    "files": {
      "run.fsx": "#r \"System.Net.Http\"\r\n#r \"Microsoft.WindowsAzure.Storage\"\r\n#r \"Newtonsoft.Json\"\r\n\r\nopen System\r\nopen System.Net\r\nopen System.Net.Http\r\nopen Microsoft.WindowsAzure.Storage.Table\r\nopen Newtonsoft.Json\r\nopen Newtonsoft.Json.Linq\r\n\r\ntype Person(name, partitionKey, rowKey) =\r\n    inherit TableEntity(partitionKey, rowKey)\r\n    member val Name: string = name with get, set\r\n\r\nlet Run(req: HttpRequestMessage, outTable: CloudTable, log: TraceWriter) =\r\n    async {\r\n        let! data = req.Content.ReadAsStringAsync() |> Async.AwaitTask\r\n        let json = JObject.Parse(data)\r\n        let nameJ = json.[\"name\"]\r\n        let partitionKeyJ = json.[\"partitionKey\"]\r\n        let rowKeyJ = json.[\"rowKey\"]\r\n\r\n        if nameJ = null || partitionKeyJ = null || rowKeyJ = null then\r\n            let response = new HttpResponseMessage(HttpStatusCode.BadRequest)\r\n            response.Content <-\r\n                new StringContent(\"A non-empty name, partitionKey, and rowKey must be specified.\")\r\n            return response\r\n        else\r\n            let person =\r\n                Person(\r\n                    nameJ.Value<string>(),\r\n                    partitionKeyJ.Value<string>(),\r\n                    rowKeyJ.Value<string>())\r\n            log.Info(sprintf \"PersonName=%s\" person.Name)\r\n            let updateOperation = TableOperation.InsertOrReplace(person)\r\n            let result = outTable.Execute(updateOperation)\r\n            return new HttpResponseMessage(enum<HttpStatusCode>(result.HttpStatusCode))\r\n    } |> Async.RunSynchronously\r\n",
      "sample.dat": "{\r\n    \"name\": \"Azure\",\r\n    \"partitionKey\": \"Functions\",\r\n    \"rowKey\" :  \"<RowKey>\"\r\n}"
    },
    "function": {
      "bindings": [
        {
          "type": "httpTrigger",
          "direction": "in",
          "name": "req",
          "methods": [
            "put"
          ]
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        },
        {
          "type": "table",
          "name": "outTable",
          "tableName": "person",
          "connection": "",
          "direction": "out"
        }
      ],
      "disabled": false
    },
    "metadata": {
      "defaultFunctionName": "HttpPUT-CRUD-FSharp",
      "description": "$HttpPUTCRUD_description",
      "name": "HTTP PUT",
      "language": "F#",
      "trigger": "HttpTrigger",
      "category": [
        "$temp_category_samples"
      ],
      "categoryStyle": "http",
      "enabledInTryMode": true,
      "userPrompt": [
        "authLevel",
        "tableName",
        "connection"
      ]
    }
  },
  {
    "id": "HttpTrigger-Batch",
    "runtime": "1",
    "files": {
      "run.bat": "echo OFF\r\n\r\nIF DEFINED req_query_name (\r\n\techo Hello %req_query_name%! > %res%\r\n) ELSE (\r\n\techo Please pass a name on the query string > %res%\r\n)"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "authLevel": "function",
          "name": "req",
          "type": "httpTrigger",
          "direction": "in"
        },
        {
          "name": "res",
          "type": "http",
          "direction": "out"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "HttpTriggerBatch",
      "description": "$HttpTrigger_description",
      "name": "HTTP trigger",
      "language": "Batch",
      "trigger": "HttpTrigger",
      "category": [
        "$temp_category_experimental"
      ],
      "categoryStyle": "http",
      "enabledInTryMode": true,
      "userPrompt": [
        "authLevel"
      ]
    }
  },
  {
    "id": "HttpTrigger-CSharp",
    "runtime": "1",
    "files": {
      "readme.md": "# HttpTrigger - C<span>#</span>\r\n\r\nThe `HttpTrigger` makes it incredibly easy to have your functions executed via an HTTP call to your function.\r\n\r\n## How it works\r\n\r\nWhen you call the function, be sure you checkout which security rules you apply. If you're using an apikey, you'll need to include that in your request.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
      "run.csx": "using System.Net;\r\n\r\npublic static async Task<HttpResponseMessage> Run(HttpRequestMessage req, TraceWriter log)\r\n{\r\n    log.Info(\"C# HTTP trigger function processed a request.\");\r\n\r\n    // parse query parameter\r\n    string name = req.GetQueryNameValuePairs()\r\n        .FirstOrDefault(q => string.Compare(q.Key, \"name\", true) == 0)\r\n        .Value;\r\n\r\n    if (name == null)\r\n    {\r\n        // Get request body\r\n        dynamic data = await req.Content.ReadAsAsync<object>();\r\n        name = data?.name;\r\n    }\r\n\r\n    return name == null\r\n        ? req.CreateResponse(HttpStatusCode.BadRequest, \"Please pass a name on the query string or in the request body\")\r\n        : req.CreateResponse(HttpStatusCode.OK, \"Hello \" + name);\r\n}\r\n",
      "sample.dat": "{\r\n    \"name\": \"Azure\"\r\n}"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "authLevel": "function",
          "name": "req",
          "type": "httpTrigger",
          "direction": "in",
          "methods": [
            "get",
            "post"
          ]
        },
        {
          "name": "$return",
          "type": "http",
          "direction": "out"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "HttpTriggerCSharp",
      "description": "$HttpTrigger_description",
      "name": "HTTP trigger",
      "language": "C#",
      "category": [
        "$temp_category_core",
        "$temp_category_api"
      ],
      "categoryStyle": "http",
      "enabledInTryMode": true,
      "userPrompt": [
        "authLevel"
      ]
    }
  },
  {
    "id": "HttpTrigger-FSharp",
    "runtime": "1",
    "files": {
      "project.json": "{\r\n  \"frameworks\": {\r\n    \"net46\":{\r\n      \"dependencies\": {\r\n        \"FSharp.Interop.Dynamic\": \"3.0.0\"\r\n      }\r\n    }\r\n  }\r\n}\r\n",
      "readme.md": "# HttpTrigger - F<span>#</span>\r\n\r\nThe `HttpTrigger` makes it incredibly easy to have your functions executed via an HTTP call to your function.\r\n\r\n## How it works\r\n\r\nWhen you call the function, be sure you checkout which security rules you apply. If you're using an apikey, you'll need to include that in your request.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
      "run.fsx": "#r \"System.Net.Http\"\r\n#r \"Newtonsoft.Json\"\r\n\r\nopen System.Net\r\nopen System.Net.Http\r\nopen Newtonsoft.Json\r\n\r\ntype Named = {\r\n    name: string\r\n}\r\n\r\nlet Run(req: HttpRequestMessage, log: TraceWriter) =\r\n    async {\r\n        log.Info(sprintf \r\n            \"F# HTTP trigger function processed a request.\")\r\n\r\n        // Set name to query string\r\n        let name =\r\n            req.GetQueryNameValuePairs()\r\n            |> Seq.tryFind (fun q -> q.Key = \"name\")\r\n\r\n        match name with\r\n        | Some x ->\r\n            return req.CreateResponse(HttpStatusCode.OK, \"Hello \" + x.Value);\r\n        | None ->\r\n            let! data = req.Content.ReadAsStringAsync() |> Async.AwaitTask\r\n\r\n            if not (String.IsNullOrEmpty(data)) then\r\n                let named = JsonConvert.DeserializeObject<Named>(data)\r\n                return req.CreateResponse(HttpStatusCode.OK, \"Hello \" + named.name);\r\n            else\r\n                return req.CreateResponse(HttpStatusCode.BadRequest, \"Specify a Name value\");\r\n    } |> Async.RunSynchronously\r\n",
      "sample.dat": "{\r\n    \"name\": \"Azure\"\r\n}"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "authLevel": "function",
          "name": "req",
          "type": "httpTrigger",
          "direction": "in"
        },
        {
          "name": "res",
          "type": "http",
          "direction": "out"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "HttpTriggerFSharp",
      "description": "$HttpTrigger_description",
      "name": "HTTP trigger",
      "language": "F#",
      "category": [
        "$temp_category_core",
        "$temp_category_api"
      ],
      "categoryStyle": "http",
      "enabledInTryMode": true,
      "userPrompt": [
        "authLevel"
      ]
    }
  },
  {
    "id": "HttpTrigger-JavaScript",
    "runtime": "1",
    "files": {
      "index.js": "module.exports = function (context, req) {\r\n    context.log('JavaScript HTTP trigger function processed a request.');\r\n\r\n    if (req.query.name || (req.body && req.body.name)) {\r\n        context.res = {\r\n            // status: 200, /* Defaults to 200 */\r\n            body: \"Hello \" + (req.query.name || req.body.name)\r\n        };\r\n    }\r\n    else {\r\n        context.res = {\r\n            status: 400,\r\n            body: \"Please pass a name on the query string or in the request body\"\r\n        };\r\n    }\r\n    context.done();\r\n};",
      "sample.dat": "{\r\n    \"name\": \"Azure\"\r\n}"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "authLevel": "function",
          "type": "httpTrigger",
          "direction": "in",
          "name": "req"
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "HttpTriggerJS",
      "description": "$HttpTrigger_description",
      "name": "HTTP trigger",
      "language": "JavaScript",
      "trigger": "HttpTrigger",
      "category": [
        "$temp_category_core",
        "$temp_category_api"
      ],
      "categoryStyle": "http",
      "enabledInTryMode": true,
      "userPrompt": [
        "authLevel"
      ]
    }
  },
  {
    "id": "HttpTrigger-Powershell",
    "runtime": "1",
    "files": {
      "readme.md": "# HttpTrigger - PowerShell\r\n\r\nThe `HttpTrigger` makes it incredibly easy to have your functions executed via an HTTP call to your function.\r\n\r\n## How it works\r\n\r\nWhen you call the function, be sure you checkout which security rules you apply. If you're using an apikey, you'll need to include that in your request.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
      "run.ps1": "# POST method: $req\r\n$requestBody = Get-Content $req -Raw | ConvertFrom-Json\r\n$name = $requestBody.name\r\n\r\n# GET method: each querystring parameter is its own variable\r\nif ($req_query_name) \r\n{\r\n    $name = $req_query_name \r\n}\r\n\r\nOut-File -Encoding Ascii -FilePath $res -inputObject \"Hello $name\"\r\n",
      "sample.dat": "{\r\n    \"name\": \"Azure\"\r\n}"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "req",
          "type": "httpTrigger",
          "direction": "in"
        },
        {
          "name": "res",
          "type": "http",
          "direction": "out"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "HttpTriggerPowerShell",
      "description": "$HttpTrigger_description",
      "name": "HTTP trigger",
      "language": "PowerShell",
      "category": [
        "$temp_category_experimental"
      ],
      "categoryStyle": "http",
      "enabledInTryMode": true,
      "userPrompt": [
        "authLevel"
      ]
    }
  },
  {
    "id": "HttpTrigger-Python",
    "runtime": "1",
    "files": {
      "run.py": "import os\r\nimport json\r\n\r\npostreqdata = json.loads(open(os.environ['req']).read())\r\nresponse = open(os.environ['res'], 'w')\r\nresponse.write(\"hello world from \"+postreqdata['name'])\r\nresponse.close()",
      "sample.dat": "{\r\n    \"name\": \"Python Function App\"\r\n}"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "authLevel": "function",
          "type": "httpTrigger",
          "direction": "in",
          "name": "req",
          "methods": [
            "post"
          ]
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "HttpTriggerPython3",
      "description": "$HttpTrigger_description",
      "name": "HTTP trigger",
      "language": "Python",
      "trigger": "HttpTrigger",
      "category": [
        "$temp_category_experimental"
      ],
      "categoryStyle": "http",
      "enabledInTryMode": true,
      "userPrompt": [
        "authLevel"
      ]
    }
  },
  {
    "id": "HttpTrigger-TypeScript",
    "runtime": "1",
    "files": {
      "index.ts": "export function run(context: any, req: any): void {\r\n    context.log(\"TypeScript HTTP trigger function processed a request.\");\r\n\r\n    if (req.query.name || (req.body && req.body.name)) {\r\n        context.res = {\r\n            // status: 200, /* Defaults to 200 */\r\n            body: {\r\n                message: `Hello ${(req.query.name || req.body.name)}`\r\n            }\r\n        };\r\n    } else {\r\n        context.res = {\r\n            status: 400,\r\n            body: \"Please pass a name on the query string or in the request body\"\r\n        };\r\n    }\r\n    context.done();\r\n};",
      "sample.dat": "{\r\n    \"name\": \"Azure\"\r\n}"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "authLevel": "function",
          "type": "httpTrigger",
          "direction": "in",
          "name": "req"
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "HttpTriggerTS",
      "description": "$HttpTrigger_description",
      "name": "HTTP trigger",
      "language": "TypeScript",
      "trigger": "HttpTrigger",
      "category": [
        "$temp_category_experimental"
      ],
      "categoryStyle": "http",
      "enabledInTryMode": true,
      "userPrompt": [
        "authLevel"
      ]
    }
  },
  {
    "id": "HttpTriggerWithParameters-CSharp",
    "runtime": "1",
    "files": {
      "readme.md": "# HttpTrigger - C<span>#</span>\r\n\r\nThe `HttpTrigger` makes it incredibly easy to have your functions executed via an HTTP call to your function.\r\n\r\n## How it works\r\n\r\nWhen you call the function, be sure you checkout which security rules you apply. If you're using an apikey, you'll need to include that in your request.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
      "run.csx": "using System.Net;\r\n\r\npublic static HttpResponseMessage Run(HttpRequestMessage req, string name, TraceWriter log)\r\n{\r\n    log.Info(\"C# HTTP trigger function processed a request.\");\r\n\r\n    // Fetching the name from the path parameter in the request URL\r\n    return req.CreateResponse(HttpStatusCode.OK, \"Hello \" + name);\r\n}\r\n"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "authLevel": "function",
          "name": "req",
          "type": "httpTrigger",
          "direction": "in",
          "route": "HttpTriggerCSharp/name/{name}",
          "methods": [
            "get"
          ]
        },
        {
          "name": "$return",
          "type": "http",
          "direction": "out"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "HttpTriggerCSharpWithParameters",
      "description": "$HttpTriggerWithParameters_description",
      "name": "HTTP trigger with parameters",
      "language": "C#",
      "trigger": "HttpTrigger",
      "category": [
        "$temp_category_core",
        "$temp_category_api"
      ],
      "categoryStyle": "http",
      "enabledInTryMode": true,
      "userPrompt": [
        "authLevel"
      ]
    }
  },
  {
    "id": "HttpTriggerWithParameters-JavaScript",
    "runtime": "1",
    "files": {
      "index.js": "module.exports = function (context, req) {\r\n    context.log('JavaScript HTTP trigger function processed a request.');\r\n    context.res = {\r\n        // status: 200, /* Defaults to 200 */\r\n        body: \"Hello \" + req.params.name\r\n    };\r\n    context.done();\r\n};"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "authLevel": "function",
          "type": "httpTrigger",
          "direction": "in",
          "name": "req",
          "route": "HttpTriggerJS/name/{name}",
          "methods": [
            "get"
          ]
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "HttpTriggerWithParametersJS",
      "description": "$HttpTriggerWithParameters_description",
      "name": "HTTP trigger with parameters",
      "language": "JavaScript",
      "trigger": "HttpTrigger",
      "category": [
        "$temp_category_core",
        "$temp_category_api"
      ],
      "categoryStyle": "http",
      "enabledInTryMode": true,
      "userPrompt": [
        "authLevel"
      ]
    }
  },
  {
    "id": "ImageResizer-CSharp",
    "runtime": "1",
    "files": {
      "project.json": "{\r\n  \"frameworks\": {\r\n    \"net46\":{\r\n      \"dependencies\": {\r\n        \"ImageResizer\": \"4.0.5\"\r\n      }\r\n    }\r\n  }\r\n}\r\n",
      "readme.md": "# Image resizing with a blob trigger - C<span>#</span>\r\n\r\nUsing a blob trigger and the [ImageResizer](https://www.nuget.org/packages/ImageResizer/) nuget package, you can create a function that resizes new images when they are added to a container. This sample shows how to use a blob trigger to trigger the function and how to use output blobs with the same input blob name.\r\n\r\n## How it works\r\n\r\nFor a `BlobTrigger` to work, you provide a path which dictates where the blobs are located inside your container, and can also help restrict the types of blobs you wish to return. For instance, you can set the path to `samples/{name}.png` to restrict the trigger to only the samples path and only blobs with \".png\" at the end of their name.\r\n\r\nThe sample uses different containers for the different image sizes, but you could instead use the same container and rename the image file instead. For instance, the blob path `sample-images/md-{name}` would prepend \"md\" to the input blob name.\r\n\r\n",
      "run.csx": "using ImageResizer;\r\n\r\npublic static void Run(\r\n    Stream image,                           // input blob, large size\r\n    Stream imageSmall,\r\n    Stream imageMedium)  // output blobs\r\n{\r\n    var imageBuilder = ImageResizer.ImageBuilder.Current;\r\n    var size = imageDimensionsTable[ImageSize.Small];\r\n\r\n    imageBuilder.Build(\r\n        image, imageSmall,\r\n        new ResizeSettings(size.Item1, size.Item2, FitMode.Max, null), false);\r\n\r\n    image.Position = 0;\r\n    size = imageDimensionsTable[ImageSize.Medium];\r\n\r\n    imageBuilder.Build(\r\n        image, imageMedium,\r\n        new ResizeSettings(size.Item1, size.Item2, FitMode.Max, null), false);\r\n}\r\n\r\npublic enum ImageSize\r\n{\r\n    ExtraSmall, Small, Medium\r\n}\r\n\r\nprivate static Dictionary<ImageSize, Tuple<int, int>> imageDimensionsTable = new Dictionary<ImageSize, Tuple<int, int>>()\r\n        {\r\n            { ImageSize.ExtraSmall, Tuple.Create(320, 200) },\r\n            { ImageSize.Small,      Tuple.Create(640, 400) },\r\n            { ImageSize.Medium,     Tuple.Create(800, 600) }\r\n        };\r\n"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "path": "sample-images/{name}",
          "type": "blobTrigger",
          "name": "image",
          "direction": "in",
          "connection": ""
        },
        {
          "path": "sample-images-sm/{name}",
          "type": "blob",
          "name": "imageSmall",
          "direction": "out",
          "connection": ""
        },
        {
          "path": "sample-images-md/{name}",
          "type": "blob",
          "name": "imageMedium",
          "direction": "out",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ResizeImageCSharp",
      "description": "$ImageResizer_description",
      "name": "Image resizer",
      "language": "C#",
      "category": [
        "$temp_category_samples"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": true,
      "userPrompt": [
        "connection",
        "path"
      ]
    }
  },
  {
    "id": "ImageResizer-FSharp",
    "runtime": "1",
    "files": {
      "project.json": "{\r\n  \"frameworks\": {\r\n    \"net46\":{\r\n      \"dependencies\": {\r\n        \"ImageResizer\": \"4.0.5\"\r\n      }\r\n    }\r\n  }\r\n}\r\n",
      "readme.md": "# Image resizing with a blob trigger - F<span>#</span>\r\n\r\nUsing a blob trigger and the [ImageResizer](https://www.nuget.org/packages/ImageResizer/) nuget package, you can create a function that resizes new images when they are added to a container. This sample shows how to use a blob trigger to trigger the function and how to use output blobs with the same input blob name.\r\n\r\n## How it works\r\n\r\nFor a `BlobTrigger` to work, you provide a path which dictates where the blobs are located inside your container, and can also help restrict the types of blobs you wish to return. For instance, you can set the path to `samples/{name}.png` to restrict the trigger to only the samples path and only blobs with \".png\" at the end of their name.\r\n\r\nThe sample uses different containers for the different image sizes, but you could instead use the same container and rename the image file instead. For instance, the blob path `sample-images/md-{name}` would prepend \"md\" to the input blob name.\r\n\r\n",
      "run.fsx": "#r \"ImageResizer.dll\"\r\n#r \"System.Drawing.dll\"\r\n\r\nopen System.IO\r\nopen ImageResizer\r\n\r\nlet Run(image: Stream, imageSmall: Stream, imageMedium: Stream) =\r\n    let imageBuilder = ImageResizer.ImageBuilder.Current\r\n\r\n    imageBuilder.Build(\r\n        image, imageSmall, \r\n        ResizeSettings(320, 200, FitMode.Max, null), false)\r\n\r\n    image.Position <- int64 0\r\n\r\n    imageBuilder.Build(\r\n        image, imageMedium,\r\n        ResizeSettings(800, 600, FitMode.Max, null), false)\r\n"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "path": "sample-images/{name}",
          "type": "blobTrigger",
          "name": "image",
          "direction": "in",
          "connection": ""
        },
        {
          "path": "sample-images-sm/{name}",
          "type": "blob",
          "name": "imageSmall",
          "direction": "out",
          "connection": ""
        },
        {
          "path": "sample-images-md/{name}",
          "type": "blob",
          "name": "imageMedium",
          "direction": "out",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ResizeImageFSharp",
      "description": "$ImageResizer_description",
      "name": "Image resizer",
      "language": "F#",
      "category": [
        "$temp_category_samples"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": true,
      "userPrompt": [
        "connection",
        "path"
      ]
    }
  },
  {
    "id": "IoTHubServiceBusQueueTrigger-CSharp",
    "runtime": "1",
    "files": {
      "run.csx": "using System;\r\nusing System.Threading.Tasks;\r\n\r\npublic static void Run(string myQueueItem, TraceWriter log)\r\n{\r\n    log.Info($\"C# ServiceBus queue trigger function processed message: {myQueueItem}\");\r\n}",
      "sample.dat": "Service Bus Message"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "myQueueItem",
          "type": "serviceBusTrigger",
          "direction": "in",
          "queueName": "myqueue",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "IoTHubServiceBusQueueTriggerCSharp",
      "description": "$ServiceBusQueueTrigger_description",
      "name": "IoT Hub (Service Bus Queue)",
      "language": "C#",
      "category": [
        "$temp_category_IoTHub"
      ],
      "categoryStyle": "iot",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "accessRights",
        "queueName"
      ]
    }
  },
  {
    "id": "IoTHubServiceBusQueueTrigger-FSharp",
    "runtime": "1",
    "files": {
      "run.fsx": "let Run(myQueueItem: string, log: TraceWriter) =\r\n    log.Info(sprintf \"F# ServiceBus function processed message: %s\" myQueueItem)\r\n",
      "sample.dat": "Service Bus Message"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "myQueueItem",
          "type": "serviceBusTrigger",
          "direction": "in",
          "queueName": "myqueue",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "IoTHubServiceBusQueueTriggerFSharp",
      "description": "$ServiceBusQueueTrigger_description",
      "name": "IoT Hub (Service Bus Queue)",
      "language": "F#",
      "category": [
        "$temp_category_IoTHub"
      ],
      "categoryStyle": "iot",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "accessRights",
        "queueName"
      ]
    }
  },
  {
    "id": "IoTHubServiceBusQueueTrigger-JavaScript",
    "runtime": "1",
    "files": {
      "index.js": "module.exports = function(context, mySbMsg) {\r\n    context.log('JavaScript ServiceBus queue trigger function processed message:', mySbMsg);\r\n    context.done();\r\n};",
      "sample.dat": "Service Bus Message"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "mySbMsg",
          "type": "serviceBusTrigger",
          "direction": "in",
          "queueName": "myinputqueue",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "IoTHubServiceBusQueueTriggerJS",
      "description": "$ServiceBusQueueTrigger_description",
      "name": "IoT Hub (Service Bus Queue)",
      "language": "JavaScript",
      "category": [
        "$temp_category_IoTHub"
      ],
      "categoryStyle": "iot",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "accessRights",
        "queueName"
      ]
    }
  },
  {
    "id": "IoTHubServiceBusQueueTrigger-TypeScript",
    "runtime": "1",
    "files": {
      "index.ts": "export function run(context: any, mySbMsg: any): void {\r\n    context.log(`TypeScript ServiceBus queue trigger function processed message: ${mySbMsg}`);\r\n    context.done();\r\n};",
      "sample.dat": "Service Bus Message"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "mySbMsg",
          "type": "serviceBusTrigger",
          "direction": "in",
          "queueName": "myinputqueue",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "IoTHubServiceBusQueueTriggerTS",
      "description": "$ServiceBusQueueTrigger_description",
      "name": "IoT Hub (Service Bus Queue)",
      "language": "TypeScript",
      "category": [
        "$temp_category_experimental",
        "$temp_category_IoTHub"
      ],
      "categoryStyle": "iot",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "accessRights",
        "queueName"
      ]
    }
  },
  {
    "id": "IoTHubServiceBusTopicTrigger-CSharp",
    "runtime": "1",
    "files": {
      "run.csx": "using System;\r\nusing System.Threading.Tasks;\r\n\r\npublic static void Run(string mySbMsg, TraceWriter log)\r\n{\r\n    log.Info($\"C# ServiceBus topic trigger function processed message: {mySbMsg}\");\r\n}",
      "sample.dat": "Service Bus Message"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "mySbMsg",
          "type": "serviceBusTrigger",
          "direction": "in",
          "topicName": "mytopic",
          "subscriptionName": "mysubscription",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "IoTHubServiceBusTopicTriggerCSharp",
      "description": "$ServiceBusTopicTrigger_description",
      "name": "IoT Hub (Service Bus Topic)",
      "language": "C#",
      "category": [
        "$temp_category_IoTHub"
      ],
      "categoryStyle": "iot",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "accessRights",
        "topicName",
        "subscriptionName"
      ]
    }
  },
  {
    "id": "IoTHubServiceBusTopicTrigger-FSharp",
    "runtime": "1",
    "files": {
      "run.fsx": "let Run(mySbMsg: string, log: TraceWriter) =\r\n    log.Info(sprintf \"F# ServiceBus function processed message: %s\" mySbMsg)\r\n",
      "sample.dat": "Service Bus Message"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "mySbMsg",
          "type": "serviceBusTrigger",
          "direction": "in",
          "topicName": "mytopic",
          "subscriptionName": "mysubscription",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "IoTHubServiceBusTopicTriggerFSharp",
      "description": "$ServiceBusTopicTrigger_description",
      "name": "IoT Hub (Service Bus Topic)",
      "language": "F#",
      "category": [
        "$temp_category_IoTHub"
      ],
      "categoryStyle": "iot",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "accessRights",
        "topicName",
        "subscriptionName"
      ]
    }
  },
  {
    "id": "IoTHubServiceBusTopicTrigger-JavaScript",
    "runtime": "1",
    "files": {
      "index.js": "module.exports = function(context, mySbMsg) {\r\n    context.log('JavaScript ServiceBus topic trigger function processed message:', mySbMsg);\r\n    context.done();\r\n};",
      "sample.dat": "Service Bus Message"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "mySbMsg",
          "type": "serviceBusTrigger",
          "direction": "in",
          "topicName": "mytopic",
          "subscriptionName": "mysubscription",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "IoTHubServiceBusTopicTriggerJS",
      "description": "$ServiceBusTopicTrigger_description",
      "name": "IoT Hub (Service Bus Topic)",
      "language": "JavaScript",
      "category": [
        "$temp_category_IoTHub"
      ],
      "categoryStyle": "iot",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "accessRights",
        "topicName",
        "subscriptionName"
      ]
    }
  },
  {
    "id": "IoTHubServiceBusTopicTrigger-TypeScript",
    "runtime": "1",
    "files": {
      "index.ts": "export function run(context: any, message: any) {\r\n    context.log(`TypeScript ServiceBus topic trigger function processed message ${message}`);\r\n    context.done();\r\n};",
      "sample.dat": "Service Bus Message"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "mySbMsg",
          "type": "serviceBusTrigger",
          "direction": "in",
          "topicName": "mytopic",
          "subscriptionName": "mysubscription",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "IoTHubServiceBusTopicTriggerTS",
      "description": "$ServiceBusTopicTrigger_description",
      "name": "IoT Hub (Service Bus Topic)",
      "language": "TypeScript",
      "category": [
        "$temp_category_experimental",
        "$temp_category_IoTHub"
      ],
      "categoryStyle": "iot",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "accessRights",
        "topicName",
        "subscriptionName"
      ]
    }
  },
  {
    "id": "IoTHubTrigger-CSharp",
    "runtime": "1",
    "files": {
      "run.csx": "using System;\r\n\r\npublic static void Run(string myIoTHubMessage, TraceWriter log)\r\n{\r\n    log.Info($\"C# IoT Hub trigger function processed a message: {myIoTHubMessage}\");\r\n}",
      "sample.dat": "Test Message"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "type": "eventHubTrigger",
          "name": "myIoTHubMessage",
          "direction": "in",
          "path": "samples-workitems",
          "connection": "",
          "consumerGroup": "$Default"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "IoTHubCSharp_EventHub",
      "description": "$IoTHubTrigger_description",
      "name": "IoT Hub (Event Hub)",
      "language": "C#",
      "category": [
        "$temp_category_IoTHub"
      ],
      "categoryStyle": "iot",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "path",
        "consumerGroup"
      ]
    }
  },
  {
    "id": "IoTHubTrigger-FSharp",
    "runtime": "1",
    "files": {
      "run.fsx": "open System\r\n\r\nlet Run(myIoTHubMessage: string, log: TraceWriter) =\r\n    log.Info(sprintf \"F# IoT Hub trigger function processed a message: %s\" myIoTHubMessage)\r\n",
      "sample.dat": "Test Message"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "type": "eventHubTrigger",
          "name": "myIoTHubMessage",
          "direction": "in",
          "path": "samples-workitems",
          "connection": "",
          "consumerGroup": "$Default"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "IoTHubFSharp_EventHub",
      "description": "$IoTHubTrigger_description",
      "name": "IoT Hub (Event Hub)",
      "language": "F#",
      "category": [
        "$temp_category_IoTHub"
      ],
      "categoryStyle": "iot",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "path",
        "consumerGroup"
      ]
    }
  },
  {
    "id": "IoTHubTrigger-JavaScript",
    "runtime": "1",
    "files": {
      "index.js": "module.exports = function (context, IoTHubMessages) {\r\n    context.log(`JavaScript eventhub trigger function called for message array: ${IoTHubMessages}`);\r\n    \r\n    IoTHubMessages.forEach(message => {\r\n        context.log(`Processed message: ${message}`);\r\n    });\r\n\r\n    context.done();\r\n};",
      "sample.dat": "Test Message"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "type": "eventHubTrigger",
          "name": "IoTHubMessages",
          "direction": "in",
          "path": "samples-workitems",
          "connection": "",
          "cardinality": "many",
          "consumerGroup": "$Default"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "IoT HubJS_EventHub",
      "description": "$IoTHubTrigger_description",
      "name": "IoT Hub (Event Hub)",
      "language": "JavaScript",
      "category": [
        "$temp_category_IoTHub"
      ],
      "categoryStyle": "iot",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "path",
        "consumerGroup"
      ]
    }
  },
  {
    "id": "IoTHubTrigger-TypeScript",
    "runtime": "1",
    "files": {
      "index.ts": "export function run(context: any, IoTHubMessages: any[]): void {\r\n    context.log(`TypeScript eventhub trigger function called for message array ${IoTHubMessages}`);\r\n\r\n    IoTHubMessages.forEach(message => {\r\n        context.log(`Processed message ${message}`);\r\n    });\r\n\r\n    context.done();\r\n};",
      "sample.dat": "Test Message"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "type": "eventHubTrigger",
          "name": "IoTHubMessages",
          "direction": "in",
          "path": "samples-workitems",
          "connection": "",
          "cardinality": "many",
          "consumerGroup": "$Default"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "IoTHubTS_EventHub",
      "description": "$IoTHubTrigger_description",
      "name": "IoT Hub (Event Hub)",
      "language": "TypeScript",
      "category": [
        "$temp_category_experimental",
        "$temp_category_IoTHub"
      ],
      "categoryStyle": "iot",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "path",
        "consumerGroup"
      ]
    }
  },
  {
    "id": "ManualTrigger-CSharp",
    "runtime": "1",
    "files": {
      "run.csx": "using System;\r\n\r\npublic static void Run(string input, TraceWriter log)\r\n{\r\n    log.Info($\"C# manually triggered function called with input: {input}\");\r\n}",
      "sample.dat": "Test Value"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "type": "manualTrigger",
          "direction": "in",
          "name": "input"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ManualTriggerCSharp",
      "description": "$ManualTrigger_description",
      "name": "Manual trigger",
      "trigger": "ManualTrigger",
      "language": "C#",
      "enabledInTryMode": true,
      "category": [
        "$temp_category_core"
      ],
      "categoryStyle": "other"
    }
  },
  {
    "id": "ManualTrigger-FSharp",
    "runtime": "1",
    "files": {
      "run.fsx": "let Run(input: string, log: TraceWriter) =\r\n    log.Info(\r\n        sprintf \"F# manually triggered function called with input: %s\" input)\r\n",
      "sample.dat": "Test Value"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "type": "manualTrigger",
          "direction": "in",
          "name": "input"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ManualTriggerFSharp",
      "description": "$ManualTrigger_description",
      "name": "Manual trigger",
      "trigger": "ManualTrigger",
      "language": "F#",
      "enabledInTryMode": true,
      "category": [
        "$temp_category_core"
      ],
      "categoryStyle": "other"
    }
  },
  {
    "id": "ManualTrigger-JavaScript",
    "runtime": "1",
    "files": {
      "index.js": "module.exports = function (context, input) {\r\n    context.log('JavaScript manually triggered function called with input:', input);\r\n    context.done();\r\n};",
      "sample.dat": "Test Value"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "type": "manualTrigger",
          "direction": "in",
          "name": "input"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ManualTriggerJS",
      "description": "$ManualTrigger_description",
      "name": "Manual trigger",
      "trigger": "ManualTrigger",
      "language": "JavaScript",
      "enabledInTryMode": true,
      "category": [
        "$temp_category_core"
      ],
      "categoryStyle": "other"
    }
  },
  {
    "id": "ManualTrigger-TypeScript",
    "runtime": "1",
    "files": {
      "index.ts": "export function run(context: any, input: any) {\r\n    context.log(`TypeScript manually triggered function called with input: ${input}`);\r\n    context.done();\r\n};",
      "sample.dat": "Test Value"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "type": "manualTrigger",
          "direction": "in",
          "name": "input"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ManualTriggerTS",
      "description": "$ManualTrigger_description",
      "name": "Manual trigger",
      "trigger": "ManualTrigger",
      "language": "TypeScript",
      "enabledInTryMode": true,
      "category": [
        "$temp_category_experimental"
      ],
      "categoryStyle": "other"
    }
  },
  {
    "id": "QueueTrigger-Bash",
    "runtime": "1",
    "files": {
      "run.sh": "inputMessage=$(<$inputMessage)\r\nprintf \"Bash script processed queue message: $inputMessage\"",
      "sample.dat": "sample queue data"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "inputMessage",
          "type": "queueTrigger",
          "direction": "in",
          "queueName": "samples-bash",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "QueueTriggerBash",
      "description": "$QueueTrigger_description",
      "name": "Queue trigger",
      "language": "Bash",
      "trigger": "QueueTrigger",
      "category": [
        "$temp_category_experimental"
      ],
      "categoryStyle": "queue",
      "enabledInTryMode": true,
      "userPrompt": [
        "connection",
        "queueName"
      ]
    }
  },
  {
    "id": "QueueTrigger-Batch",
    "runtime": "1",
    "files": {
      "run.bat": "echo OFF\r\nSET /p inputMessage=<%inputMessage%\r\necho Windows Batch script processed queue message '%inputMessage%'",
      "sample.dat": "sample queue data"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "inputMessage",
          "type": "queueTrigger",
          "direction": "in",
          "queueName": "samples-batch",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "QueueTriggerBatch",
      "description": "$QueueTrigger_description",
      "name": "Queue trigger",
      "language": "Batch",
      "trigger": "QueueTrigger",
      "category": [
        "$temp_category_experimental"
      ],
      "categoryStyle": "queue",
      "enabledInTryMode": true,
      "userPrompt": [
        "connection",
        "queueName"
      ]
    }
  },
  {
    "id": "QueueTrigger-CSharp",
    "runtime": "1",
    "files": {
      "readme.md": "# QueueTrigger - C<span>#</span>\r\n\r\nThe `QueueTrigger` makes it incredibly easy to react to new Queues inside of Azure Queue Storage. This sample demonstrates a simple use case of processing data from a given Queue using C#.\r\n\r\n## How it works\r\n\r\nFor a `QueueTrigger` to work, you must provide a queue name that defines the queue messages will be read from.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
      "run.csx": "using System;\r\n\r\npublic static void Run(string myQueueItem, TraceWriter log)\r\n{\r\n    log.Info($\"C# Queue trigger function processed: {myQueueItem}\");\r\n}\r\n",
      "sample.dat": "sample queue data"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "myQueueItem",
          "type": "queueTrigger",
          "direction": "in",
          "queueName": "myqueue-items",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "QueueTriggerCSharp",
      "description": "$QueueTrigger_description",
      "name": "Queue trigger",
      "language": "C#",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "queue",
      "enabledInTryMode": true,
      "userPrompt": [
        "connection",
        "queueName"
      ]
    }
  },
  {
    "id": "QueueTrigger-FSharp",
    "runtime": "1",
    "files": {
      "readme.md": "# QueueTrigger - F<span>#</span>\r\n\r\nThe `QueueTrigger` makes it incredibly easy to react to new Queues inside of Azure Queue Storage. This sample demonstrates a simple use case of processing data from a given Queue using F#.\r\n\r\n## How it works\r\n\r\nFor a `QueueTrigger` to work, you must provide a queue name that defines the queue messages will be read from.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
      "run.fsx": "let Run(inputMessage: string, log: TraceWriter) =\r\n    log.Info(sprintf \"F# Queue trigger function processed: '%s'\" inputMessage)\r\n",
      "sample.dat": "sample queue data"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "inputMessage",
          "type": "queueTrigger",
          "direction": "in",
          "queueName": "samples-fsharp",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "QueueTriggerFSharp",
      "description": "$QueueTrigger_description",
      "name": "Queue trigger",
      "language": "F#",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "queue",
      "enabledInTryMode": true,
      "userPrompt": [
        "connection",
        "queueName"
      ]
    }
  },
  {
    "id": "QueueTrigger-JavaScript",
    "runtime": "1",
    "files": {
      "index.js": "module.exports = function (context, myQueueItem) {\r\n    context.log('JavaScript queue trigger function processed work item:', myQueueItem);\r\n    context.done();\r\n};",
      "readme.md": "# QueueTrigger - JavaScript\r\n\r\nThe `QueueTrigger` makes it incredibly easy to react to new Queues inside of Azure Queue Storage. This sample demonstrates a simple use case of processing data from a given Queue using C#.\r\n\r\n## How it works\r\n\r\nFor a `QueueTrigger` to work, you provide a path which dictates where the queue messages are located inside your container.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
      "sample.dat": "sample queue data"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "myQueueItem",
          "type": "queueTrigger",
          "direction": "in",
          "queueName": "js-queue-items",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "QueueTriggerJS",
      "description": "$QueueTrigger_description",
      "name": "Queue trigger",
      "language": "JavaScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "queue",
      "enabledInTryMode": true,
      "userPrompt": [
        "connection",
        "queueName"
      ]
    }
  },
  {
    "id": "QueueTrigger-Php",
    "runtime": "1",
    "files": {
      "run.php": "<?php\r\n  $inputMessage = file_get_contents(getenv('inputMessage'));\r\n  $inputMessage = rtrim($inputMessage, \"\\n\\r\");\r\n  fwrite(STDOUT, \"PHP script processed queue message '$inputMessage'\");\r\n?>",
      "sample.dat": "sample queue data"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "inputMessage",
          "type": "queueTrigger",
          "direction": "in",
          "queueName": "samples-php",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "QueueTriggerPHP",
      "description": "$QueueTrigger_description",
      "name": "Queue trigger",
      "language": "PHP",
      "trigger": "QueueTrigger",
      "category": [
        "$temp_category_experimental"
      ],
      "categoryStyle": "queue",
      "enabledInTryMode": true,
      "userPrompt": [
        "connection",
        "queueName"
      ]
    }
  },
  {
    "id": "QueueTrigger-Powershell",
    "runtime": "1",
    "files": {
      "run.ps1": "$in = Get-Content $triggerInput -Raw\r\nWrite-Output \"PowerShell script processed queue message '$in'\"\r\n",
      "sample.dat": "sample queue data"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "triggerInput",
          "type": "queueTrigger",
          "direction": "in",
          "queueName": "samples-powershell",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "QueueTriggerPowerShell",
      "description": "$QueueTrigger_description",
      "name": "Queue trigger",
      "language": "PowerShell",
      "trigger": "QueueTrigger",
      "category": [
        "$temp_category_experimental"
      ],
      "categoryStyle": "queue",
      "enabledInTryMode": true,
      "userPrompt": [
        "connection",
        "queueName"
      ]
    }
  },
  {
    "id": "QueueTrigger-Python",
    "runtime": "1",
    "files": {
      "run.py": "import os\r\n\r\n# read the queue message and write to stdout\r\ninputMessage = open(os.environ['inputMessage']).read()\r\nmessage = \"Python script processed queue message '{0}'\".format(inputMessage)\r\nprint(message)",
      "sample.dat": "sample queue data"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "inputMessage",
          "type": "queueTrigger",
          "direction": "in",
          "queueName": "samples-python",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "QueueTriggerPython",
      "description": "$QueueTrigger_description",
      "name": "Queue trigger",
      "language": "Python",
      "trigger": "QueueTrigger",
      "category": [
        "$temp_category_experimental"
      ],
      "categoryStyle": "queue",
      "enabledInTryMode": true,
      "userPrompt": [
        "connection",
        "queueName"
      ]
    }
  },
  {
    "id": "QueueTrigger-TypeScript",
    "runtime": "1",
    "files": {
      "index.ts": "export function run(context: any, item: any) {\r\n    context.log(`TypeScript queue trigger function processed work item: ${item}`);\r\n    context.done();\r\n};",
      "readme.md": "# QueueTrigger - TypeScript\r\n\r\nThe `QueueTrigger` makes it incredibly easy to react to new Queues inside of Azure Queue Storage. This sample demonstrates a simple use case of processing data from a given Queue using C#.\r\n\r\n## How it works\r\n\r\nFor a `QueueTrigger` to work, you provide a path which dictates where the queue messages are located inside your container.\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
      "sample.dat": "sample queue data"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "myQueueItem",
          "type": "queueTrigger",
          "direction": "in",
          "queueName": "ts-queue-items",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "QueueTriggerTS",
      "description": "$QueueTrigger_description",
      "name": "Queue trigger",
      "language": "TypeScript",
      "category": [
        "$temp_category_experimental"
      ],
      "categoryStyle": "queue",
      "enabledInTryMode": true,
      "userPrompt": [
        "connection",
        "queueName"
      ]
    }
  },
  {
    "id": "SasToken-CSharp",
    "runtime": "1",
    "files": {
      "readme.md": "# SAS Token Generator - C<span>#</span>\r\n\r\nAn HTTP trigger Azure Function that returns a SAS token for Azure Storage for the specified container, blob, and permissions. A SAS token provides a secure way for client apps to access particular storage account resources, without giving them the full control of the storage access key.\r\n\r\n##Calling the function\r\n\r\nTo request a SAS token, send an HTTP post to your function URI, including the API key if you've specified one. The request body format is:\r\n\r\n- `ContainerName` - *required*. Name of container in storage account\r\n- `BlobName` - *optional*. Used to scope permissions to a particular blob\r\n- `Permission` - *optional*. Default value is read permissions. The format matches the enum values of SharedAccessBlobPermissions. Possible values are \"Read\", \"Write\", \"Delete\", \"List\", \"Add\", \"Create\". Comma-separate multiple permissions, such as \"Read, Write, Create\".\r\n\r\n## How it works\r\n\r\nWhen you create a storage account, you get two storage access keys, which provide full control over the storage account contents. Since these keys are admin credentials, they should **never** be distributed with a client app. \r\n\r\nInstead, clients should use a shared access signature (SAS) for delegated access to storage resources. A SAS token, which is appended to a storage resource URI, provides access to only a particular resource for a limited period of time. A SAS token can be scoped to a blob or a container and specifies access permissions (such as read or write).\r\n\r\nA SAS token is usually generated server-side, using the account access key and the Azure Storage SDK. This sample shows how to use an Azure Function as a SAS token service. Web and mobile clients can call this function to request access to a particular container or blob. By default, the sample creates a token that expires after an hour, but this can be customized.\r\n\r\nIf the function will be called from a mobile client or a JavaScript web app, we recommend that you add authentication to your Function using [App Service Authentication/Authorization](https://azure.microsoft.com/en-us/documentation/articles/app-service-authentication-overview/). The API key is usually insufficent for security purposes since it can be discovered by sniffing traffic or decompiling the client app.\r\n\r\n## Learn more\r\n\r\n- [Authentication and authorization in Azure App Service](https://azure.microsoft.com/en-us/documentation/articles/app-service-authentication-overview/)\r\n- [Shared Access Signatures: Understanding the SAS Model](https://azure.microsoft.com/documentation/articles/storage-dotnet-shared-access-signature-part-1/)\r\n- [Create and use a SAS with Blob storage](https://azure.microsoft.com/documentation/articles/storage-dotnet-shared-access-signature-part-2/)\r\n- [Delegating Access with a Shared Access Signature](https://msdn.microsoft.com/library/ee395415.aspx)\r\n- [Establishing a Stored Access Policy](https://msdn.microsoft.com/library/dn140257.aspx)\r\n",
      "run.csx": "// An HTTP trigger Azure Function that returns a SAS token for Azure Storage for the specified container. \r\n// You can also optionally specify a particular blob name and access permissions. \r\n// To learn more, see https://github.com/Azure/azure-webjobs-sdk-templates/blob/master/Templates/SasToken-CSharp/readme.md\r\n\r\n// Request body format:\r\n// - `ContainerName` - *required*. Name of container in storage account\r\n// - `BlobName` - *optional*. Used to scope permissions to a particular blob\r\n// - `Permission` - *optional*. Default value is read permissions. The format matches the enum values of SharedAccessBlobPermissions. \r\n//    Possible values are \"Read\", \"Write\", \"Delete\", \"List\", \"Add\", \"Create\". Comma-separate multiple permissions, such as \"Read, Write, Create\".\r\n#r \"Microsoft.WindowsAzure.Storage\"\r\n\r\nusing System.Net;\r\nusing System.Configuration;\r\nusing Microsoft.WindowsAzure.Storage;\r\nusing Microsoft.WindowsAzure.Storage.Blob;\r\n\r\npublic static HttpResponseMessage Run(Input input, CloudBlobDirectory blobDirectory, TraceWriter log)\r\n{\r\n    var permissions = SharedAccessBlobPermissions.Read; // default to read permissions\r\n\r\n    // if permission was supplied, check if it is a possible value\r\n    if (!string.IsNullOrWhiteSpace(input.Permission))\r\n    {\r\n        if (!Enum.TryParse(input.Permission, out permissions))\r\n        {\r\n            return new HttpResponseMessage(HttpStatusCode.BadRequest) { Content = new StringContent(\"Invalid value for 'permissions'\") };\r\n        }\r\n    }\r\n\r\n    var container = blobDirectory.Container;\r\n    var sasToken = input.BlobName != null ?\r\n         GetBlobSasToken(container, input.BlobName, permissions) :\r\n         GetContainerSasToken(container, permissions);\r\n\r\n    return new HttpResponseMessage(HttpStatusCode.OK) { Content = new StringContent(sasToken) };\r\n}\r\n\r\npublic class Input\r\n{\r\n    public string ContainerName { get; set; }\r\n    public string BlobName { get; set; }\r\n    public string Permission { get; set; }\r\n}\r\n\r\npublic static string GetBlobSasToken(CloudBlobContainer container, string blobName, SharedAccessBlobPermissions permissions, string policyName = null)\r\n{\r\n    string sasBlobToken;\r\n\r\n    // Get a reference to a blob within the container.\r\n    // Note that the blob may not exist yet, but a SAS can still be created for it.\r\n    CloudBlockBlob blob = container.GetBlockBlobReference(blobName);\r\n\r\n    if (policyName == null)\r\n    {\r\n        var adHocSas = CreateAdHocSasPolicy(permissions);\r\n\r\n        // Generate the shared access signature on the blob, setting the constraints directly on the signature.\r\n        sasBlobToken = blob.GetSharedAccessSignature(adHocSas);\r\n    }\r\n    else\r\n    {\r\n        // Generate the shared access signature on the blob. In this case, all of the constraints for the\r\n        // shared access signature are specified on the container's stored access policy.\r\n        sasBlobToken = blob.GetSharedAccessSignature(null, policyName);\r\n    }\r\n\r\n    return sasBlobToken;\r\n}\r\n\r\npublic static string GetContainerSasToken(CloudBlobContainer container, SharedAccessBlobPermissions permissions, string storedPolicyName = null)\r\n{\r\n    string sasContainerToken;\r\n\r\n    // If no stored policy is specified, create a new access policy and define its constraints.\r\n    if (storedPolicyName == null)\r\n    {\r\n        var adHocSas = CreateAdHocSasPolicy(permissions);\r\n\r\n        // Generate the shared access signature on the container, setting the constraints directly on the signature.\r\n        sasContainerToken = container.GetSharedAccessSignature(adHocSas, null);\r\n    }\r\n    else\r\n    {\r\n        // Generate the shared access signature on the container. In this case, all of the constraints for the\r\n        // shared access signature are specified on the stored access policy, which is provided by name.\r\n        // It is also possible to specify some constraints on an ad-hoc SAS and others on the stored access policy.\r\n        // However, a constraint must be specified on one or the other; it cannot be specified on both.\r\n        sasContainerToken = container.GetSharedAccessSignature(null, storedPolicyName);\r\n    }\r\n\r\n    return sasContainerToken;\r\n}\r\n\r\nprivate static SharedAccessBlobPolicy CreateAdHocSasPolicy(SharedAccessBlobPermissions permissions)\r\n{\r\n    // Create a new access policy and define its constraints.\r\n    // Note that the SharedAccessBlobPolicy class is used both to define the parameters of an ad-hoc SAS, and \r\n    // to construct a shared access policy that is saved to the container's shared access policies. \r\n    return new SharedAccessBlobPolicy()\r\n    {\r\n        // Set start time to five minutes before now to avoid clock skew.\r\n        SharedAccessStartTime = DateTime.UtcNow.AddMinutes(-5),\r\n        SharedAccessExpiryTime = DateTime.UtcNow.AddHours(1),\r\n        Permissions = permissions\r\n    };\r\n}\r\n",
      "sample.dat": "{\r\n    \"ContainerName\": \"sample-container\",\r\n    \"BlobName\": \"sample-blob\",\r\n    \"Permission\": \"Read,Write,Create\"\r\n}"
    },
    "function": {
      "bindings": [
        {
          "authLevel": "function",
          "name": "input",
          "type": "httpTrigger",
          "direction": "in",
          "methods": [
            "post"
          ]
        },
        {
          "name": "$return",
          "type": "http",
          "direction": "out"
        },
        {
          "type": "blob",
          "name": "blobDirectory",
          "path": "{ContainerName}",
          "connection": "",
          "direction": "in"
        }
      ],
      "disabled": false
    },
    "metadata": {
      "defaultFunctionName": "SasTokenCSharp",
      "description": "$SasToken_description",
      "name": "SAS Token Generator",
      "language": "C#",
      "category": [
        "$temp_category_samples"
      ],
      "categoryStyle": "blob",
      "enabledInTryMode": true,
      "userPrompt": [
        "authLevel",
        "connection"
      ]
    }
  },
  {
    "id": "SasToken-FSharp",
    "runtime": "1",
    "files": {
      "readme.md": "# SAS Token Generator - F<span>#</span>\r\n\r\nAn HTTP trigger Azure Function that returns a SAS token for Azure Storage for the specified container, blob, and permissions. A SAS token provides a secure way for client apps to access particular storage account resources, without giving them the full control of the storage access key.\r\n\r\n##Calling the function\r\n\r\nTo request a SAS token, send an HTTP post to your function URI, including the API key if you've specified one. The request body format is:\r\n\r\n- `container` - *required*. Name of container in storage account\r\n- `blobName` - *optional*. Used to scope permissions to a particular blob\r\n- `permissions` - *optional*. Default value is read permissions. The format matches the enum values of SharedAccessBlobPermissions. Possible values are \"Read\", \"Write\", \"Delete\", \"List\", \"Add\", \"Create\". Comma-separate multiple permissions, such as \"Read, Write, Create\".\r\n\r\n## How it works\r\n\r\nWhen you create a storage account, you get two storage access keys, which provide full control over the storage account contents. Since these keys are admin credentials, they should **never** be distributed with a client app. \r\n\r\nInstead, clients should use a shared access signature (SAS) for delegated access to storage resources. A SAS token, which is appended to a storage resource URI, provides access to only a particular resource for a limited period of time. A SAS token can be scoped to a blob or a container and specifies access permissions (such as read or write).\r\n\r\nA SAS token is usually generated server-side, using the account access key and the Azure Storage SDK. This sample shows how to use an Azure Function as a SAS token service. Web and mobile clients can call this function to request access to a particular container or blob. By default, the sample creates a token that expires after an hour, but this can be customized.\r\n\r\nIf the function will be called from a mobile client or a JavaScript web app, we recommend that you add authentication to your Function using [App Service Authentication/Authorization](https://azure.microsoft.com/en-us/documentation/articles/app-service-authentication-overview/). The API key is usually insufficent for security purposes since it can be discovered by sniffing traffic or decompiling the client app.\r\n\r\n## Learn more\r\n\r\n- [Authentication and authorization in Azure App Service](https://azure.microsoft.com/en-us/documentation/articles/app-service-authentication-overview/)\r\n- [Shared Access Signatures: Understanding the SAS Model](https://azure.microsoft.com/documentation/articles/storage-dotnet-shared-access-signature-part-1/)\r\n- [Create and use a SAS with Blob storage](https://azure.microsoft.com/documentation/articles/storage-dotnet-shared-access-signature-part-2/)\r\n- [Delegating Access with a Shared Access Signature](https://msdn.microsoft.com/library/ee395415.aspx)\r\n- [Establishing a Stored Access Policy](https://msdn.microsoft.com/library/dn140257.aspx)\r\n",
      "run.fsx": "// An HTTP trigger Azure Function that returns a SAS token for Azure Storage for the specified container. \r\n// You can also optionally specify a particular blob name and access permissions. \r\n// To learn more, see https://github.com/Azure/azure-webjobs-sdk-templates/blob/master/Templates/SasToken-FSharp/readme.md\r\n\r\n#r \"System.Configuration\"\r\n#r \"System.Net.Http\"\r\n#r \"Microsoft.WindowsAzure.Storage\"\r\n#r \"Newtonsoft.Json\"\r\n\r\nopen System\r\nopen System.Net\r\nopen System.Net.Http\r\nopen System.Configuration\r\nopen Microsoft.WindowsAzure.Storage\r\nopen Microsoft.WindowsAzure.Storage.Blob\r\nopen Newtonsoft.Json\r\nopen Newtonsoft.Json.Linq\r\n\r\n// Request body format: \r\n// - `container` - *required*. Name of container in storage account\r\n// - `blobName` - *optional*. Used to scope permissions to a particular blob\r\n// - `permissions` - *optional*. Default value is read permissions. The format matches the enum values of SharedAccessBlobPermissions. \r\n//    Possible values are \"Read\", \"Write\", \"Delete\", \"List\", \"Add\", \"Create\". Comma-separate multiple permissions, such as \"Read, Write, Create\".\r\n\r\ntype Response = {\r\n    Token: string\r\n    Uri: string\r\n}\r\n\r\nlet CreateAdHocSasPolicy permissions =\r\n    let adHocSas = SharedAccessBlobPolicy()\r\n    adHocSas.SharedAccessStartTime <- DateTimeOffset.UtcNow.AddMinutes(-5.) |> Nullable\r\n    adHocSas.SharedAccessExpiryTime <- DateTimeOffset.UtcNow.AddHours(1.) |> Nullable\r\n    adHocSas.Permissions <- permissions\r\n    adHocSas\r\n\r\nlet GetContainerSasToken (container: CloudBlobContainer) permissions =\r\n    let adHocSas = CreateAdHocSasPolicy permissions\r\n    container.GetSharedAccessSignature(adHocSas, null)\r\n\r\nlet GetBlobSasToken (container: CloudBlobContainer) blobName permissions =\r\n    let blob = container.GetBlockBlobReference(blobName)\r\n    let adHocSas = CreateAdHocSasPolicy permissions\r\n    blob.GetSharedAccessSignature(adHocSas)\r\n\r\nlet Run(req: HttpRequestMessage, log: TraceWriter) =\r\n    async {\r\n        let! data = req.Content.ReadAsStringAsync() |> Async.AwaitTask\r\n        let json = JObject.Parse(data)\r\n        let containerJ = json.[\"container\"]\r\n\r\n        if containerJ = null then\r\n            return req.CreateResponse(HttpStatusCode.BadRequest, \"Specify value for container\")\r\n        else\r\n        let container = containerJ.Value<string>()\r\n        let mutable permissions = SharedAccessBlobPermissions.Read\r\n        let reqPermJ = json.[\"permissions\"]\r\n\r\n        if reqPermJ = null then\r\n            return req.CreateResponse(HttpStatusCode.BadRequest, \"Specify value for 'permissions'\")\r\n        else\r\n        let reqPerm = reqPermJ.Value<string>()\r\n        if not (Enum.TryParse(reqPerm, &permissions)) then\r\n            return req.CreateResponse(HttpStatusCode.BadRequest, \"Invalid value for 'permissions'\")\r\n\r\n        else\r\n        let storageAccount = CloudStorageAccount.Parse(ConfigurationManager.AppSettings.Item(\"AzureWebJobsStorage\"))\r\n        let blobClient = storageAccount.CreateCloudBlobClient()\r\n        let container = blobClient.GetContainerReference(container.ToString())\r\n        let blobJ = json.[\"blobName\"]\r\n\r\n        let sasToken =\r\n            if blobJ = null then\r\n                GetContainerSasToken container permissions\r\n            else\r\n                GetBlobSasToken container (blobJ.Value<string>()) permissions\r\n\r\n        return req.CreateResponse(HttpStatusCode.OK, { Token = sasToken; Uri = container.Uri.ToString() + sasToken })\r\n    } |> Async.RunSynchronously\r\n",
      "sample.dat": "{\r\n    \"container\": \"sample-container\", \"permissions\": \"Read,Write,Create\"\r\n}"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "authLevel": "function",
          "name": "req",
          "type": "httpTrigger",
          "direction": "in",
          "methods": [
            "post"
          ]
        },
        {
          "name": "res",
          "type": "http",
          "direction": "out"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "SasTokenFSharp",
      "description": "$SasToken_description",
      "name": "SAS Token Generator",
      "language": "F#",
      "category": [
        "$temp_category_samples"
      ],
      "categoryStyle": "blob",
      "enabledInTryMode": true,
      "userPrompt": [
        "authLevel"
      ]
    }
  },
  {
    "id": "SasToken-JavaScript",
    "runtime": "1",
    "files": {
      "index.js": "// An HTTP trigger Azure Function that returns a SAS token for Azure Storage for the specified container. \r\n// You can also optionally specify a particular blob name and access permissions. \r\n// To learn more, see https://github.com/Azure/azure-webjobs-sdk-templates/blob/master/Templates/SasToken-JavaScript/readme.md\r\n\r\nvar azure = require('azure-storage');\r\n\r\n// Setup: npm install \r\n// Go to Function app settings -> App Service settings -> Tools -> Console and type the following:\r\n//    > cd <functionName>\r\n//    > npm install\r\n// Or, go to http://yoursite.scm.azurewebsites.net/DebugConsole navigate to site/wwwroot/YourFunctionName\r\n// and do npm install in the console window\r\n\r\nmodule.exports = function(context, req) {\r\n    if (req.body.container) {\r\n        // The following values can be used for permissions: \r\n        // \"a\" (Add), \"r\" (Read), \"w\" (Write), \"d\" (Delete), \"l\" (List)\r\n        // Concatenate multiple permissions, such as \"rwa\" = Read, Write, Add\r\n        context.res = generateSasToken(context, req.body.container, req.body.blobName, req.body.permissions);\r\n    } else {\r\n        context.res = {\r\n            status: 400,\r\n            body: \"Specify a value for 'container'\"\r\n        };\r\n    }\r\n    \r\n    context.done();\r\n};\r\n\r\nfunction generateSasToken(context, container, blobName, permissions) {\r\n    var connString = process.env.AzureWebJobsStorage;\r\n    var blobService = azure.createBlobService(connString);\r\n\r\n    // Create a SAS token that expires in an hour\r\n    // Set start time to five minutes ago to avoid clock skew.\r\n    var startDate = new Date();\r\n    startDate.setMinutes(startDate.getMinutes() - 5);\r\n    var expiryDate = new Date(startDate);\r\n    expiryDate.setMinutes(startDate.getMinutes() + 60);\r\n\r\n    permissions = permissions || azure.BlobUtilities.SharedAccessPermissions.READ;\r\n\r\n    var sharedAccessPolicy = {\r\n        AccessPolicy: {\r\n            Permissions: permissions,\r\n            Start: startDate,\r\n            Expiry: expiryDate\r\n        }\r\n    };\r\n    \r\n    var sasToken = blobService.generateSharedAccessSignature(container, blobName, sharedAccessPolicy);\r\n    \r\n    return {\r\n        token: sasToken,\r\n        uri: blobService.getUrl(container, blobName, sasToken, true)\r\n    };\r\n}\r\n",
      "package.json": "{\r\n\t\"version\": \"1.0.0\",\r\n\t\"name\": \"SasToken-JavaScript\",\r\n\t\"private\": true,\r\n\t\"dependencies\": {\r\n\t\t\"azure-storage\": \"1.0.1\"\r\n\t}\r\n}",
      "readme.md": "# SAS Token Generator - JavaScript</span>\r\n\r\nAn HTTP trigger Azure Function that returns a SAS token for Azure Storage for the specified container, blob, and permissions. A SAS token provides a secure way for client apps to access particular storage account resources, without giving them the full control of the storage access key.\r\n\r\n##Calling the function\r\n\r\nTo request a SAS token, send an HTTP post to your function URI, including the API key if you've specified one. The request body format is:\r\n\r\n- `container` - *required*. Name of container in storage account\r\n- `blobName` - *optional*. Used to scope permissions to a particular blob\r\n- `permissions` - *optional*. Default value is read permissions. Possible values are: \"a\" (Add), \"r\" (Read), \"w\" (Write), \"d\" (Delete), \"l\" (List). Concatenate multiple permissions, such as \"rwa\" = Read, Write, Add\r\n\r\nResponse:\r\n\r\n- `token` - SAS token, which does **not** include a leading \"?\"\r\n- `uri` - Resource URI with token appended as query string\r\n\r\n## How it works\r\n\r\nWhen you create a storage account, you get two storage access keys, which provide full control over the storage account contents. Since these keys are admin credentials, they should **never** be distributed with a client app. \r\n\r\nInstead, clients should use a shared access signature (SAS) for delegated access to storage resources. A SAS token, which is appended to a storage resource URI, provides access to only a particular resource for a limited period of time. A SAS token can be scoped to a blob or a container and specifies access permissions (such as read or write).\r\n\r\nA SAS token is usually generated server-side, using the account access key and the Azure Storage SDK. This sample shows how to use an Azure Function as a SAS token service. Web and mobile clients can call this function to request access to a particular container or blob. By default, the sample creates a token that expires after an hour, but this can be customized.\r\n\r\nIf the function will be called from a mobile client or a JavaScript web app, we recommend that you add authentication to your Function using [App Service Authentication/Authorization](https://azure.microsoft.com/en-us/documentation/articles/app-service-authentication-overview/). The API key is usually insufficent for security purposes since it can be discovered by sniffing traffic or decompiling the client app.\r\n\r\n## Learn more\r\n\r\n- [Authentication and authorization in Azure App Service](https://azure.microsoft.com/en-us/documentation/articles/app-service-authentication-overview/)\r\n- [Shared Access Signatures: Understanding the SAS Model](https://azure.microsoft.com/documentation/articles/storage-dotnet-shared-access-signature-part-1/)\r\n- [Create and use a SAS with Blob storage](https://azure.microsoft.com/documentation/articles/storage-dotnet-shared-access-signature-part-2/)\r\n- [Delegating Access with a Shared Access Signature](https://msdn.microsoft.com/library/ee395415.aspx)\r\n- [Establishing a Stored Access Policy](https://msdn.microsoft.com/library/dn140257.aspx)\r\n",
      "sample.dat": "{\r\n    \"container\": \"sample-container\", \"permissions\": \"rwa\"\r\n}"
    },
    "function": {
      "bindings": [
        {
          "authLevel": "function",
          "type": "httpTrigger",
          "direction": "in",
          "name": "req",
          "methods": [
            "post"
          ]
        },
        {
          "type": "http",
          "direction": "out",
          "name": "res"
        }
      ],
      "disabled": false
    },
    "metadata": {
      "defaultFunctionName": "SasTokenJS",
      "description": "$SasToken_description",
      "name": "SAS Token Generator",
      "language": "JavaScript",
      "category": [
        "$temp_category_samples"
      ],
      "categoryStyle": "blob",
      "enabledInTryMode": true,
      "userPrompt": [
        "authLevel"
      ]
    }
  },
  {
    "id": "ScheduledMail-CSharp",
    "runtime": "1",
    "files": {
      "run.csx": "#r \"SendGrid\"\r\n\r\nusing System;\r\nusing SendGrid.Helpers.Mail;\r\nusing Microsoft.Azure.WebJobs.Host;\r\n\r\n// The 'From' and 'To' fields are automatically populated with the values specified by the binding settings.\r\n//\r\n// You can also optionally configure the default From/To addresses globally via host.config, e.g.:\r\n//\r\n// {\r\n//   \"sendGrid\": {\r\n//      \"to\": \"user@host.com\",\r\n//      \"from\": \"Azure Functions <samples@functions.com>\"\r\n//   }\r\n// }\r\npublic static Mail Run(TimerInfo myTimer, TraceWriter log)\r\n{\r\n    var today = DateTime.Today.ToShortDateString();\r\n    log.Info($\"Generating daily report for {today} at {DateTime.Now}\");\r\n    \r\n    Mail message = new Mail()\r\n    {\r\n        Subject = $\"Daily Report for {today}\"\r\n    };\r\n\r\n    // TODO: Customize this code to generate your specific mail message\r\n    var orderCount = 100;\r\n\r\n    Content content = new Content\r\n    {\r\n        Type = \"text/plain\",\r\n        Value = $\"You had {orderCount} orders today!\"\r\n    };\r\n\r\n    message.AddContent(content);\r\n    return message;\r\n}\r\n"
    },
    "function": {
      "bindings": [
        {
          "type": "timerTrigger",
          "name": "myTimer",
          "schedule": "0 0 23 * * *",
          "direction": "in"
        },
        {
          "type": "sendGrid",
          "name": "$return",
          "direction": "out",
          "apiKey": "SendGridApiKey",
          "from": "Azure Functions <samples@functions.com>",
          "to": "user@host.com"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ScheduledMailCSharp",
      "description": "$ScheduledMail_description",
      "name": "Scheduled mail",
      "language": "C#",
      "category": [
        "$temp_category_samples"
      ],
      "categoryStyle": "timer",
      "enabledInTryMode": false,
      "userPrompt": [
        "to",
        "from",
        "apiKey",
        "schedule"
      ]
    }
  },
  {
    "id": "SendGrid-CSharp",
    "runtime": "1",
    "files": {
      "run.csx": "// The 'From' and 'To' fields are automatically populated with the values specified by the binding settings.\r\n//\r\n// You can also optionally configure the default From/To addresses globally via host.config, e.g.:\r\n//\r\n// {\r\n//   \"sendGrid\": {\r\n//      \"to\": \"user@host.com\",\r\n//      \"from\": \"Azure Functions <samples@functions.com>\"\r\n//   }\r\n// }\r\n#r \"SendGrid\"\r\n\r\nusing System;\r\nusing SendGrid.Helpers.Mail;\r\nusing Microsoft.Azure.WebJobs.Host;\r\n\r\npublic static Mail Run(Order order, TraceWriter log)\r\n{\r\n    log.Info($\"C# Queue trigger function processed order: {order.OrderId}\");\r\n\r\n    Mail message = new Mail()\r\n    {\r\n        Subject = $\"Thanks for your order (#{order.OrderId})!\"\r\n    };\r\n\r\n    Content content = new Content\r\n    {\r\n        Type = \"text/plain\",\r\n        Value = $\"{order.CustomerName}, your order ({order.OrderId}) is being processed!\"\r\n    };\r\n\r\n    message.AddContent(content);\r\n    return message;\r\n}\r\npublic class Order\r\n{\r\n    public string OrderId { get; set; }\r\n    public string CustomerName { get; set; }\r\n    public string CustomerEmail { get; set; }\r\n}\r\n",
      "sample.dat": "{ \"OrderId\": 12345, \"CustomerName\": \"Joe Schmoe\", \"CustomerEmail\": \"joeschmoe@foo.com\" }"
    },
    "function": {
      "bindings": [
        {
          "type": "queueTrigger",
          "name": "order",
          "direction": "in",
          "queueName": "samples-orders-csharp"
        },
        {
          "type": "sendGrid",
          "name": "$return",
          "direction": "out",
          "apiKey": "SendGridApiKey",
          "from": "Azure Functions <samples@functions.com>",
          "to": "{CustomerEmail}"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "SendGridCSharp",
      "description": "$SendGrid_description",
      "name": "SendGrid",
      "language": "C#",
      "category": [
        "$temp_category_samples",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": [
        "to",
        "from",
        "apiKey"
      ]
    }
  },
  {
    "id": "SendGrid-FSharp",
    "runtime": "1",
    "files": {
      "run.fsx": "#r \"SendGrid\"\r\n\r\nopen System\r\nopen SendGrid.Helpers.Mail\r\n\r\n// The 'From' and 'To' fields are automatically populated with the values specified by the binding settings.\r\n//\r\n// You can also optionally configure the default From/To addresses globally via host.config, e.g.:\r\n//\r\n// {\r\n//   \"sendGrid\": {\r\n//      \"to\": \"user@host.com\",\r\n//      \"from\": \"Azure Functions <samples@functions.com>\"\r\n//   }\r\n// }\r\n\r\n[<CLIMutable>]\r\ntype Order = {\r\n    OrderId: string\r\n    CustomerName: string\r\n    CustomerEmail: string\r\n}\r\n\r\nlet Run(order: Order, log: TraceWriter) =\r\n    log.Info(\r\n        sprintf \"F# Queue trigger function processed order: %s\" order.OrderId)\r\n\r\n    let message = new Mail()\r\n    message.Subject <- sprintf \"Thanks for your order (#%s)!\" order.OrderId\r\n\r\n    let content =\r\n        Content(\r\n            \"text/plain\",\r\n            sprintf \"%s, your order (%s) is being processed!\"\r\n                order.CustomerName order.OrderId\r\n        )\r\n\r\n    message.AddContent(content)\r\n    message\r\n",
      "sample.dat": "{ \"OrderId\": 12345, \"CustomerName\": \"Joe Schmoe\", \"CustomerEmail\": \"joeschmoe@foo.com\" }"
    },
    "function": {
      "bindings": [
        {
          "type": "queueTrigger",
          "name": "order",
          "direction": "in",
          "queueName": "samples-orders-fsharp"
        },
        {
          "type": "sendGrid",
          "name": "$return",
          "direction": "out",
          "apiKey": "SendGridApiKey",
          "from": "Azure Functions <samples@functions.com>",
          "to": "{CustomerEmail}"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "SendGridFSharp",
      "description": "$SendGrid_description",
      "name": "SendGrid",
      "language": "F#",
      "category": [
        "$temp_category_samples"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": [
        "to",
        "from",
        "subject",
        "text",
        "apiKey"
      ]
    }
  },
  {
    "id": "SendGrid-JavaScript",
    "runtime": "1",
    "files": {
      "index.js": "var util = require('util');\r\n\r\n// The 'From' and 'To' fields are automatically populated with the values specified by the binding settings.\r\n//\r\n// You can also optionally configure the default From/To addresses globally via host.config, e.g.:\r\n//\r\n// {\r\n//   \"sendGrid\": {\r\n//      \"to\": \"user@host.com\",\r\n//      \"from\": \"Azure Functions <samples@functions.com>\"\r\n//   }\r\n// }\r\nmodule.exports = function (context, order) {\r\n    context.log('JavaScript queue trigger function processed order:', order.orderId);\r\n\r\n    context.done(null, {\r\n        message: {\r\n            subject: util.format('Thanks for your order (#%d)!', order.orderId),\r\n            content: [{\r\n                type: 'text/plain',\r\n                value: util.format(\"%s, your order (%d) is being processed!\", order.customerName, order.orderId)\r\n            }]\r\n        }\r\n    });\r\n}",
      "sample.dat": "{ \"orderId\": 12345, \"customerName\": \"Joe Schmoe\", \"customerEmail\": \"joeschmoe@foo.com\" }"
    },
    "function": {
      "bindings": [
        {
          "type": "queueTrigger",
          "name": "order",
          "direction": "in",
          "queueName": "samples-orders"
        },
        {
          "type": "sendGrid",
          "name": "message",
          "direction": "out",
          "apiKey": "SendGridApiKey",
          "from": "Azure Functions <samples@functions.com>",
          "to": "{customerEmail}"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "SendGridJS",
      "description": "$SendGrid_description",
      "name": "SendGrid",
      "language": "JavaScript",
      "category": [
        "$temp_category_samples",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "other",
      "enabledInTryMode": false,
      "userPrompt": [
        "to",
        "from",
        "subject",
        "text",
        "apiKey"
      ]
    }
  },
  {
    "id": "ServiceBusQueueTrigger-CSharp",
    "runtime": "1",
    "files": {
      "run.csx": "using System;\r\nusing System.Threading.Tasks;\r\n\r\npublic static void Run(string myQueueItem, TraceWriter log)\r\n{\r\n    log.Info($\"C# ServiceBus queue trigger function processed message: {myQueueItem}\");\r\n}\r\n",
      "sample.dat": "Service Bus Message"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "myQueueItem",
          "type": "serviceBusTrigger",
          "direction": "in",
          "queueName": "myqueue",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ServiceBusQueueTriggerCSharp",
      "description": "$ServiceBusQueueTrigger_description",
      "name": "Service Bus Queue trigger",
      "language": "C#",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "serviceBus",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "accessRights",
        "queueName"
      ]
    }
  },
  {
    "id": "ServiceBusQueueTrigger-FSharp",
    "runtime": "1",
    "files": {
      "run.fsx": "let Run(myQueueItem: string, log: TraceWriter) =\r\n    log.Info(sprintf \"F# ServiceBus function processed message: %s\" myQueueItem)\r\n",
      "sample.dat": "Service Bus Message"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "myQueueItem",
          "type": "serviceBusTrigger",
          "direction": "in",
          "queueName": "myqueue",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ServiceBusQueueTriggerFSharp",
      "description": "$ServiceBusQueueTrigger_description",
      "name": "Service Bus Queue trigger",
      "language": "F#",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "serviceBus",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "accessRights",
        "queueName"
      ]
    }
  },
  {
    "id": "ServiceBusQueueTrigger-JavaScript",
    "runtime": "1",
    "files": {
      "index.js": "module.exports = function(context, mySbMsg) {\r\n    context.log('JavaScript ServiceBus queue trigger function processed message:', mySbMsg);\r\n    context.done();\r\n};",
      "sample.dat": "Service Bus Message"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "mySbMsg",
          "type": "serviceBusTrigger",
          "direction": "in",
          "queueName": "myinputqueue",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ServiceBusQueueTriggerJS",
      "description": "$ServiceBusQueueTrigger_description",
      "name": "Service Bus Queue trigger",
      "language": "JavaScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "serviceBus",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "accessRights",
        "queueName"
      ]
    }
  },
  {
    "id": "ServiceBusQueueTrigger-TypeScript",
    "runtime": "1",
    "files": {
      "index.ts": "export function run(context: any, mySbMsg: any): void {\r\n    context.log(`TypeScript ServiceBus queue trigger function processed message: ${mySbMsg}`);\r\n    context.done();\r\n};",
      "sample.dat": "Service Bus Message"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "mySbMsg",
          "type": "serviceBusTrigger",
          "direction": "in",
          "queueName": "myinputqueue",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ServiceBusQueueTriggerTS",
      "description": "$ServiceBusQueueTrigger_description",
      "name": "Service Bus Queue trigger",
      "language": "TypeScript",
      "category": [
        "$temp_category_experimental"
      ],
      "categoryStyle": "serviceBus",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "accessRights",
        "queueName"
      ]
    }
  },
  {
    "id": "ServiceBusTopicTrigger-CSharp",
    "runtime": "1",
    "files": {
      "run.csx": "using System;\r\nusing System.Threading.Tasks;\r\n\r\npublic static void Run(string mySbMsg, TraceWriter log)\r\n{\r\n    log.Info($\"C# ServiceBus topic trigger function processed message: {mySbMsg}\");\r\n}\r\n",
      "sample.dat": "Service Bus Message"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "mySbMsg",
          "type": "serviceBusTrigger",
          "direction": "in",
          "topicName": "mytopic",
          "subscriptionName": "mysubscription",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ServiceBusTopicTriggerCSharp",
      "description": "$ServiceBusTopicTrigger_description",
      "name": "Service Bus Topic trigger",
      "language": "C#",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "serviceBus",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "accessRights",
        "topicName",
        "subscriptionName"
      ]
    }
  },
  {
    "id": "ServiceBusTopicTrigger-FSharp",
    "runtime": "1",
    "files": {
      "run.fsx": "let Run(mySbMsg: string, log: TraceWriter) =\r\n    log.Info(sprintf \"F# ServiceBus function processed message: %s\" mySbMsg)\r\n",
      "sample.dat": "Service Bus Message"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "mySbMsg",
          "type": "serviceBusTrigger",
          "direction": "in",
          "topicName": "mytopic",
          "subscriptionName": "mysubscription",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ServiceBusTopicTriggerFSharp",
      "description": "$ServiceBusTopicTrigger_description",
      "name": "Service Bus Topic trigger",
      "language": "F#",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "serviceBus",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "accessRights",
        "topicName",
        "subscriptionName"
      ]
    }
  },
  {
    "id": "ServiceBusTopicTrigger-JavaScript",
    "runtime": "1",
    "files": {
      "index.js": "module.exports = function(context, mySbMsg) {\r\n    context.log('JavaScript ServiceBus topic trigger function processed message:', mySbMsg);\r\n    context.done();\r\n};",
      "sample.dat": "Service Bus Message"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "mySbMsg",
          "type": "serviceBusTrigger",
          "direction": "in",
          "topicName": "mytopic",
          "subscriptionName": "mysubscription",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ServiceBusTopicTriggerJS",
      "description": "$ServiceBusTopicTrigger_description",
      "name": "Service Bus Topic trigger",
      "language": "JavaScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "serviceBus",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "accessRights",
        "topicName",
        "subscriptionName"
      ]
    }
  },
  {
    "id": "ServiceBusTopicTrigger-TypeScript",
    "runtime": "1",
    "files": {
      "index.ts": "export function run(context: any, message: any) {\r\n    context.log(`TypeScript ServiceBus topic trigger function processed message ${message}`);\r\n    context.done();\r\n};",
      "sample.dat": "Service Bus Message"
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "mySbMsg",
          "type": "serviceBusTrigger",
          "direction": "in",
          "topicName": "mytopic",
          "subscriptionName": "mysubscription",
          "connection": ""
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "ServiceBusTopicTriggerTS",
      "description": "$ServiceBusTopicTrigger_description",
      "name": "Service Bus Topic trigger",
      "language": "TypeScript",
      "category": [
        "$temp_category_experimental"
      ],
      "categoryStyle": "serviceBus",
      "enabledInTryMode": false,
      "userPrompt": [
        "connection",
        "accessRights",
        "topicName",
        "subscriptionName"
      ]
    }
  },
  {
    "id": "TimerTrigger-CSharp",
    "runtime": "1",
    "files": {
      "readme.md": "# TimerTrigger - C<span>#</span>\r\n\r\nThe `TimerTrigger` makes it incredibly easy to have your functions executed on a schedule. This sample demonstrates a simple use case of calling your function every 5 minutes.\r\n\r\n## How it works\r\n\r\nFor a `TimerTrigger` to work, you provide a schedule in the form of a [cron expression](https://en.wikipedia.org/wiki/Cron#CRON_expression)(See the link for full details). A cron expression is a string with 6 separate expressions which represent a given schedule via patterns. The pattern we use to represent every 5 minutes is `0 */5 * * * *`. This, in plain text, means: \"When seconds is equal to 0, minutes is divisible by 5, for any hour, day of the month, month, day of the week, or year\".\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
      "run.csx": "using System;\r\n\r\npublic static void Run(TimerInfo myTimer, TraceWriter log)\r\n{\r\n    log.Info($\"C# Timer trigger function executed at: {DateTime.Now}\");\r\n}\r\n",
      "sample.dat": ""
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "myTimer",
          "type": "timerTrigger",
          "direction": "in",
          "schedule": "0 */5 * * * *"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "TimerTriggerCSharp",
      "description": "$TimerTrigger_description",
      "name": "Timer trigger",
      "language": "C#",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "timer",
      "enabledInTryMode": true,
      "userPrompt": [
        "schedule"
      ]
    }
  },
  {
    "id": "TimerTrigger-FSharp",
    "runtime": "1",
    "files": {
      "readme.md": "# TimerTrigger - F<span>#</span>\r\n\r\nThe `TimerTrigger` makes it incredibly easy to have your functions executed on a schedule. This sample demonstrates a simple use case of calling your function every 5 minutes.\r\n\r\n## How it works\r\n\r\nFor a `TimerTrigger` to work, you provide a schedule in the form of a [cron expression](https://en.wikipedia.org/wiki/Cron#CRON_expression)(See the link for full details). A cron expression is a string with 6 separate expressions which represent a given schedule via patterns. The pattern we use to represent every 5 minutes is `0 */5 * * * *`. This, in plain text, means: \"When seconds is equal to 0, minutes is divisible by 5, for any hour, day of the month, month, day of the week, or year\".\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
      "run.fsx": "open System\r\n\r\nlet Run(myTimer: TimerInfo, log: TraceWriter) =\r\n    log.Info(\r\n        sprintf \"F# Timer trigger function executed at: %s\" \r\n            (DateTime.Now.ToString()))\r\n",
      "sample.dat": ""
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "myTimer",
          "type": "timerTrigger",
          "direction": "in",
          "schedule": "0 */5 * * * *"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "TimerTriggerFSharp",
      "description": "$TimerTrigger_description",
      "name": "Timer trigger",
      "language": "F#",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "timer",
      "enabledInTryMode": true,
      "userPrompt": [
        "schedule"
      ]
    }
  },
  {
    "id": "TimerTrigger-JavaScript",
    "runtime": "1",
    "files": {
      "index.js": "module.exports = function (context, myTimer) {\r\n    var timeStamp = new Date().toISOString();\r\n    \r\n    if(myTimer.isPastDue)\r\n    {\r\n        context.log('JavaScript is running late!');\r\n    }\r\n    context.log('JavaScript timer trigger function ran!:', timeStamp);   \r\n    \r\n    context.done();\r\n};",
      "readme.md": "# TimerTrigger - JavaScript\r\n\r\nThe `TimerTrigger` makes it incredibly easy to have your functions executed on a schedule. This sample demonstrates a simple use case of calling your function every 5 minutes.\r\n\r\n## How it works\r\n\r\nFor a `TimerTrigger` to work, you provide a schedule in the form of a [cron expression](https://en.wikipedia.org/wiki/Cron#CRON_expression)(See the link for full details). A cron expression is a string with 6 separate expressions which represent a given schedule via patterns. The pattern we use to represent every 5 minutes is `0 */5 * * * *`. This, in plain text, means: \"When seconds is equal to 0, minutes is divisible by 5, for any hour, day of the month, month, day of the week, or year\".\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
      "sample.dat": ""
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "myTimer",
          "type": "timerTrigger",
          "direction": "in",
          "schedule": "0 */5 * * * *"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "TimerTriggerJS",
      "description": "$TimerTrigger_description",
      "name": "Timer trigger",
      "language": "JavaScript",
      "category": [
        "$temp_category_core",
        "$temp_category_dataProcessing"
      ],
      "categoryStyle": "timer",
      "enabledInTryMode": true,
      "userPrompt": [
        "schedule"
      ]
    }
  },
  {
    "id": "TimerTrigger-Powershell",
    "runtime": "1",
    "files": {
      "readme.md": "# TimerTrigger - PowerShell\r\n\r\nThe `TimerTrigger` makes it incredibly easy to have your functions executed on a schedule. This sample demonstrates a simple use case of calling your function every minute.\r\n\r\n## How it works\r\n\r\nFor a `TimerTrigger` to work, you provide a schedule in the form of a [cron expression](https://en.wikipedia.org/wiki/Cron#CRON_expression)(See the link for full details). A cron expression is a string with 6 separate expressions which represent a given schedule via patterns. The pattern we use to represent every 5 minutes is `0 */5 * * * *`. This, in plain text, means: \"When seconds is equal to 0, minutes is divisible by 5, for any hour, day of the month, month, day of the week, or year\".",
      "run.ps1": "Write-Output \"PowerShell Timer trigger function executed at:$(get-date)\";",
      "sample.dat": ""
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "myTimer",
          "type": "timerTrigger",
          "direction": "in",
          "schedule": "0 */5 * * * *"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "TimerTriggerPowerShell",
      "description": "$TimerTrigger_description",
      "name": "Timer trigger",
      "language": "PowerShell",
      "category": [
        "$temp_category_experimental"
      ],
      "categoryStyle": "timer",
      "enabledInTryMode": true,
      "userPrompt": [
        "schedule"
      ]
    }
  },
  {
    "id": "TimerTrigger-TypeScript",
    "runtime": "1",
    "files": {
      "index.ts": "export function run(context: any, myTimer: any): any {\r\n    const timeStamp: string = new Date().toISOString();\r\n\r\n    if(myTimer.isPastDue) {\r\n        context.log(`TypeScript is running late!`);\r\n    }\r\n    context.log(`TypeScript timer trigger function ran! ${timeStamp}`);\r\n\r\n    context.done();\r\n};",
      "readme.md": "# TimerTrigger - TypeScript\r\n\r\nThe `TimerTrigger` makes it incredibly easy to have your functions executed on a schedule. This sample demonstrates a simple use case of calling your function every 5 minutes.\r\n\r\n## How it works\r\n\r\nFor a `TimerTrigger` to work, you provide a schedule in the form of a [cron expression](https://en.wikipedia.org/wiki/Cron#CRON_expression)(See the link for full details). A cron expression is a string with 6 separate expressions which represent a given schedule via patterns. The pattern we use to represent every 5 minutes is `0 */5 * * * *`. This, in plain text, means: \"When seconds is equal to 0, minutes is divisible by 5, for any hour, day of the month, month, day of the week, or year\".\r\n\r\n## Learn more\r\n\r\n<TODO> Documentation",
      "sample.dat": ""
    },
    "function": {
      "disabled": false,
      "bindings": [
        {
          "name": "myTimer",
          "type": "timerTrigger",
          "direction": "in",
          "schedule": "0 */5 * * * *"
        }
      ]
    },
    "metadata": {
      "defaultFunctionName": "TimerTriggerTS",
      "description": "$TimerTrigger_description",
      "name": "Timer trigger",
      "language": "TypeScript",
      "category": [
        "$temp_category_experimental"
      ],
      "categoryStyle": "timer",
      "enabledInTryMode": true,
      "userPrompt": [
        "schedule"
      ]
    }
  }
]